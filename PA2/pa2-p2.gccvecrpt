
Analyzing loop at pa2-p2.c:66

pa2-p2.c:66: note: ===== analyze_loop_nest =====
pa2-p2.c:66: note: === vect_analyze_loop_form ===
pa2-p2.c:66: note: not vectorized: multiple nested loops.
pa2-p2.c:66: note: bad loop form.
Analyzing loop at pa2-p2.c:66

pa2-p2.c:66: note: ===== analyze_loop_nest =====
pa2-p2.c:66: note: === vect_analyze_loop_form ===
pa2-p2.c:66: note: not vectorized: multiple nested loops.
pa2-p2.c:66: note: bad loop form.
Analyzing loop at pa2-p2.c:71

pa2-p2.c:71: note: ===== analyze_loop_nest =====
pa2-p2.c:71: note: === vect_analyze_loop_form ===
pa2-p2.c:71: note: not vectorized: multiple nested loops.
pa2-p2.c:71: note: bad loop form.
Analyzing loop at pa2-p2.c:72

pa2-p2.c:72: note: ===== analyze_loop_nest =====
pa2-p2.c:72: note: === vect_analyze_loop_form ===
pa2-p2.c:72: note: ===== analyze_loop_nest_1 =====
pa2-p2.c:72: note: === vect_analyze_loop_form ===
pa2-p2.c:72: note: === get_loop_niters ===
pa2-p2.c:72: note: ==> get_loop_niters:2000
pa2-p2.c:72: note: Considering outer-loop vectorization.
pa2-p2.c:72: note: === get_loop_niters ===
pa2-p2.c:72: note: ==> get_loop_niters:2000 - (unsigned int) k_89
pa2-p2.c:72: note: Symbolic number of iterations is 2000 - (unsigned int) k_89
pa2-p2.c:72: note: === vect_analyze_data_refs ===

pa2-p2.c:72: note: get vectype with 4 units of type float
pa2-p2.c:72: note: vectype: vector(4) float
pa2-p2.c:72: note: analyze in outer-loop: c
pa2-p2.c:72: note: 	outer base_address: &c
	outer offset from base address: (ssizetype) ((sizetype) j_15 * 8000)
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 64
pa2-p2.c:72: note: get vectype with 4 units of type float
pa2-p2.c:72: note: vectype: vector(4) float
pa2-p2.c:72: note: analyze in outer-loop: a
pa2-p2.c:72: note: 	outer base_address: &a
	outer offset from base address: (ssizetype) ((sizetype) k_89 * 8000)
	outer constant offset from base address: 0
	outer step: 8000
	outer aligned to: 64
pa2-p2.c:72: note: get vectype with 4 units of type float
pa2-p2.c:72: note: vectype: vector(4) float
pa2-p2.c:72: note: analyze in outer-loop: c
pa2-p2.c:72: note: 	outer base_address: &c
	outer offset from base address: (ssizetype) ((sizetype) j_15 * 8000)
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 64
pa2-p2.c:72: note: get vectype with 4 units of type float
pa2-p2.c:72: note: vectype: vector(4) float
pa2-p2.c:72: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:72: note: Analyze phi: .MEM_20 = PHI <.MEM_85(33), .MEM_82(22)>

pa2-p2.c:72: note: Analyze phi: k_87 = PHI <k_89(33), k_76(22)>

pa2-p2.c:72: note: Access function of PHI: {k_89, +, 1}_7
pa2-p2.c:72: note: step: 1,  init: k_89
pa2-p2.c:72: note: Detected induction.
pa2-p2.c:72: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:72: note: Analyze phi: i_103 = PHI <i_83(27), 0(23)>

pa2-p2.c:72: note: Access function of PHI: {0, +, 1}_8
pa2-p2.c:72: note: step: 1,  init: 0
pa2-p2.c:72: note: Detected induction.
pa2-p2.c:72: note: Analyze phi: .MEM_86 = PHI <.MEM_82(27), .MEM_20(23)>

pa2-p2.c:72: note: Analyze phi: ivtmp_150 = PHI <ivtmp_152(27), 2000(23)>

pa2-p2.c:72: note: Access function of PHI: {2000, +, 4294967295}_8
pa2-p2.c:72: note: step: 4294967295,  init: 2000
pa2-p2.c:72: note: Detected induction.
pa2-p2.c:72: note: === vect_pattern_recog ===
pa2-p2.c:72: note: vect_is_simple_use: operand _78
pa2-p2.c:72: note: def_stmt: _78 = a[k_87][i_103];

pa2-p2.c:72: note: type of def: 3.
pa2-p2.c:72: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p2.c:72: note: init: phi relevant? .MEM_20 = PHI <.MEM_85(33), .MEM_82(22)>

pa2-p2.c:72: note: init: phi relevant? k_87 = PHI <k_89(33), k_76(22)>

pa2-p2.c:72: note: init: stmt relevant? # DEBUG k => k_87

pa2-p2.c:72: note: init: stmt relevant? # DEBUG i => 0

pa2-p2.c:72: note: init: stmt relevant? pretmp_158 = b[k_87][j_15];

pa2-p2.c:72: note: init: phi relevant? i_103 = PHI <i_83(27), 0(23)>

pa2-p2.c:72: note: init: phi relevant? .MEM_86 = PHI <.MEM_82(27), .MEM_20(23)>

pa2-p2.c:72: note: init: phi relevant? ivtmp_150 = PHI <ivtmp_152(27), 2000(23)>

pa2-p2.c:72: note: init: stmt relevant? # DEBUG i => i_103

pa2-p2.c:72: note: init: stmt relevant? _77 = c[j_15][i_103];

pa2-p2.c:72: note: init: stmt relevant? _78 = a[k_87][i_103];

pa2-p2.c:72: note: init: stmt relevant? _80 = _78 * pretmp_158;

pa2-p2.c:72: note: init: stmt relevant? _81 = _77 + _80;

pa2-p2.c:72: note: init: stmt relevant? c[j_15][i_103] = _81;

pa2-p2.c:72: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:72: note: mark relevant 4, live 0.
pa2-p2.c:72: note: init: stmt relevant? i_83 = i_103 + 1;

pa2-p2.c:72: note: init: stmt relevant? # DEBUG i => i_83

pa2-p2.c:72: note: init: stmt relevant? # DEBUG i => i_83

pa2-p2.c:72: note: init: stmt relevant? ivtmp_152 = ivtmp_150 - 1;

pa2-p2.c:72: note: init: stmt relevant? if (ivtmp_152 != 0)

pa2-p2.c:72: note: init: stmt relevant? k_76 = k_87 + 1;

pa2-p2.c:72: note: init: stmt relevant? # DEBUG k => k_76

pa2-p2.c:72: note: init: stmt relevant? # DEBUG k => k_76

pa2-p2.c:72: note: init: stmt relevant? if (k_76 != 2000)

pa2-p2.c:72: note: worklist: examine stmt: c[j_15][i_103] = _81;

pa2-p2.c:72: note: vect_is_simple_use: operand _81
pa2-p2.c:72: note: def_stmt: _81 = _77 + _80;

pa2-p2.c:72: note: type of def: 3.
pa2-p2.c:72: note: mark relevant 4, live 0.
pa2-p2.c:72: note: worklist: examine stmt: _81 = _77 + _80;

pa2-p2.c:72: note: vect_is_simple_use: operand _77
pa2-p2.c:72: note: def_stmt: _77 = c[j_15][i_103];

pa2-p2.c:72: note: type of def: 3.
pa2-p2.c:72: note: mark relevant 4, live 0.
pa2-p2.c:72: note: vect_is_simple_use: operand _80
pa2-p2.c:72: note: def_stmt: _80 = _78 * pretmp_158;

pa2-p2.c:72: note: type of def: 3.
pa2-p2.c:72: note: mark relevant 4, live 0.
pa2-p2.c:72: note: worklist: examine stmt: _80 = _78 * pretmp_158;

pa2-p2.c:72: note: vect_is_simple_use: operand _78
pa2-p2.c:72: note: def_stmt: _78 = a[k_87][i_103];

pa2-p2.c:72: note: type of def: 3.
pa2-p2.c:72: note: mark relevant 4, live 0.
pa2-p2.c:72: note: vect_is_simple_use: operand pretmp_158
pa2-p2.c:72: note: def_stmt: pretmp_158 = b[k_87][j_15];

pa2-p2.c:72: note: type of def: 3.
pa2-p2.c:72: note: outer-loop def-stmt defining inner-loop stmt.
pa2-p2.c:72: note: mark relevant 4, live 0.
pa2-p2.c:72: note: worklist: examine stmt: pretmp_158 = b[k_87][j_15];

pa2-p2.c:72: note: worklist: examine stmt: _78 = a[k_87][i_103];

pa2-p2.c:72: note: worklist: examine stmt: _77 = c[j_15][i_103];

pa2-p2.c:72: note: === vect_analyze_dependences ===
pa2-p2.c:72: note: dependence distance  = 0.
pa2-p2.c:72: note: dependence distance == 0 between c[j_15][i_103] and c[j_15][i_103]
pa2-p2.c:72: note: dependence distance  = 1.
pa2-p2.c:72: note: not vectorized, possible dependence between data-refs c[j_15][i_103] and c[j_15][i_103]
pa2-p2.c:72: note: bad data dependence.
Analyzing loop at pa2-p2.c:73

pa2-p2.c:73: note: ===== analyze_loop_nest =====
pa2-p2.c:73: note: === vect_analyze_loop_form ===
pa2-p2.c:73: note: === get_loop_niters ===
pa2-p2.c:73: note: ==> get_loop_niters:2000
pa2-p2.c:73: note: === vect_analyze_data_refs ===

pa2-p2.c:73: note: get vectype with 4 units of type float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: get vectype with 4 units of type float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: get vectype with 4 units of type float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:73: note: Analyze phi: i_103 = PHI <i_83(27), 0(23)>

pa2-p2.c:73: note: Access function of PHI: {0, +, 1}_8
pa2-p2.c:73: note: step: 1,  init: 0
pa2-p2.c:73: note: Detected induction.
pa2-p2.c:73: note: Analyze phi: .MEM_86 = PHI <.MEM_82(27), .MEM_20(23)>

pa2-p2.c:73: note: Analyze phi: ivtmp_150 = PHI <ivtmp_152(27), 2000(23)>

pa2-p2.c:73: note: Access function of PHI: {2000, +, 4294967295}_8
pa2-p2.c:73: note: step: 4294967295,  init: 2000
pa2-p2.c:73: note: Detected induction.
pa2-p2.c:73: note: === vect_pattern_recog ===
pa2-p2.c:73: note: vect_is_simple_use: operand _78
pa2-p2.c:73: note: def_stmt: _78 = a[k_87][i_103];

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p2.c:73: note: init: phi relevant? i_103 = PHI <i_83(27), 0(23)>

pa2-p2.c:73: note: init: phi relevant? .MEM_86 = PHI <.MEM_82(27), .MEM_20(23)>

pa2-p2.c:73: note: init: phi relevant? ivtmp_150 = PHI <ivtmp_152(27), 2000(23)>

pa2-p2.c:73: note: init: stmt relevant? # DEBUG i => i_103

pa2-p2.c:73: note: init: stmt relevant? _77 = c[j_15][i_103];

pa2-p2.c:73: note: init: stmt relevant? _78 = a[k_87][i_103];

pa2-p2.c:73: note: init: stmt relevant? _80 = _78 * pretmp_158;

pa2-p2.c:73: note: init: stmt relevant? _81 = _77 + _80;

pa2-p2.c:73: note: init: stmt relevant? c[j_15][i_103] = _81;

pa2-p2.c:73: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:73: note: mark relevant 4, live 0.
pa2-p2.c:73: note: init: stmt relevant? i_83 = i_103 + 1;

pa2-p2.c:73: note: init: stmt relevant? # DEBUG i => i_83

pa2-p2.c:73: note: init: stmt relevant? # DEBUG i => i_83

pa2-p2.c:73: note: init: stmt relevant? ivtmp_152 = ivtmp_150 - 1;

pa2-p2.c:73: note: init: stmt relevant? if (ivtmp_152 != 0)

pa2-p2.c:73: note: worklist: examine stmt: c[j_15][i_103] = _81;

pa2-p2.c:73: note: vect_is_simple_use: operand _81
pa2-p2.c:73: note: def_stmt: _81 = _77 + _80;

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: mark relevant 4, live 0.
pa2-p2.c:73: note: worklist: examine stmt: _81 = _77 + _80;

pa2-p2.c:73: note: vect_is_simple_use: operand _77
pa2-p2.c:73: note: def_stmt: _77 = c[j_15][i_103];

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: mark relevant 4, live 0.
pa2-p2.c:73: note: vect_is_simple_use: operand _80
pa2-p2.c:73: note: def_stmt: _80 = _78 * pretmp_158;

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: mark relevant 4, live 0.
pa2-p2.c:73: note: worklist: examine stmt: _80 = _78 * pretmp_158;

pa2-p2.c:73: note: vect_is_simple_use: operand _78
pa2-p2.c:73: note: def_stmt: _78 = a[k_87][i_103];

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: mark relevant 4, live 0.
pa2-p2.c:73: note: vect_is_simple_use: operand pretmp_158
pa2-p2.c:73: note: def_stmt: pretmp_158 = b[k_87][j_15];

pa2-p2.c:73: note: type of def: 2.
pa2-p2.c:73: note: def_stmt is out of loop.
pa2-p2.c:73: note: worklist: examine stmt: _78 = a[k_87][i_103];

pa2-p2.c:73: note: worklist: examine stmt: _77 = c[j_15][i_103];

pa2-p2.c:73: note: === vect_analyze_dependences ===
pa2-p2.c:73: note: dependence distance  = 0.
pa2-p2.c:73: note: dependence distance == 0 between c[j_15][i_103] and c[j_15][i_103]
pa2-p2.c:73: note: === vect_determine_vectorization_factor ===
pa2-p2.c:73: note: ==> examining phi: i_103 = PHI <i_83(27), 0(23)>

pa2-p2.c:73: note: ==> examining phi: .MEM_86 = PHI <.MEM_82(27), .MEM_20(23)>

pa2-p2.c:73: note: ==> examining phi: ivtmp_150 = PHI <ivtmp_152(27), 2000(23)>

pa2-p2.c:73: note: ==> examining statement: # DEBUG i => i_103

pa2-p2.c:73: note: skip.
pa2-p2.c:73: note: ==> examining statement: _77 = c[j_15][i_103];

pa2-p2.c:73: note: get vectype for scalar type:  float
pa2-p2.c:73: note: get vectype with 4 units of type float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: nunits = 4
pa2-p2.c:73: note: ==> examining statement: _78 = a[k_87][i_103];

pa2-p2.c:73: note: get vectype for scalar type:  float
pa2-p2.c:73: note: get vectype with 4 units of type float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: nunits = 4
pa2-p2.c:73: note: ==> examining statement: _80 = _78 * pretmp_158;

pa2-p2.c:73: note: get vectype for scalar type:  float
pa2-p2.c:73: note: get vectype with 4 units of type float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: get vectype for scalar type:  float
pa2-p2.c:73: note: get vectype with 4 units of type float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: nunits = 4
pa2-p2.c:73: note: ==> examining statement: _81 = _77 + _80;

pa2-p2.c:73: note: get vectype for scalar type:  float
pa2-p2.c:73: note: get vectype with 4 units of type float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: get vectype for scalar type:  float
pa2-p2.c:73: note: get vectype with 4 units of type float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: nunits = 4
pa2-p2.c:73: note: ==> examining statement: c[j_15][i_103] = _81;

pa2-p2.c:73: note: get vectype for scalar type:  float
pa2-p2.c:73: note: get vectype with 4 units of type float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: nunits = 4
pa2-p2.c:73: note: ==> examining statement: i_83 = i_103 + 1;

pa2-p2.c:73: note: skip.
pa2-p2.c:73: note: ==> examining statement: # DEBUG i => i_83

pa2-p2.c:73: note: skip.
pa2-p2.c:73: note: ==> examining statement: # DEBUG i => i_83

pa2-p2.c:73: note: skip.
pa2-p2.c:73: note: ==> examining statement: ivtmp_152 = ivtmp_150 - 1;

pa2-p2.c:73: note: skip.
pa2-p2.c:73: note: ==> examining statement: if (ivtmp_152 != 0)

pa2-p2.c:73: note: skip.
pa2-p2.c:73: note: vectorization factor = 4
pa2-p2.c:73: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:73: note: dependence distance  = 0.
pa2-p2.c:73: note: accesses have the same alignment.dependence distance modulo vf == 0 between c[j_15][i_103] and c[j_15][i_103]
pa2-p2.c:73: note: vect_compute_data_ref_alignment:
pa2-p2.c:73: note: misalign = 0 bytes of ref c[j_15][i_103]
pa2-p2.c:73: note: vect_compute_data_ref_alignment:
pa2-p2.c:73: note: misalign = 0 bytes of ref a[k_87][i_103]
pa2-p2.c:73: note: vect_compute_data_ref_alignment:
pa2-p2.c:73: note: misalign = 0 bytes of ref c[j_15][i_103]
pa2-p2.c:73: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:73: note: === vect_prune_runtime_alias_test_list ===
pa2-p2.c:73: note: === vect_enhance_data_refs_alignment ===
pa2-p2.c:73: note: vect_can_advance_ivs_p:
pa2-p2.c:73: note: Analyze phi: i_103 = PHI <i_83(27), 0(23)>

pa2-p2.c:73: note: Access function of PHI: {0, +, 1}_8
pa2-p2.c:73: note: Analyze phi: .MEM_86 = PHI <.MEM_82(27), .MEM_20(23)>

pa2-p2.c:73: note: virtual phi. skip.
pa2-p2.c:73: note: Analyze phi: ivtmp_150 = PHI <ivtmp_152(27), 2000(23)>

pa2-p2.c:73: note: Access function of PHI: {2000, +, 4294967295}_8
pa2-p2.c:73: note: vect_model_load_cost: aligned.
pa2-p2.c:73: note: vect_get_data_access_cost: inside_cost = 1, outside_cost = 0.
pa2-p2.c:73: note: vect_model_load_cost: aligned.
pa2-p2.c:73: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
pa2-p2.c:73: note: vect_model_store_cost: aligned.
pa2-p2.c:73: note: vect_get_data_access_cost: inside_cost = 3, outside_cost = 0.
pa2-p2.c:73: note: === vect_analyze_slp ===
pa2-p2.c:73: note: === vect_make_slp_decision ===
pa2-p2.c:73: note: === vect_detect_hybrid_slp ===
pa2-p2.c:73: note: === vect_analyze_loop_operations ===
pa2-p2.c:73: note: examining phi: i_103 = PHI <i_83(27), 0(23)>

pa2-p2.c:73: note: examining phi: .MEM_86 = PHI <.MEM_82(27), .MEM_20(23)>

pa2-p2.c:73: note: examining phi: ivtmp_150 = PHI <ivtmp_152(27), 2000(23)>

pa2-p2.c:73: note: ==> examining statement: # DEBUG i => i_103

pa2-p2.c:73: note: irrelevant.
pa2-p2.c:73: note: ==> examining statement: _77 = c[j_15][i_103];

pa2-p2.c:73: note: num. args = 4 (not unary/binary/ternary op).
pa2-p2.c:73: note: vect_is_simple_use: operand c[j_15][i_103]
pa2-p2.c:73: note: not ssa-name.
pa2-p2.c:73: note: use not simple.
pa2-p2.c:73: note: vect_model_load_cost: aligned.
pa2-p2.c:73: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:73: note: ==> examining statement: _78 = a[k_87][i_103];

pa2-p2.c:73: note: num. args = 4 (not unary/binary/ternary op).
pa2-p2.c:73: note: vect_is_simple_use: operand a[k_87][i_103]
pa2-p2.c:73: note: not ssa-name.
pa2-p2.c:73: note: use not simple.
pa2-p2.c:73: note: vect_model_load_cost: aligned.
pa2-p2.c:73: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:73: note: ==> examining statement: _80 = _78 * pretmp_158;

pa2-p2.c:73: note: vect_is_simple_use: operand _78
pa2-p2.c:73: note: def_stmt: _78 = a[k_87][i_103];

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: vect_is_simple_use: operand pretmp_158
pa2-p2.c:73: note: def_stmt: pretmp_158 = b[k_87][j_15];

pa2-p2.c:73: note: type of def: 2.
pa2-p2.c:73: note: === vectorizable_operation ===
pa2-p2.c:73: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p2.c:73: note: ==> examining statement: _81 = _77 + _80;

pa2-p2.c:73: note: vect_is_simple_use: operand _77
pa2-p2.c:73: note: def_stmt: _77 = c[j_15][i_103];

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: vect_is_simple_use: operand _80
pa2-p2.c:73: note: def_stmt: _80 = _78 * pretmp_158;

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: === vectorizable_operation ===
pa2-p2.c:73: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:73: note: ==> examining statement: c[j_15][i_103] = _81;

pa2-p2.c:73: note: vect_is_simple_use: operand _81
pa2-p2.c:73: note: def_stmt: _81 = _77 + _80;

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: vect_model_store_cost: aligned.
pa2-p2.c:73: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:73: note: ==> examining statement: i_83 = i_103 + 1;

pa2-p2.c:73: note: irrelevant.
pa2-p2.c:73: note: ==> examining statement: # DEBUG i => i_83

pa2-p2.c:73: note: irrelevant.
pa2-p2.c:73: note: ==> examining statement: # DEBUG i => i_83

pa2-p2.c:73: note: irrelevant.
pa2-p2.c:73: note: ==> examining statement: ivtmp_152 = ivtmp_150 - 1;

pa2-p2.c:73: note: irrelevant.
pa2-p2.c:73: note: ==> examining statement: if (ivtmp_152 != 0)

pa2-p2.c:73: note: irrelevant.
pa2-p2.c:73: note: vectorization_factor = 4, niters = 2000
pa2-p2.c:73: note: === vect_update_slp_costs_according_to_vf ===
pa2-p2.c:73: note: Cost model analysis: 
  Vector inside of loop cost: 5
  Vector prologue cost: 1
  Vector epilogue cost: 0
  Scalar iteration cost: 5
  Scalar outside cost: 0
  Vector outside cost: 1
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

pa2-p2.c:73: note:   Runtime profitability threshold = 3

pa2-p2.c:73: note:   Static estimate profitability threshold = 3


Vectorizing loop at pa2-p2.c:73

pa2-p2.c:73: note: === vec_transform_loop ===
pa2-p2.c:73: note: ------>vectorizing phi: i_103 = PHI <i_83(27), 0(36)>

pa2-p2.c:73: note: ------>vectorizing phi: .MEM_86 = PHI <.MEM_82(27), .MEM_20(36)>

pa2-p2.c:73: note: ------>vectorizing phi: ivtmp_150 = PHI <ivtmp_152(27), 2000(36)>

pa2-p2.c:73: note: ------>vectorizing statement: # DEBUG i => i_103

pa2-p2.c:73: note: ------>vectorizing statement: _77 = c[j_15][i_103];

pa2-p2.c:73: note: transform statement.
pa2-p2.c:73: note: transform load. ncopies = 1
pa2-p2.c:73: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:73: note: created vect_pc.15_79
pa2-p2.c:73: note: add new stmt: vect_var_.16_144 = MEM[(float[2000][2000] *)vect_pc.12_49];

pa2-p2.c:73: note: ------>vectorizing statement: _78 = a[k_87][i_103];

pa2-p2.c:73: note: transform statement.
pa2-p2.c:73: note: transform load. ncopies = 1
pa2-p2.c:73: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: a
pa2-p2.c:73: note: created vect_pa.20_141
pa2-p2.c:73: note: add new stmt: vect_var_.21_138 = MEM[(float[2000][2000] *)vect_pa.17_140];

pa2-p2.c:73: note: ------>vectorizing statement: _80 = _78 * pretmp_158;

pa2-p2.c:73: note: transform statement.
pa2-p2.c:73: note: vect_is_simple_use: operand _78
pa2-p2.c:73: note: def_stmt: _78 = a[k_87][i_103];

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: vect_is_simple_use: operand pretmp_158
pa2-p2.c:73: note: def_stmt: pretmp_158 = b[k_87][j_15];

pa2-p2.c:73: note: type of def: 2.
pa2-p2.c:73: note: transform binary/unary operation.
pa2-p2.c:73: note: vect_get_vec_def_for_operand: _78
pa2-p2.c:73: note: vect_is_simple_use: operand _78
pa2-p2.c:73: note: def_stmt: _78 = a[k_87][i_103];

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: def =  _78  def_stmt =  _78 = a[k_87][i_103];

pa2-p2.c:73: note: vect_get_vec_def_for_operand: pretmp_158
pa2-p2.c:73: note: vect_is_simple_use: operand pretmp_158
pa2-p2.c:73: note: def_stmt: pretmp_158 = b[k_87][j_15];

pa2-p2.c:73: note: type of def: 2.
pa2-p2.c:73: note: def =  pretmp_158  def_stmt =  pretmp_158 = b[k_87][j_15];

pa2-p2.c:73: note: get vectype with 4 units of type float
pa2-p2.c:73: note: vectype: vector(4) float
pa2-p2.c:73: note: Create vector_inv.
pa2-p2.c:73: note: created new init_stmt: vect_cst_.23_134 = {pretmp_158, pretmp_158, pretmp_158, pretmp_158};

pa2-p2.c:73: note: add new stmt: vect_var_.22_133 = vect_var_.21_138 * vect_cst_.23_134;

pa2-p2.c:73: note: ------>vectorizing statement: _81 = _77 + _80;

pa2-p2.c:73: note: transform statement.
pa2-p2.c:73: note: vect_is_simple_use: operand _77
pa2-p2.c:73: note: def_stmt: _77 = c[j_15][i_103];

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: vect_is_simple_use: operand _80
pa2-p2.c:73: note: def_stmt: _80 = _78 * pretmp_158;

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: transform binary/unary operation.
pa2-p2.c:73: note: vect_get_vec_def_for_operand: _77
pa2-p2.c:73: note: vect_is_simple_use: operand _77
pa2-p2.c:73: note: def_stmt: _77 = c[j_15][i_103];

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: def =  _77  def_stmt =  _77 = c[j_15][i_103];

pa2-p2.c:73: note: vect_get_vec_def_for_operand: _80
pa2-p2.c:73: note: vect_is_simple_use: operand _80
pa2-p2.c:73: note: def_stmt: _80 = _78 * pretmp_158;

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: def =  _80  def_stmt =  _80 = _78 * pretmp_158;

pa2-p2.c:73: note: add new stmt: vect_var_.24_132 = vect_var_.16_144 + vect_var_.22_133;

pa2-p2.c:73: note: ------>vectorizing statement: c[j_15][i_103] = _81;

pa2-p2.c:73: note: transform statement.
pa2-p2.c:73: note: vect_is_simple_use: operand _81
pa2-p2.c:73: note: def_stmt: _81 = _77 + _80;

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: transform store. ncopies = 1
pa2-p2.c:73: note: vect_get_vec_def_for_operand: _81
pa2-p2.c:73: note: vect_is_simple_use: operand _81
pa2-p2.c:73: note: def_stmt: _81 = _77 + _80;

pa2-p2.c:73: note: type of def: 3.
pa2-p2.c:73: note: def =  _81  def_stmt =  _81 = _77 + _80;

pa2-p2.c:73: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:73: note: created vect_pc.28_129
pa2-p2.c:73: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.25_128] = vect_var_.24_132;

pa2-p2.c:73: note: ------>vectorizing statement: i_83 = i_103 + 1;

pa2-p2.c:73: note: ------>vectorizing statement: # DEBUG i => i_83

pa2-p2.c:73: note: ------>vectorizing statement: # DEBUG i => i_83

pa2-p2.c:73: note: ------>vectorizing statement: ivtmp_152 = ivtmp_150 - 1;

pa2-p2.c:73: note: ------>vectorizing statement: vect_pc.12_22 = vect_pc.12_49 + 16;

pa2-p2.c:73: note: ------>vectorizing statement: vect_pa.17_139 = vect_pa.17_140 + 16;

pa2-p2.c:73: note: ------>vectorizing statement: vect_pc.25_127 = vect_pc.25_128 + 16;

pa2-p2.c:73: note: ------>vectorizing statement: if (ivtmp_152 != 0)

loop at pa2-p2.c:74: if (ivtmp_125 < 500)

pa2-p2.c:73: note: LOOP VECTORIZED.
Analyzing loop at pa2-p2.c:77

pa2-p2.c:77: note: ===== analyze_loop_nest =====
pa2-p2.c:77: note: === vect_analyze_loop_form ===
pa2-p2.c:77: note: not vectorized: multiple nested loops.
pa2-p2.c:77: note: bad loop form.
Analyzing loop at pa2-p2.c:78

pa2-p2.c:78: note: ===== analyze_loop_nest =====
pa2-p2.c:78: note: === vect_analyze_loop_form ===
pa2-p2.c:78: note: ===== analyze_loop_nest_1 =====
pa2-p2.c:78: note: === vect_analyze_loop_form ===
pa2-p2.c:78: note: === get_loop_niters ===
pa2-p2.c:78: note: ==> get_loop_niters:2000
pa2-p2.c:78: note: Considering outer-loop vectorization.
pa2-p2.c:78: note: === get_loop_niters ===
pa2-p2.c:78: note: ==> get_loop_niters:12
pa2-p2.c:78: note: === vect_analyze_data_refs ===

pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: analyze in outer-loop: c
pa2-p2.c:78: note: 	outer base_address: &c
	outer offset from base address: (ssizetype) ((sizetype) j_37 * 8000)
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 64
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: analyze in outer-loop: a
pa2-p2.c:78: note: 	outer base_address: &a
	outer offset from base address: (ssizetype) ((sizetype) k_89 * 8000)
	outer constant offset from base address: 0
	outer step: 8000
	outer aligned to: 64
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: analyze in outer-loop: c
pa2-p2.c:78: note: 	outer base_address: &c
	outer offset from base address: (ssizetype) ((sizetype) j_37 * 8000)
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 64
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: analyze in outer-loop: *(&c + 8000)
pa2-p2.c:78: note: 	outer base_address: &c
	outer offset from base address: (ssizetype) ((sizetype) j_37 * 8000)
	outer constant offset from base address: 8000
	outer step: 0
	outer aligned to: 64
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: analyze in outer-loop: *(&c + 8000)
pa2-p2.c:78: note: 	outer base_address: &c
	outer offset from base address: (ssizetype) ((sizetype) j_37 * 8000)
	outer constant offset from base address: 8000
	outer step: 0
	outer aligned to: 64
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: analyze in outer-loop: *(&c + 16000)
pa2-p2.c:78: note: 	outer base_address: &c
	outer offset from base address: (ssizetype) ((sizetype) j_37 * 8000)
	outer constant offset from base address: 16000
	outer step: 0
	outer aligned to: 64
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: analyze in outer-loop: *(&c + 16000)
pa2-p2.c:78: note: 	outer base_address: &c
	outer offset from base address: (ssizetype) ((sizetype) j_37 * 8000)
	outer constant offset from base address: 16000
	outer step: 0
	outer aligned to: 64
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: analyze in outer-loop: *(&c + 24000)
pa2-p2.c:78: note: 	outer base_address: &c
	outer offset from base address: (ssizetype) ((sizetype) j_37 * 8000)
	outer constant offset from base address: 24000
	outer step: 0
	outer aligned to: 64
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: analyze in outer-loop: *(&c + 24000)
pa2-p2.c:78: note: 	outer base_address: &c
	outer offset from base address: (ssizetype) ((sizetype) j_37 * 8000)
	outer constant offset from base address: 24000
	outer step: 0
	outer aligned to: 64
pa2-p2.c:78: note: get vectype with 4 units of type float
pa2-p2.c:78: note: vectype: vector(4) float
pa2-p2.c:78: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:78: note: Analyze phi: k_17 = PHI <k_40(34), k_89(15)>

pa2-p2.c:78: note: Access function of PHI: {k_89, +, 1}_4
pa2-p2.c:78: note: step: 1,  init: k_89
pa2-p2.c:78: note: Detected induction.
pa2-p2.c:78: note: Analyze phi: .MEM_58 = PHI <.MEM_70(34), .MEM_93(15)>

pa2-p2.c:78: note: Analyze phi: ivtmp_47 = PHI <ivtmp_51(34), 12(15)>

pa2-p2.c:78: note: Access function of PHI: {12, +, 4294967295}_4
pa2-p2.c:78: note: step: 4294967295,  init: 12
pa2-p2.c:78: note: Detected induction.
pa2-p2.c:78: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:78: note: Analyze phi: i_101 = PHI <i_71(20), 0(35)>

pa2-p2.c:78: note: Access function of PHI: {0, +, 1}_5
pa2-p2.c:78: note: step: 1,  init: 0
pa2-p2.c:78: note: Detected induction.
pa2-p2.c:78: note: Analyze phi: .MEM_99 = PHI <.MEM_70(20), .MEM_58(35)>

pa2-p2.c:78: note: Analyze phi: ivtmp_154 = PHI <ivtmp_43(20), 2000(35)>

pa2-p2.c:78: note: Access function of PHI: {2000, +, 4294967295}_5
pa2-p2.c:78: note: step: 4294967295,  init: 2000
pa2-p2.c:78: note: Detected induction.
pa2-p2.c:78: note: === vect_pattern_recog ===
pa2-p2.c:78: note: vect_is_simple_use: operand _42
pa2-p2.c:78: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: vect_is_simple_use: operand _42
pa2-p2.c:78: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: vect_is_simple_use: operand _42
pa2-p2.c:78: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: vect_is_simple_use: operand _42
pa2-p2.c:78: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p2.c:78: note: init: phi relevant? k_17 = PHI <k_40(34), k_89(15)>

pa2-p2.c:78: note: init: phi relevant? .MEM_58 = PHI <.MEM_70(34), .MEM_93(15)>

pa2-p2.c:78: note: init: phi relevant? ivtmp_47 = PHI <ivtmp_51(34), 12(15)>

pa2-p2.c:78: note: init: stmt relevant? # DEBUG k => k_17

pa2-p2.c:78: note: init: stmt relevant? # DEBUG i => 0

pa2-p2.c:78: note: init: stmt relevant? pretmp_148 = b[k_17][j_37];

pa2-p2.c:78: note: init: stmt relevant? pretmp_151 = b[k_17][pretmp_145];

pa2-p2.c:78: note: init: stmt relevant? pretmp_153 = b[k_17][pretmp_146];

pa2-p2.c:78: note: init: stmt relevant? pretmp_155 = b[k_17][pretmp_147];

pa2-p2.c:78: note: init: phi relevant? i_101 = PHI <i_71(20), 0(35)>

pa2-p2.c:78: note: init: phi relevant? .MEM_99 = PHI <.MEM_70(20), .MEM_58(35)>

pa2-p2.c:78: note: init: phi relevant? ivtmp_154 = PHI <ivtmp_43(20), 2000(35)>

pa2-p2.c:78: note: init: stmt relevant? # DEBUG i => i_101

pa2-p2.c:78: note: init: stmt relevant? _41 = c[j_37][i_101];

pa2-p2.c:78: note: init: stmt relevant? _42 = a[k_17][i_101];

pa2-p2.c:78: note: init: stmt relevant? _44 = _42 * pretmp_148;

pa2-p2.c:78: note: init: stmt relevant? _45 = _41 + _44;

pa2-p2.c:78: note: init: stmt relevant? c[j_37][i_101] = _45;

pa2-p2.c:78: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: init: stmt relevant? _48 = c[pretmp_145][i_101];

pa2-p2.c:78: note: init: stmt relevant? _52 = _42 * pretmp_151;

pa2-p2.c:78: note: init: stmt relevant? _53 = _48 + _52;

pa2-p2.c:78: note: init: stmt relevant? c[pretmp_145][i_101] = _53;

pa2-p2.c:78: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: init: stmt relevant? _56 = c[pretmp_146][i_101];

pa2-p2.c:78: note: init: stmt relevant? _60 = _42 * pretmp_153;

pa2-p2.c:78: note: init: stmt relevant? _61 = _56 + _60;

pa2-p2.c:78: note: init: stmt relevant? c[pretmp_146][i_101] = _61;

pa2-p2.c:78: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: init: stmt relevant? _64 = c[pretmp_147][i_101];

pa2-p2.c:78: note: init: stmt relevant? _68 = _42 * pretmp_155;

pa2-p2.c:78: note: init: stmt relevant? _69 = _64 + _68;

pa2-p2.c:78: note: init: stmt relevant? c[pretmp_147][i_101] = _69;

pa2-p2.c:78: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: init: stmt relevant? i_71 = i_101 + 1;

pa2-p2.c:78: note: init: stmt relevant? # DEBUG i => i_71

pa2-p2.c:78: note: init: stmt relevant? # DEBUG i => i_71

pa2-p2.c:78: note: init: stmt relevant? ivtmp_43 = ivtmp_154 - 1;

pa2-p2.c:78: note: init: stmt relevant? if (ivtmp_43 != 0)

pa2-p2.c:78: note: init: stmt relevant? k_40 = k_17 + 1;

pa2-p2.c:78: note: init: stmt relevant? # DEBUG k => k_40

pa2-p2.c:78: note: init: stmt relevant? # DEBUG k => k_40

pa2-p2.c:78: note: init: stmt relevant? ivtmp_51 = ivtmp_47 - 1;

pa2-p2.c:78: note: init: stmt relevant? if (ivtmp_51 != 0)

pa2-p2.c:78: note: worklist: examine stmt: c[pretmp_147][i_101] = _69;

pa2-p2.c:78: note: vect_is_simple_use: operand _69
pa2-p2.c:78: note: def_stmt: _69 = _64 + _68;

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: _69 = _64 + _68;

pa2-p2.c:78: note: vect_is_simple_use: operand _64
pa2-p2.c:78: note: def_stmt: _64 = c[pretmp_147][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: vect_is_simple_use: operand _68
pa2-p2.c:78: note: def_stmt: _68 = _42 * pretmp_155;

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: _68 = _42 * pretmp_155;

pa2-p2.c:78: note: vect_is_simple_use: operand _42
pa2-p2.c:78: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: vect_is_simple_use: operand pretmp_155
pa2-p2.c:78: note: def_stmt: pretmp_155 = b[k_17][pretmp_147];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: outer-loop def-stmt defining inner-loop stmt.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: pretmp_155 = b[k_17][pretmp_147];

pa2-p2.c:78: note: worklist: examine stmt: _42 = a[k_17][i_101];

pa2-p2.c:78: note: worklist: examine stmt: _64 = c[pretmp_147][i_101];

pa2-p2.c:78: note: worklist: examine stmt: c[pretmp_146][i_101] = _61;

pa2-p2.c:78: note: vect_is_simple_use: operand _61
pa2-p2.c:78: note: def_stmt: _61 = _56 + _60;

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: _61 = _56 + _60;

pa2-p2.c:78: note: vect_is_simple_use: operand _56
pa2-p2.c:78: note: def_stmt: _56 = c[pretmp_146][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: vect_is_simple_use: operand _60
pa2-p2.c:78: note: def_stmt: _60 = _42 * pretmp_153;

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: _60 = _42 * pretmp_153;

pa2-p2.c:78: note: vect_is_simple_use: operand _42
pa2-p2.c:78: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: already marked relevant/live.
pa2-p2.c:78: note: vect_is_simple_use: operand pretmp_153
pa2-p2.c:78: note: def_stmt: pretmp_153 = b[k_17][pretmp_146];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: outer-loop def-stmt defining inner-loop stmt.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: pretmp_153 = b[k_17][pretmp_146];

pa2-p2.c:78: note: worklist: examine stmt: _56 = c[pretmp_146][i_101];

pa2-p2.c:78: note: worklist: examine stmt: c[pretmp_145][i_101] = _53;

pa2-p2.c:78: note: vect_is_simple_use: operand _53
pa2-p2.c:78: note: def_stmt: _53 = _48 + _52;

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: _53 = _48 + _52;

pa2-p2.c:78: note: vect_is_simple_use: operand _48
pa2-p2.c:78: note: def_stmt: _48 = c[pretmp_145][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: vect_is_simple_use: operand _52
pa2-p2.c:78: note: def_stmt: _52 = _42 * pretmp_151;

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: _52 = _42 * pretmp_151;

pa2-p2.c:78: note: vect_is_simple_use: operand _42
pa2-p2.c:78: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: already marked relevant/live.
pa2-p2.c:78: note: vect_is_simple_use: operand pretmp_151
pa2-p2.c:78: note: def_stmt: pretmp_151 = b[k_17][pretmp_145];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: outer-loop def-stmt defining inner-loop stmt.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: pretmp_151 = b[k_17][pretmp_145];

pa2-p2.c:78: note: worklist: examine stmt: _48 = c[pretmp_145][i_101];

pa2-p2.c:78: note: worklist: examine stmt: c[j_37][i_101] = _45;

pa2-p2.c:78: note: vect_is_simple_use: operand _45
pa2-p2.c:78: note: def_stmt: _45 = _41 + _44;

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: _45 = _41 + _44;

pa2-p2.c:78: note: vect_is_simple_use: operand _41
pa2-p2.c:78: note: def_stmt: _41 = c[j_37][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: vect_is_simple_use: operand _44
pa2-p2.c:78: note: def_stmt: _44 = _42 * pretmp_148;

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: _44 = _42 * pretmp_148;

pa2-p2.c:78: note: vect_is_simple_use: operand _42
pa2-p2.c:78: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: already marked relevant/live.
pa2-p2.c:78: note: vect_is_simple_use: operand pretmp_148
pa2-p2.c:78: note: def_stmt: pretmp_148 = b[k_17][j_37];

pa2-p2.c:78: note: type of def: 3.
pa2-p2.c:78: note: outer-loop def-stmt defining inner-loop stmt.
pa2-p2.c:78: note: mark relevant 4, live 0.
pa2-p2.c:78: note: worklist: examine stmt: pretmp_148 = b[k_17][j_37];

pa2-p2.c:78: note: worklist: examine stmt: _41 = c[j_37][i_101];

pa2-p2.c:78: note: === vect_analyze_dependences ===
pa2-p2.c:78: note: dependence distance  = 0.
pa2-p2.c:78: note: dependence distance == 0 between c[j_37][i_101] and c[j_37][i_101]
pa2-p2.c:78: note: dependence distance  = 1.
pa2-p2.c:78: note: not vectorized, possible dependence between data-refs c[j_37][i_101] and c[j_37][i_101]
pa2-p2.c:78: note: bad data dependence.
Analyzing loop at pa2-p2.c:79

pa2-p2.c:79: note: ===== analyze_loop_nest =====
pa2-p2.c:79: note: === vect_analyze_loop_form ===
pa2-p2.c:79: note: === get_loop_niters ===
pa2-p2.c:79: note: ==> get_loop_niters:2000
pa2-p2.c:79: note: === vect_analyze_data_refs ===

pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:79: note: Analyze phi: i_101 = PHI <i_71(20), 0(35)>

pa2-p2.c:79: note: Access function of PHI: {0, +, 1}_5
pa2-p2.c:79: note: step: 1,  init: 0
pa2-p2.c:79: note: Detected induction.
pa2-p2.c:79: note: Analyze phi: .MEM_99 = PHI <.MEM_70(20), .MEM_58(35)>

pa2-p2.c:79: note: Analyze phi: ivtmp_154 = PHI <ivtmp_43(20), 2000(35)>

pa2-p2.c:79: note: Access function of PHI: {2000, +, 4294967295}_5
pa2-p2.c:79: note: step: 4294967295,  init: 2000
pa2-p2.c:79: note: Detected induction.
pa2-p2.c:79: note: === vect_pattern_recog ===
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p2.c:79: note: init: phi relevant? i_101 = PHI <i_71(20), 0(35)>

pa2-p2.c:79: note: init: phi relevant? .MEM_99 = PHI <.MEM_70(20), .MEM_58(35)>

pa2-p2.c:79: note: init: phi relevant? ivtmp_154 = PHI <ivtmp_43(20), 2000(35)>

pa2-p2.c:79: note: init: stmt relevant? # DEBUG i => i_101

pa2-p2.c:79: note: init: stmt relevant? _41 = c[j_37][i_101];

pa2-p2.c:79: note: init: stmt relevant? _42 = a[k_17][i_101];

pa2-p2.c:79: note: init: stmt relevant? _44 = _42 * pretmp_148;

pa2-p2.c:79: note: init: stmt relevant? _45 = _41 + _44;

pa2-p2.c:79: note: init: stmt relevant? c[j_37][i_101] = _45;

pa2-p2.c:79: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: init: stmt relevant? _48 = c[pretmp_145][i_101];

pa2-p2.c:79: note: init: stmt relevant? _52 = _42 * pretmp_151;

pa2-p2.c:79: note: init: stmt relevant? _53 = _48 + _52;

pa2-p2.c:79: note: init: stmt relevant? c[pretmp_145][i_101] = _53;

pa2-p2.c:79: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: init: stmt relevant? _56 = c[pretmp_146][i_101];

pa2-p2.c:79: note: init: stmt relevant? _60 = _42 * pretmp_153;

pa2-p2.c:79: note: init: stmt relevant? _61 = _56 + _60;

pa2-p2.c:79: note: init: stmt relevant? c[pretmp_146][i_101] = _61;

pa2-p2.c:79: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: init: stmt relevant? _64 = c[pretmp_147][i_101];

pa2-p2.c:79: note: init: stmt relevant? _68 = _42 * pretmp_155;

pa2-p2.c:79: note: init: stmt relevant? _69 = _64 + _68;

pa2-p2.c:79: note: init: stmt relevant? c[pretmp_147][i_101] = _69;

pa2-p2.c:79: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: init: stmt relevant? i_71 = i_101 + 1;

pa2-p2.c:79: note: init: stmt relevant? # DEBUG i => i_71

pa2-p2.c:79: note: init: stmt relevant? # DEBUG i => i_71

pa2-p2.c:79: note: init: stmt relevant? ivtmp_43 = ivtmp_154 - 1;

pa2-p2.c:79: note: init: stmt relevant? if (ivtmp_43 != 0)

pa2-p2.c:79: note: worklist: examine stmt: c[pretmp_147][i_101] = _69;

pa2-p2.c:79: note: vect_is_simple_use: operand _69
pa2-p2.c:79: note: def_stmt: _69 = _64 + _68;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: worklist: examine stmt: _69 = _64 + _68;

pa2-p2.c:79: note: vect_is_simple_use: operand _64
pa2-p2.c:79: note: def_stmt: _64 = c[pretmp_147][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: vect_is_simple_use: operand _68
pa2-p2.c:79: note: def_stmt: _68 = _42 * pretmp_155;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: worklist: examine stmt: _68 = _42 * pretmp_155;

pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_155
pa2-p2.c:79: note: def_stmt: pretmp_155 = b[k_17][pretmp_147];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: def_stmt is out of loop.
pa2-p2.c:79: note: worklist: examine stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: worklist: examine stmt: _64 = c[pretmp_147][i_101];

pa2-p2.c:79: note: worklist: examine stmt: c[pretmp_146][i_101] = _61;

pa2-p2.c:79: note: vect_is_simple_use: operand _61
pa2-p2.c:79: note: def_stmt: _61 = _56 + _60;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: worklist: examine stmt: _61 = _56 + _60;

pa2-p2.c:79: note: vect_is_simple_use: operand _56
pa2-p2.c:79: note: def_stmt: _56 = c[pretmp_146][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: vect_is_simple_use: operand _60
pa2-p2.c:79: note: def_stmt: _60 = _42 * pretmp_153;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: worklist: examine stmt: _60 = _42 * pretmp_153;

pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: already marked relevant/live.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_153
pa2-p2.c:79: note: def_stmt: pretmp_153 = b[k_17][pretmp_146];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: def_stmt is out of loop.
pa2-p2.c:79: note: worklist: examine stmt: _56 = c[pretmp_146][i_101];

pa2-p2.c:79: note: worklist: examine stmt: c[pretmp_145][i_101] = _53;

pa2-p2.c:79: note: vect_is_simple_use: operand _53
pa2-p2.c:79: note: def_stmt: _53 = _48 + _52;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: worklist: examine stmt: _53 = _48 + _52;

pa2-p2.c:79: note: vect_is_simple_use: operand _48
pa2-p2.c:79: note: def_stmt: _48 = c[pretmp_145][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: vect_is_simple_use: operand _52
pa2-p2.c:79: note: def_stmt: _52 = _42 * pretmp_151;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: worklist: examine stmt: _52 = _42 * pretmp_151;

pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: already marked relevant/live.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_151
pa2-p2.c:79: note: def_stmt: pretmp_151 = b[k_17][pretmp_145];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: def_stmt is out of loop.
pa2-p2.c:79: note: worklist: examine stmt: _48 = c[pretmp_145][i_101];

pa2-p2.c:79: note: worklist: examine stmt: c[j_37][i_101] = _45;

pa2-p2.c:79: note: vect_is_simple_use: operand _45
pa2-p2.c:79: note: def_stmt: _45 = _41 + _44;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: worklist: examine stmt: _45 = _41 + _44;

pa2-p2.c:79: note: vect_is_simple_use: operand _41
pa2-p2.c:79: note: def_stmt: _41 = c[j_37][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: vect_is_simple_use: operand _44
pa2-p2.c:79: note: def_stmt: _44 = _42 * pretmp_148;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: worklist: examine stmt: _44 = _42 * pretmp_148;

pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: mark relevant 4, live 0.
pa2-p2.c:79: note: already marked relevant/live.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_148
pa2-p2.c:79: note: def_stmt: pretmp_148 = b[k_17][j_37];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: def_stmt is out of loop.
pa2-p2.c:79: note: worklist: examine stmt: _41 = c[j_37][i_101];

pa2-p2.c:79: note: === vect_analyze_dependences ===
pa2-p2.c:79: note: dependence distance  = 0.
pa2-p2.c:79: note: dependence distance == 0 between c[j_37][i_101] and c[j_37][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[j_37][i_101] and c[pretmp_145][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[j_37][i_101] and c[pretmp_145][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[j_37][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[j_37][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[j_37][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[j_37][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[j_37][i_101] and c[pretmp_145][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[j_37][i_101] and c[pretmp_145][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[j_37][i_101] and c[pretmp_145][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[j_37][i_101] and c[pretmp_145][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[j_37][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[j_37][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[j_37][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[j_37][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[j_37][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[j_37][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[j_37][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[j_37][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: dependence distance  = 0.
pa2-p2.c:79: note: dependence distance == 0 between c[pretmp_145][i_101] and c[pretmp_145][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[pretmp_145][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[pretmp_145][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[pretmp_145][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[pretmp_145][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[pretmp_145][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[pretmp_145][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[pretmp_145][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[pretmp_145][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[pretmp_145][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[pretmp_145][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[pretmp_145][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[pretmp_145][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: dependence distance  = 0.
pa2-p2.c:79: note: dependence distance == 0 between c[pretmp_146][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[pretmp_146][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[pretmp_146][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[pretmp_146][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[pretmp_146][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: versioning for alias required: can't determine dependence between c[pretmp_146][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: mark for run-time aliasing test between c[pretmp_146][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: dependence distance  = 0.
pa2-p2.c:79: note: dependence distance == 0 between c[pretmp_147][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: === vect_determine_vectorization_factor ===
pa2-p2.c:79: note: ==> examining phi: i_101 = PHI <i_71(20), 0(35)>

pa2-p2.c:79: note: ==> examining phi: .MEM_99 = PHI <.MEM_70(20), .MEM_58(35)>

pa2-p2.c:79: note: ==> examining phi: ivtmp_154 = PHI <ivtmp_43(20), 2000(35)>

pa2-p2.c:79: note: ==> examining statement: # DEBUG i => i_101

pa2-p2.c:79: note: skip.
pa2-p2.c:79: note: ==> examining statement: _41 = c[j_37][i_101];

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _42 = a[k_17][i_101];

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _44 = _42 * pretmp_148;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _45 = _41 + _44;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: c[j_37][i_101] = _45;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _48 = c[pretmp_145][i_101];

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _52 = _42 * pretmp_151;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _53 = _48 + _52;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: c[pretmp_145][i_101] = _53;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _56 = c[pretmp_146][i_101];

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _60 = _42 * pretmp_153;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _61 = _56 + _60;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: c[pretmp_146][i_101] = _61;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _64 = c[pretmp_147][i_101];

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _68 = _42 * pretmp_155;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: _69 = _64 + _68;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: c[pretmp_147][i_101] = _69;

pa2-p2.c:79: note: get vectype for scalar type:  float
pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: nunits = 4
pa2-p2.c:79: note: ==> examining statement: i_71 = i_101 + 1;

pa2-p2.c:79: note: skip.
pa2-p2.c:79: note: ==> examining statement: # DEBUG i => i_71

pa2-p2.c:79: note: skip.
pa2-p2.c:79: note: ==> examining statement: # DEBUG i => i_71

pa2-p2.c:79: note: skip.
pa2-p2.c:79: note: ==> examining statement: ivtmp_43 = ivtmp_154 - 1;

pa2-p2.c:79: note: skip.
pa2-p2.c:79: note: ==> examining statement: if (ivtmp_43 != 0)

pa2-p2.c:79: note: skip.
pa2-p2.c:79: note: vectorization factor = 4
pa2-p2.c:79: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:79: note: dependence distance  = 0.
pa2-p2.c:79: note: accesses have the same alignment.dependence distance modulo vf == 0 between c[j_37][i_101] and c[j_37][i_101]
pa2-p2.c:79: note: dependence distance  = 0.
pa2-p2.c:79: note: accesses have the same alignment.dependence distance modulo vf == 0 between c[pretmp_145][i_101] and c[pretmp_145][i_101]
pa2-p2.c:79: note: dependence distance  = 0.
pa2-p2.c:79: note: accesses have the same alignment.dependence distance modulo vf == 0 between c[pretmp_146][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: dependence distance  = 0.
pa2-p2.c:79: note: accesses have the same alignment.dependence distance modulo vf == 0 between c[pretmp_147][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: vect_compute_data_ref_alignment:
pa2-p2.c:79: note: misalign = 0 bytes of ref c[j_37][i_101]
pa2-p2.c:79: note: vect_compute_data_ref_alignment:
pa2-p2.c:79: note: misalign = 0 bytes of ref a[k_17][i_101]
pa2-p2.c:79: note: vect_compute_data_ref_alignment:
pa2-p2.c:79: note: misalign = 0 bytes of ref c[j_37][i_101]
pa2-p2.c:79: note: vect_compute_data_ref_alignment:
pa2-p2.c:79: note: misalign = 0 bytes of ref c[pretmp_145][i_101]
pa2-p2.c:79: note: vect_compute_data_ref_alignment:
pa2-p2.c:79: note: misalign = 0 bytes of ref c[pretmp_145][i_101]
pa2-p2.c:79: note: vect_compute_data_ref_alignment:
pa2-p2.c:79: note: misalign = 0 bytes of ref c[pretmp_146][i_101]
pa2-p2.c:79: note: vect_compute_data_ref_alignment:
pa2-p2.c:79: note: misalign = 0 bytes of ref c[pretmp_146][i_101]
pa2-p2.c:79: note: vect_compute_data_ref_alignment:
pa2-p2.c:79: note: misalign = 0 bytes of ref c[pretmp_147][i_101]
pa2-p2.c:79: note: vect_compute_data_ref_alignment:
pa2-p2.c:79: note: misalign = 0 bytes of ref c[pretmp_147][i_101]
pa2-p2.c:79: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:79: note: === vect_prune_runtime_alias_test_list ===
pa2-p2.c:79: note: found equal ranges c[j_37][i_101], c[pretmp_145][i_101] and c[j_37][i_101], c[pretmp_145][i_101]
pa2-p2.c:79: note: found equal ranges c[j_37][i_101], c[pretmp_145][i_101] and c[j_37][i_101], c[pretmp_145][i_101]
pa2-p2.c:79: note: found equal ranges c[j_37][i_101], c[pretmp_146][i_101] and c[j_37][i_101], c[pretmp_146][i_101]
pa2-p2.c:79: note: found equal ranges c[j_37][i_101], c[pretmp_146][i_101] and c[j_37][i_101], c[pretmp_146][i_101]
pa2-p2.c:79: note: found equal ranges c[j_37][i_101], c[pretmp_147][i_101] and c[j_37][i_101], c[pretmp_147][i_101]
pa2-p2.c:79: note: found equal ranges c[j_37][i_101], c[pretmp_147][i_101] and c[j_37][i_101], c[pretmp_147][i_101]
pa2-p2.c:79: note: found equal ranges c[pretmp_145][i_101], c[pretmp_146][i_101] and c[pretmp_145][i_101], c[pretmp_146][i_101]
pa2-p2.c:79: note: found equal ranges c[pretmp_145][i_101], c[pretmp_146][i_101] and c[pretmp_145][i_101], c[pretmp_146][i_101]
pa2-p2.c:79: note: found equal ranges c[pretmp_145][i_101], c[pretmp_147][i_101] and c[pretmp_145][i_101], c[pretmp_147][i_101]
pa2-p2.c:79: note: found equal ranges c[pretmp_145][i_101], c[pretmp_147][i_101] and c[pretmp_145][i_101], c[pretmp_147][i_101]
pa2-p2.c:79: note: found equal ranges c[pretmp_146][i_101], c[pretmp_147][i_101] and c[pretmp_146][i_101], c[pretmp_147][i_101]
pa2-p2.c:79: note: found equal ranges c[pretmp_146][i_101], c[pretmp_147][i_101] and c[pretmp_146][i_101], c[pretmp_147][i_101]
pa2-p2.c:79: note: === vect_enhance_data_refs_alignment ===
pa2-p2.c:79: note: === vect_analyze_slp ===
pa2-p2.c:79: note: === vect_make_slp_decision ===
pa2-p2.c:79: note: === vect_detect_hybrid_slp ===
pa2-p2.c:79: note: === vect_analyze_loop_operations ===
pa2-p2.c:79: note: examining phi: i_101 = PHI <i_71(20), 0(35)>

pa2-p2.c:79: note: examining phi: .MEM_99 = PHI <.MEM_70(20), .MEM_58(35)>

pa2-p2.c:79: note: examining phi: ivtmp_154 = PHI <ivtmp_43(20), 2000(35)>

pa2-p2.c:79: note: ==> examining statement: # DEBUG i => i_101

pa2-p2.c:79: note: irrelevant.
pa2-p2.c:79: note: ==> examining statement: _41 = c[j_37][i_101];

pa2-p2.c:79: note: num. args = 4 (not unary/binary/ternary op).
pa2-p2.c:79: note: vect_is_simple_use: operand c[j_37][i_101]
pa2-p2.c:79: note: not ssa-name.
pa2-p2.c:79: note: use not simple.
pa2-p2.c:79: note: vect_model_load_cost: aligned.
pa2-p2.c:79: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: _42 = a[k_17][i_101];

pa2-p2.c:79: note: num. args = 4 (not unary/binary/ternary op).
pa2-p2.c:79: note: vect_is_simple_use: operand a[k_17][i_101]
pa2-p2.c:79: note: not ssa-name.
pa2-p2.c:79: note: use not simple.
pa2-p2.c:79: note: vect_model_load_cost: aligned.
pa2-p2.c:79: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: _44 = _42 * pretmp_148;

pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_148
pa2-p2.c:79: note: def_stmt: pretmp_148 = b[k_17][j_37];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: === vectorizable_operation ===
pa2-p2.c:79: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p2.c:79: note: ==> examining statement: _45 = _41 + _44;

pa2-p2.c:79: note: vect_is_simple_use: operand _41
pa2-p2.c:79: note: def_stmt: _41 = c[j_37][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand _44
pa2-p2.c:79: note: def_stmt: _44 = _42 * pretmp_148;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: === vectorizable_operation ===
pa2-p2.c:79: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: c[j_37][i_101] = _45;

pa2-p2.c:79: note: vect_is_simple_use: operand _45
pa2-p2.c:79: note: def_stmt: _45 = _41 + _44;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_model_store_cost: aligned.
pa2-p2.c:79: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: _48 = c[pretmp_145][i_101];

pa2-p2.c:79: note: num. args = 4 (not unary/binary/ternary op).
pa2-p2.c:79: note: vect_is_simple_use: operand c[pretmp_145][i_101]
pa2-p2.c:79: note: not ssa-name.
pa2-p2.c:79: note: use not simple.
pa2-p2.c:79: note: vect_model_load_cost: aligned.
pa2-p2.c:79: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: _52 = _42 * pretmp_151;

pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_151
pa2-p2.c:79: note: def_stmt: pretmp_151 = b[k_17][pretmp_145];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: === vectorizable_operation ===
pa2-p2.c:79: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p2.c:79: note: ==> examining statement: _53 = _48 + _52;

pa2-p2.c:79: note: vect_is_simple_use: operand _48
pa2-p2.c:79: note: def_stmt: _48 = c[pretmp_145][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand _52
pa2-p2.c:79: note: def_stmt: _52 = _42 * pretmp_151;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: === vectorizable_operation ===
pa2-p2.c:79: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: c[pretmp_145][i_101] = _53;

pa2-p2.c:79: note: vect_is_simple_use: operand _53
pa2-p2.c:79: note: def_stmt: _53 = _48 + _52;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_model_store_cost: aligned.
pa2-p2.c:79: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: _56 = c[pretmp_146][i_101];

pa2-p2.c:79: note: num. args = 4 (not unary/binary/ternary op).
pa2-p2.c:79: note: vect_is_simple_use: operand c[pretmp_146][i_101]
pa2-p2.c:79: note: not ssa-name.
pa2-p2.c:79: note: use not simple.
pa2-p2.c:79: note: vect_model_load_cost: aligned.
pa2-p2.c:79: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: _60 = _42 * pretmp_153;

pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_153
pa2-p2.c:79: note: def_stmt: pretmp_153 = b[k_17][pretmp_146];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: === vectorizable_operation ===
pa2-p2.c:79: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p2.c:79: note: ==> examining statement: _61 = _56 + _60;

pa2-p2.c:79: note: vect_is_simple_use: operand _56
pa2-p2.c:79: note: def_stmt: _56 = c[pretmp_146][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand _60
pa2-p2.c:79: note: def_stmt: _60 = _42 * pretmp_153;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: === vectorizable_operation ===
pa2-p2.c:79: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: c[pretmp_146][i_101] = _61;

pa2-p2.c:79: note: vect_is_simple_use: operand _61
pa2-p2.c:79: note: def_stmt: _61 = _56 + _60;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_model_store_cost: aligned.
pa2-p2.c:79: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: _64 = c[pretmp_147][i_101];

pa2-p2.c:79: note: num. args = 4 (not unary/binary/ternary op).
pa2-p2.c:79: note: vect_is_simple_use: operand c[pretmp_147][i_101]
pa2-p2.c:79: note: not ssa-name.
pa2-p2.c:79: note: use not simple.
pa2-p2.c:79: note: vect_model_load_cost: aligned.
pa2-p2.c:79: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: _68 = _42 * pretmp_155;

pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_155
pa2-p2.c:79: note: def_stmt: pretmp_155 = b[k_17][pretmp_147];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: === vectorizable_operation ===
pa2-p2.c:79: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p2.c:79: note: ==> examining statement: _69 = _64 + _68;

pa2-p2.c:79: note: vect_is_simple_use: operand _64
pa2-p2.c:79: note: def_stmt: _64 = c[pretmp_147][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand _68
pa2-p2.c:79: note: def_stmt: _68 = _42 * pretmp_155;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: === vectorizable_operation ===
pa2-p2.c:79: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: c[pretmp_147][i_101] = _69;

pa2-p2.c:79: note: vect_is_simple_use: operand _69
pa2-p2.c:79: note: def_stmt: _69 = _64 + _68;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_model_store_cost: aligned.
pa2-p2.c:79: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:79: note: ==> examining statement: i_71 = i_101 + 1;

pa2-p2.c:79: note: irrelevant.
pa2-p2.c:79: note: ==> examining statement: # DEBUG i => i_71

pa2-p2.c:79: note: irrelevant.
pa2-p2.c:79: note: ==> examining statement: # DEBUG i => i_71

pa2-p2.c:79: note: irrelevant.
pa2-p2.c:79: note: ==> examining statement: ivtmp_43 = ivtmp_154 - 1;

pa2-p2.c:79: note: irrelevant.
pa2-p2.c:79: note: ==> examining statement: if (ivtmp_43 != 0)

pa2-p2.c:79: note: irrelevant.
pa2-p2.c:79: note: vectorization_factor = 4, niters = 2000
pa2-p2.c:79: note: === vect_update_slp_costs_according_to_vf ===cost model: Adding cost of checks for loop versioning aliasing.

pa2-p2.c:79: note: Cost model analysis: 
  Vector inside of loop cost: 17
  Vector prologue cost: 13
  Vector epilogue cost: 0
  Scalar iteration cost: 17
  Scalar outside cost: 1
  Vector outside cost: 13
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

pa2-p2.c:79: note:   Runtime profitability threshold = 3

pa2-p2.c:79: note:   Static estimate profitability threshold = 3


Vectorizing loop at pa2-p2.c:79

pa2-p2.c:79: note: === vec_transform_loop ===
pa2-p2.c:79: note: created vect_pc.31_122
pa2-p2.c:79: note: created vect_pc.34_118
pa2-p2.c:79: note: create runtime check for data references c[j_37][i_101] and c[pretmp_145][i_101]
pa2-p2.c:79: note: created vect_pc.37_115
pa2-p2.c:79: note: created vect_pc.40_111
pa2-p2.c:79: note: create runtime check for data references c[j_37][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: created vect_pc.43_108
pa2-p2.c:79: note: created vect_pc.46_104
pa2-p2.c:79: note: create runtime check for data references c[j_37][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: created vect_pc.49_96
pa2-p2.c:79: note: created vect_pc.52_91
pa2-p2.c:79: note: create runtime check for data references c[pretmp_145][i_101] and c[pretmp_146][i_101]
pa2-p2.c:79: note: created vect_pc.55_75
pa2-p2.c:79: note: created vect_pc.58_57
pa2-p2.c:79: note: create runtime check for data references c[pretmp_145][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: created vect_pc.61_21
pa2-p2.c:79: note: created vect_pc.64_14
pa2-p2.c:79: note: create runtime check for data references c[pretmp_146][i_101] and c[pretmp_147][i_101]
pa2-p2.c:79: note: created 6 versioning for alias checks.

pa2-p2.c:79: note: ------>vectorizing phi: i_101 = PHI <i_71(20), 0(43)>

pa2-p2.c:79: note: ------>vectorizing phi: .MEM_99 = PHI <.MEM_70(20), .MEM_58(43)>

pa2-p2.c:79: note: ------>vectorizing phi: ivtmp_154 = PHI <ivtmp_43(20), 2000(43)>

pa2-p2.c:79: note: ------>vectorizing statement: # DEBUG i => i_101

pa2-p2.c:79: note: ------>vectorizing statement: _41 = c[j_37][i_101];

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: transform load. ncopies = 1
pa2-p2.c:79: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:79: note: created vect_pc.68_209
pa2-p2.c:79: note: add new stmt: vect_var_.69_212 = MEM[(float[2000][2000] *)vect_pc.65_210];

pa2-p2.c:79: note: ------>vectorizing statement: _42 = a[k_17][i_101];

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: transform load. ncopies = 1
pa2-p2.c:79: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: a
pa2-p2.c:79: note: created vect_pa.73_215
pa2-p2.c:79: note: add new stmt: vect_var_.74_218 = MEM[(float[2000][2000] *)vect_pa.70_216];

pa2-p2.c:79: note: ------>vectorizing statement: _44 = _42 * pretmp_148;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_148
pa2-p2.c:79: note: def_stmt: pretmp_148 = b[k_17][j_37];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: transform binary/unary operation.
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _42
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _42  def_stmt =  _42 = a[k_17][i_101];

pa2-p2.c:79: note: vect_get_vec_def_for_operand: pretmp_148
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_148
pa2-p2.c:79: note: def_stmt: pretmp_148 = b[k_17][j_37];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: def =  pretmp_148  def_stmt =  pretmp_148 = b[k_17][j_37];

pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: Create vector_inv.
pa2-p2.c:79: note: created new init_stmt: vect_cst_.76_219 = {pretmp_148, pretmp_148, pretmp_148, pretmp_148};

pa2-p2.c:79: note: add new stmt: vect_var_.75_220 = vect_var_.74_218 * vect_cst_.76_219;

pa2-p2.c:79: note: ------>vectorizing statement: _45 = _41 + _44;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _41
pa2-p2.c:79: note: def_stmt: _41 = c[j_37][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand _44
pa2-p2.c:79: note: def_stmt: _44 = _42 * pretmp_148;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: transform binary/unary operation.
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _41
pa2-p2.c:79: note: vect_is_simple_use: operand _41
pa2-p2.c:79: note: def_stmt: _41 = c[j_37][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _41  def_stmt =  _41 = c[j_37][i_101];

pa2-p2.c:79: note: vect_get_vec_def_for_operand: _44
pa2-p2.c:79: note: vect_is_simple_use: operand _44
pa2-p2.c:79: note: def_stmt: _44 = _42 * pretmp_148;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _44  def_stmt =  _44 = _42 * pretmp_148;

pa2-p2.c:79: note: add new stmt: vect_var_.77_221 = vect_var_.69_212 + vect_var_.75_220;

pa2-p2.c:79: note: ------>vectorizing statement: c[j_37][i_101] = _45;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _45
pa2-p2.c:79: note: def_stmt: _45 = _41 + _44;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: transform store. ncopies = 1
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _45
pa2-p2.c:79: note: vect_is_simple_use: operand _45
pa2-p2.c:79: note: def_stmt: _45 = _41 + _44;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _45  def_stmt =  _45 = _41 + _44;

pa2-p2.c:79: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:79: note: created vect_pc.81_224
pa2-p2.c:79: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.78_225] = vect_var_.77_221;

pa2-p2.c:79: note: ------>vectorizing statement: _48 = c[pretmp_145][i_101];

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: transform load. ncopies = 1
pa2-p2.c:79: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:79: note: created vect_pc.85_230
pa2-p2.c:79: note: add new stmt: vect_var_.86_233 = MEM[(float[2000][2000] *)vect_pc.82_231];

pa2-p2.c:79: note: ------>vectorizing statement: _52 = _42 * pretmp_151;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_151
pa2-p2.c:79: note: def_stmt: pretmp_151 = b[k_17][pretmp_145];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: transform binary/unary operation.
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _42
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _42  def_stmt =  _42 = a[k_17][i_101];

pa2-p2.c:79: note: vect_get_vec_def_for_operand: pretmp_151
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_151
pa2-p2.c:79: note: def_stmt: pretmp_151 = b[k_17][pretmp_145];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: def =  pretmp_151  def_stmt =  pretmp_151 = b[k_17][pretmp_145];

pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: Create vector_inv.
pa2-p2.c:79: note: created new init_stmt: vect_cst_.88_234 = {pretmp_151, pretmp_151, pretmp_151, pretmp_151};

pa2-p2.c:79: note: add new stmt: vect_var_.87_235 = vect_var_.74_218 * vect_cst_.88_234;

pa2-p2.c:79: note: ------>vectorizing statement: _53 = _48 + _52;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _48
pa2-p2.c:79: note: def_stmt: _48 = c[pretmp_145][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand _52
pa2-p2.c:79: note: def_stmt: _52 = _42 * pretmp_151;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: transform binary/unary operation.
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _48
pa2-p2.c:79: note: vect_is_simple_use: operand _48
pa2-p2.c:79: note: def_stmt: _48 = c[pretmp_145][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _48  def_stmt =  _48 = c[pretmp_145][i_101];

pa2-p2.c:79: note: vect_get_vec_def_for_operand: _52
pa2-p2.c:79: note: vect_is_simple_use: operand _52
pa2-p2.c:79: note: def_stmt: _52 = _42 * pretmp_151;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _52  def_stmt =  _52 = _42 * pretmp_151;

pa2-p2.c:79: note: add new stmt: vect_var_.89_236 = vect_var_.86_233 + vect_var_.87_235;

pa2-p2.c:79: note: ------>vectorizing statement: c[pretmp_145][i_101] = _53;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _53
pa2-p2.c:79: note: def_stmt: _53 = _48 + _52;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: transform store. ncopies = 1
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _53
pa2-p2.c:79: note: vect_is_simple_use: operand _53
pa2-p2.c:79: note: def_stmt: _53 = _48 + _52;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _53  def_stmt =  _53 = _48 + _52;

pa2-p2.c:79: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:79: note: created vect_pc.93_240
pa2-p2.c:79: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.90_241] = vect_var_.89_236;

pa2-p2.c:79: note: ------>vectorizing statement: _56 = c[pretmp_146][i_101];

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: transform load. ncopies = 1
pa2-p2.c:79: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:79: note: created vect_pc.97_246
pa2-p2.c:79: note: add new stmt: vect_var_.98_249 = MEM[(float[2000][2000] *)vect_pc.94_247];

pa2-p2.c:79: note: ------>vectorizing statement: _60 = _42 * pretmp_153;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_153
pa2-p2.c:79: note: def_stmt: pretmp_153 = b[k_17][pretmp_146];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: transform binary/unary operation.
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _42
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _42  def_stmt =  _42 = a[k_17][i_101];

pa2-p2.c:79: note: vect_get_vec_def_for_operand: pretmp_153
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_153
pa2-p2.c:79: note: def_stmt: pretmp_153 = b[k_17][pretmp_146];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: def =  pretmp_153  def_stmt =  pretmp_153 = b[k_17][pretmp_146];

pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: Create vector_inv.
pa2-p2.c:79: note: created new init_stmt: vect_cst_.100_250 = {pretmp_153, pretmp_153, pretmp_153, pretmp_153};

pa2-p2.c:79: note: add new stmt: vect_var_.99_251 = vect_var_.74_218 * vect_cst_.100_250;

pa2-p2.c:79: note: ------>vectorizing statement: _61 = _56 + _60;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _56
pa2-p2.c:79: note: def_stmt: _56 = c[pretmp_146][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand _60
pa2-p2.c:79: note: def_stmt: _60 = _42 * pretmp_153;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: transform binary/unary operation.
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _56
pa2-p2.c:79: note: vect_is_simple_use: operand _56
pa2-p2.c:79: note: def_stmt: _56 = c[pretmp_146][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _56  def_stmt =  _56 = c[pretmp_146][i_101];

pa2-p2.c:79: note: vect_get_vec_def_for_operand: _60
pa2-p2.c:79: note: vect_is_simple_use: operand _60
pa2-p2.c:79: note: def_stmt: _60 = _42 * pretmp_153;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _60  def_stmt =  _60 = _42 * pretmp_153;

pa2-p2.c:79: note: add new stmt: vect_var_.101_252 = vect_var_.98_249 + vect_var_.99_251;

pa2-p2.c:79: note: ------>vectorizing statement: c[pretmp_146][i_101] = _61;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _61
pa2-p2.c:79: note: def_stmt: _61 = _56 + _60;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: transform store. ncopies = 1
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _61
pa2-p2.c:79: note: vect_is_simple_use: operand _61
pa2-p2.c:79: note: def_stmt: _61 = _56 + _60;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _61  def_stmt =  _61 = _56 + _60;

pa2-p2.c:79: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:79: note: created vect_pc.105_256
pa2-p2.c:79: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.102_257] = vect_var_.101_252;

pa2-p2.c:79: note: ------>vectorizing statement: _64 = c[pretmp_147][i_101];

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: transform load. ncopies = 1
pa2-p2.c:79: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:79: note: created vect_pc.109_262
pa2-p2.c:79: note: add new stmt: vect_var_.110_265 = MEM[(float[2000][2000] *)vect_pc.106_263];

pa2-p2.c:79: note: ------>vectorizing statement: _68 = _42 * pretmp_155;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_155
pa2-p2.c:79: note: def_stmt: pretmp_155 = b[k_17][pretmp_147];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: transform binary/unary operation.
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _42
pa2-p2.c:79: note: vect_is_simple_use: operand _42
pa2-p2.c:79: note: def_stmt: _42 = a[k_17][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _42  def_stmt =  _42 = a[k_17][i_101];

pa2-p2.c:79: note: vect_get_vec_def_for_operand: pretmp_155
pa2-p2.c:79: note: vect_is_simple_use: operand pretmp_155
pa2-p2.c:79: note: def_stmt: pretmp_155 = b[k_17][pretmp_147];

pa2-p2.c:79: note: type of def: 2.
pa2-p2.c:79: note: def =  pretmp_155  def_stmt =  pretmp_155 = b[k_17][pretmp_147];

pa2-p2.c:79: note: get vectype with 4 units of type float
pa2-p2.c:79: note: vectype: vector(4) float
pa2-p2.c:79: note: Create vector_inv.
pa2-p2.c:79: note: created new init_stmt: vect_cst_.112_266 = {pretmp_155, pretmp_155, pretmp_155, pretmp_155};

pa2-p2.c:79: note: add new stmt: vect_var_.111_267 = vect_var_.74_218 * vect_cst_.112_266;

pa2-p2.c:79: note: ------>vectorizing statement: _69 = _64 + _68;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _64
pa2-p2.c:79: note: def_stmt: _64 = c[pretmp_147][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: vect_is_simple_use: operand _68
pa2-p2.c:79: note: def_stmt: _68 = _42 * pretmp_155;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: transform binary/unary operation.
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _64
pa2-p2.c:79: note: vect_is_simple_use: operand _64
pa2-p2.c:79: note: def_stmt: _64 = c[pretmp_147][i_101];

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _64  def_stmt =  _64 = c[pretmp_147][i_101];

pa2-p2.c:79: note: vect_get_vec_def_for_operand: _68
pa2-p2.c:79: note: vect_is_simple_use: operand _68
pa2-p2.c:79: note: def_stmt: _68 = _42 * pretmp_155;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _68  def_stmt =  _68 = _42 * pretmp_155;

pa2-p2.c:79: note: add new stmt: vect_var_.113_268 = vect_var_.110_265 + vect_var_.111_267;

pa2-p2.c:79: note: ------>vectorizing statement: c[pretmp_147][i_101] = _69;

pa2-p2.c:79: note: transform statement.
pa2-p2.c:79: note: vect_is_simple_use: operand _69
pa2-p2.c:79: note: def_stmt: _69 = _64 + _68;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: transform store. ncopies = 1
pa2-p2.c:79: note: vect_get_vec_def_for_operand: _69
pa2-p2.c:79: note: vect_is_simple_use: operand _69
pa2-p2.c:79: note: def_stmt: _69 = _64 + _68;

pa2-p2.c:79: note: type of def: 3.
pa2-p2.c:79: note: def =  _69  def_stmt =  _69 = _64 + _68;

pa2-p2.c:79: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:79: note: created vect_pc.117_272
pa2-p2.c:79: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.114_273] = vect_var_.113_268;

pa2-p2.c:79: note: ------>vectorizing statement: i_71 = i_101 + 1;

pa2-p2.c:79: note: ------>vectorizing statement: # DEBUG i => i_71

pa2-p2.c:79: note: ------>vectorizing statement: # DEBUG i => i_71

pa2-p2.c:79: note: ------>vectorizing statement: ivtmp_43 = ivtmp_154 - 1;

pa2-p2.c:79: note: ------>vectorizing statement: vect_pc.65_211 = vect_pc.65_210 + 16;

pa2-p2.c:79: note: ------>vectorizing statement: vect_pa.70_217 = vect_pa.70_216 + 16;

pa2-p2.c:79: note: ------>vectorizing statement: vect_pc.78_226 = vect_pc.78_225 + 16;

pa2-p2.c:79: note: ------>vectorizing statement: vect_pc.82_232 = vect_pc.82_231 + 16;

pa2-p2.c:79: note: ------>vectorizing statement: vect_pc.90_242 = vect_pc.90_241 + 16;

pa2-p2.c:79: note: ------>vectorizing statement: vect_pc.94_248 = vect_pc.94_247 + 16;

pa2-p2.c:79: note: ------>vectorizing statement: vect_pc.102_258 = vect_pc.102_257 + 16;

pa2-p2.c:79: note: ------>vectorizing statement: vect_pc.106_264 = vect_pc.106_263 + 16;

pa2-p2.c:79: note: ------>vectorizing statement: vect_pc.114_274 = vect_pc.114_273 + 16;

pa2-p2.c:79: note: ------>vectorizing statement: if (ivtmp_43 != 0)

loop at pa2-p2.c:80: if (ivtmp_276 < 500)

pa2-p2.c:79: note: LOOP VECTORIZED.
pa2-p2.c:64: note: vectorized 2 loops in function.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:66: note: ===vect_slp_analyze_bb===

pa2-p2.c:66: note: === vect_analyze_data_refs ===

pa2-p2.c:66: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:66: note: ===vect_slp_analyze_bb===

pa2-p2.c:66: note: === vect_analyze_data_refs ===

pa2-p2.c:66: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:67: note: ===vect_slp_analyze_bb===

pa2-p2.c:67: note: === vect_analyze_data_refs ===

pa2-p2.c:67: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:71: note: ===vect_slp_analyze_bb===

pa2-p2.c:71: note: === vect_analyze_data_refs ===

pa2-p2.c:71: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:77: note: ===vect_slp_analyze_bb===

pa2-p2.c:77: note: === vect_analyze_data_refs ===

pa2-p2.c:77: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:77: note: ===vect_slp_analyze_bb===

pa2-p2.c:77: note: === vect_analyze_data_refs ===

pa2-p2.c:77: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:78: note: ===vect_slp_analyze_bb===

pa2-p2.c:78: note: === vect_analyze_data_refs ===

pa2-p2.c:78: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:80: note: ===vect_slp_analyze_bb===

pa2-p2.c:80: note: === vect_analyze_data_refs ===

pa2-p2.c:80: note: get vectype with 4 units of type float
pa2-p2.c:80: note: vectype: vector(4) float
pa2-p2.c:80: note: get vectype with 4 units of type float
pa2-p2.c:80: note: vectype: vector(4) float
pa2-p2.c:80: note: get vectype with 4 units of type float
pa2-p2.c:80: note: vectype: vector(4) float
pa2-p2.c:80: note: get vectype with 4 units of type float
pa2-p2.c:80: note: vectype: vector(4) float
pa2-p2.c:80: note: get vectype with 4 units of type float
pa2-p2.c:80: note: vectype: vector(4) float
pa2-p2.c:80: note: get vectype with 4 units of type float
pa2-p2.c:80: note: vectype: vector(4) float
pa2-p2.c:80: note: get vectype with 4 units of type float
pa2-p2.c:80: note: vectype: vector(4) float
pa2-p2.c:80: note: get vectype with 4 units of type float
pa2-p2.c:80: note: vectype: vector(4) float
pa2-p2.c:80: note: get vectype with 4 units of type float
pa2-p2.c:80: note: vectype: vector(4) float
pa2-p2.c:80: note: === vect_pattern_recog ===
pa2-p2.c:80: note: vect_is_simple_use: operand _188
pa2-p2.c:80: note: def_stmt: _188 = a[k_17][i_184];

pa2-p2.c:80: note: type of def: 3.
pa2-p2.c:80: note: vect_is_simple_use: operand _188
pa2-p2.c:80: note: def_stmt: _188 = a[k_17][i_184];

pa2-p2.c:80: note: type of def: 3.
pa2-p2.c:80: note: vect_is_simple_use: operand _188
pa2-p2.c:80: note: def_stmt: _188 = a[k_17][i_184];

pa2-p2.c:80: note: type of def: 3.
pa2-p2.c:80: note: vect_is_simple_use: operand _188
pa2-p2.c:80: note: def_stmt: _188 = a[k_17][i_184];

pa2-p2.c:80: note: type of def: 3.
pa2-p2.c:80: note: === vect_analyze_dependences ===
pa2-p2.c:80: note: determined dependence between c[j_37][i_184] and c[j_37][i_184]
pa2-p2.c:80: note: can't determine dependence between c[j_37][i_184] and c[pretmp_145][i_184]
pa2-p2.c:80: note: can't determine dependence between c[j_37][i_184] and c[pretmp_146][i_184]
pa2-p2.c:80: note: can't determine dependence between c[j_37][i_184] and c[pretmp_147][i_184]
pa2-p2.c:80: note: can't determine dependence between c[j_37][i_184] and c[pretmp_145][i_184]
pa2-p2.c:80: note: not vectorized: unhandled data dependence in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:80: note: ===vect_slp_analyze_bb===

pa2-p2.c:80: note: === vect_analyze_data_refs ===

pa2-p2.c:80: note: not vectorized: no vectype for stmt: vect_var_.69_212 = MEM[(float[2000][2000] *)vect_pc.65_210];
 scalar_type: vector(4) float
pa2-p2.c:80: note: === vect_pattern_recog ===
pa2-p2.c:80: note: vect_is_simple_use: operand vect_var_.74_218
pa2-p2.c:80: note: def_stmt: vect_var_.74_218 = MEM[(float[2000][2000] *)vect_pa.70_216];

pa2-p2.c:80: note: type of def: 3.
pa2-p2.c:80: note: vect_is_simple_use: operand vect_var_.74_218
pa2-p2.c:80: note: def_stmt: vect_var_.74_218 = MEM[(float[2000][2000] *)vect_pa.70_216];

pa2-p2.c:80: note: type of def: 3.
pa2-p2.c:80: note: vect_is_simple_use: operand vect_var_.74_218
pa2-p2.c:80: note: def_stmt: vect_var_.74_218 = MEM[(float[2000][2000] *)vect_pa.70_216];

pa2-p2.c:80: note: type of def: 3.
pa2-p2.c:80: note: vect_is_simple_use: operand vect_var_.74_218
pa2-p2.c:80: note: def_stmt: vect_var_.74_218 = MEM[(float[2000][2000] *)vect_pa.70_216];

pa2-p2.c:80: note: type of def: 3.
pa2-p2.c:80: note: === vect_analyze_dependences ===
pa2-p2.c:80: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:80: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:80: note: === vect_analyze_slp ===
pa2-p2.c:80: note: Failed to SLP the basic block.
pa2-p2.c:80: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: get vectype with 4 units of type float
pa2-p2.c:64: note: vectype: vector(4) float
pa2-p2.c:64: note: === vect_pattern_recog ===
pa2-p2.c:64: note: vect_is_simple_use: operand _67
pa2-p2.c:64: note: def_stmt: _67 = (sizetype) j_15;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand j_15
pa2-p2.c:64: note: def_stmt: j_15 = PHI <j_74(27), j_3(33)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: vect_is_simple_use: operand _142
pa2-p2.c:64: note: def_stmt: _142 = (sizetype) k_87;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand k_87
pa2-p2.c:64: note: def_stmt: k_87 = PHI <k_89(34), k_76(24)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: vect_is_simple_use: operand _130
pa2-p2.c:64: note: def_stmt: _130 = (sizetype) j_15;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand j_15
pa2-p2.c:64: note: def_stmt: j_15 = PHI <j_74(27), j_3(33)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: === vect_analyze_dependences ===
pa2-p2.c:64: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:64: note: vect_compute_data_ref_alignment:
pa2-p2.c:64: note: Unknown alignment for access: b
pa2-p2.c:64: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:64: note: not consecutive access pretmp_158 = b[k_87][j_15];

pa2-p2.c:64: note: === vect_analyze_slp ===
pa2-p2.c:64: note: Failed to SLP the basic block.
pa2-p2.c:64: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:71: note: ===vect_slp_analyze_bb===

pa2-p2.c:71: note: === vect_analyze_data_refs ===

pa2-p2.c:71: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:72: note: ===vect_slp_analyze_bb===

pa2-p2.c:72: note: === vect_analyze_data_refs ===

pa2-p2.c:72: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:74: note: ===vect_slp_analyze_bb===

pa2-p2.c:74: note: === vect_analyze_data_refs ===

pa2-p2.c:74: note: not vectorized: no vectype for stmt: vect_var_.16_144 = MEM[(float[2000][2000] *)vect_pc.12_49];
 scalar_type: vector(4) float
pa2-p2.c:74: note: === vect_pattern_recog ===
pa2-p2.c:74: note: vect_is_simple_use: operand vect_var_.21_138
pa2-p2.c:74: note: def_stmt: vect_var_.21_138 = MEM[(float[2000][2000] *)vect_pa.17_140];

pa2-p2.c:74: note: type of def: 3.
pa2-p2.c:74: note: === vect_analyze_dependences ===
pa2-p2.c:74: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:74: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:74: note: === vect_analyze_slp ===
pa2-p2.c:74: note: Failed to SLP the basic block.
pa2-p2.c:74: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:64: note: ===vect_slp_analyze_bb===

pa2-p2.c:64: note: === vect_analyze_data_refs ===

pa2-p2.c:64: note: get vectype with 4 units of type float
pa2-p2.c:64: note: vectype: vector(4) float
pa2-p2.c:64: note: get vectype with 4 units of type float
pa2-p2.c:64: note: vectype: vector(4) float
pa2-p2.c:64: note: get vectype with 4 units of type float
pa2-p2.c:64: note: vectype: vector(4) float
pa2-p2.c:64: note: get vectype with 4 units of type float
pa2-p2.c:64: note: vectype: vector(4) float
pa2-p2.c:64: note: === vect_pattern_recog ===
pa2-p2.c:64: note: vect_is_simple_use: operand _123
pa2-p2.c:64: note: def_stmt: _123 = (sizetype) j_37;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand j_37
pa2-p2.c:64: note: def_stmt: j_37 = PHI <j_39(16), j_3(13)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: vect_is_simple_use: operand _119
pa2-p2.c:64: note: def_stmt: _119 = _120 + 1;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand _116
pa2-p2.c:64: note: def_stmt: _116 = (sizetype) j_37;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand j_37
pa2-p2.c:64: note: def_stmt: j_37 = PHI <j_39(16), j_3(13)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: vect_is_simple_use: operand _113
pa2-p2.c:64: note: def_stmt: _113 = (sizetype) j_37;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand j_37
pa2-p2.c:64: note: def_stmt: j_37 = PHI <j_39(16), j_3(13)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: vect_is_simple_use: operand _109
pa2-p2.c:64: note: def_stmt: _109 = (sizetype) j_37;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand j_37
pa2-p2.c:64: note: def_stmt: j_37 = PHI <j_39(16), j_3(13)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: vect_is_simple_use: operand _106
pa2-p2.c:64: note: def_stmt: _106 = (sizetype) j_37;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand j_37
pa2-p2.c:64: note: def_stmt: j_37 = PHI <j_39(16), j_3(13)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: vect_is_simple_use: operand _97
pa2-p2.c:64: note: def_stmt: _97 = _100 + 1;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand _94
pa2-p2.c:64: note: def_stmt: _94 = (sizetype) j_37;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand j_37
pa2-p2.c:64: note: def_stmt: j_37 = PHI <j_39(16), j_3(13)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: vect_is_simple_use: operand _84
pa2-p2.c:64: note: def_stmt: _84 = _88 + 1;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand _72
pa2-p2.c:64: note: def_stmt: _72 = (sizetype) j_37;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand j_37
pa2-p2.c:64: note: def_stmt: j_37 = PHI <j_39(16), j_3(13)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: vect_is_simple_use: operand _38
pa2-p2.c:64: note: def_stmt: _38 = (sizetype) j_37;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand j_37
pa2-p2.c:64: note: def_stmt: j_37 = PHI <j_39(16), j_3(13)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: vect_is_simple_use: operand _18
pa2-p2.c:64: note: def_stmt: _18 = (sizetype) j_37;

pa2-p2.c:64: note: type of def: 3.
pa2-p2.c:64: note: vect_is_simple_use: operand j_37
pa2-p2.c:64: note: def_stmt: j_37 = PHI <j_39(16), j_3(13)>

pa2-p2.c:64: note: type of def: 2.
pa2-p2.c:64: note: vect_is_simple_use: operand 8000
pa2-p2.c:64: note: === vect_analyze_dependences ===
pa2-p2.c:64: note: Detected interleaving b[k_17][j_37] and b[k_17][pretmp_145]
pa2-p2.c:64: note: Detected interleaving b[k_17][j_37] and b[k_17][pretmp_146]
pa2-p2.c:64: note: Detected interleaving b[k_17][j_37] and b[k_17][pretmp_147]
pa2-p2.c:64: note: Detected interleaving b[k_17][pretmp_145] and b[k_17][pretmp_146]
pa2-p2.c:64: note: Detected interleaving b[k_17][pretmp_145] and b[k_17][pretmp_147]
pa2-p2.c:64: note: Detected interleaving b[k_17][pretmp_146] and b[k_17][pretmp_147]
pa2-p2.c:64: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:64: note: vect_compute_data_ref_alignment:
pa2-p2.c:64: note: Unknown alignment for access: b
pa2-p2.c:64: note: vect_compute_data_ref_alignment:
pa2-p2.c:64: note: Unknown alignment for access: b
pa2-p2.c:64: note: vect_compute_data_ref_alignment:
pa2-p2.c:64: note: Unknown alignment for access: b
pa2-p2.c:64: note: vect_compute_data_ref_alignment:
pa2-p2.c:64: note: Unknown alignment for access: b
pa2-p2.c:64: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:64: note: Detected interleaving of size 2000
pa2-p2.c:64: note: === vect_analyze_slp ===
pa2-p2.c:64: note: Failed to SLP the basic block.
pa2-p2.c:64: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:97: note: ===vect_slp_analyze_bb===

pa2-p2.c:97: note: === vect_analyze_data_refs ===

pa2-p2.c:97: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:98: note: ===vect_slp_analyze_bb===

pa2-p2.c:98: note: === vect_analyze_data_refs ===

pa2-p2.c:98: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:99: note: ===vect_slp_analyze_bb===

pa2-p2.c:99: note: === vect_analyze_data_refs ===

pa2-p2.c:99: note: get vectype with 2 units of type __time_t
pa2-p2.c:99: note: vectype: vector(2) long int
pa2-p2.c:99: note: get vectype with 2 units of type __suseconds_t
pa2-p2.c:99: note: vectype: vector(2) long int
pa2-p2.c:99: note: get vectype with 2 units of type long unsigned int
pa2-p2.c:99: note: vectype: vector(2) long unsigned int
pa2-p2.c:99: note: not vectorized: no vectype for stmt: Tp ={v} {CLOBBER};
 scalar_type: struct timeval
pa2-p2.c:99: note: === vect_pattern_recog ===
pa2-p2.c:99: note: vect_is_simple_use: operand _9
pa2-p2.c:99: note: def_stmt: _9 = (double) _8;

pa2-p2.c:99: note: type of def: 3.
pa2-p2.c:99: note: === vect_analyze_dependences ===
pa2-p2.c:99: note: Detected interleaving Tp.tv_sec and Tp.tv_usec
pa2-p2.c:99: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:99: note: vect_compute_data_ref_alignment:
pa2-p2.c:99: note: misalign = 0 bytes of ref Tp.tv_sec
pa2-p2.c:99: note: vect_compute_data_ref_alignment:
pa2-p2.c:99: note: misalign = 8 bytes of ref Tp.tv_usec
pa2-p2.c:99: note: vect_compute_data_ref_alignment:
pa2-p2.c:99: note: misalign = 0 bytes of ref Tzp
pa2-p2.c:99: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:99: note: Detected interleaving of size 2
pa2-p2.c:99: note: not consecutive access Tzp ={v} {CLOBBER};

pa2-p2.c:99: note: === vect_analyze_slp ===
pa2-p2.c:99: note: Failed to SLP the basic block.
pa2-p2.c:99: note: not vectorized: failed to find SLP opportunities in basic block.

Analyzing loop at pa2-p2.c:109

pa2-p2.c:109: note: ===== analyze_loop_nest =====
pa2-p2.c:109: note: === vect_analyze_loop_form ===
pa2-p2.c:109: note: ===== analyze_loop_nest_1 =====
pa2-p2.c:109: note: === vect_analyze_loop_form ===
pa2-p2.c:109: note: not vectorized: control flow in loop.
pa2-p2.c:109: note: bad inner-loop form.
pa2-p2.c:109: note: not vectorized: Bad inner loop.
pa2-p2.c:109: note: bad loop form.
Analyzing loop at pa2-p2.c:110

pa2-p2.c:110: note: ===== analyze_loop_nest =====
pa2-p2.c:110: note: === vect_analyze_loop_form ===
pa2-p2.c:110: note: not vectorized: control flow in loop.
pa2-p2.c:110: note: bad loop form.
pa2-p2.c:102: note: vectorized 0 loops in function.

pa2-p2.c:102: note: ===vect_slp_analyze_bb===

pa2-p2.c:102: note: === vect_analyze_data_refs ===

pa2-p2.c:102: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:102: note: ===vect_slp_analyze_bb===

pa2-p2.c:102: note: === vect_analyze_data_refs ===

pa2-p2.c:102: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:102: note: ===vect_slp_analyze_bb===

pa2-p2.c:102: note: === vect_analyze_data_refs ===

pa2-p2.c:102: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:112: note: ===vect_slp_analyze_bb===

pa2-p2.c:112: note: === vect_analyze_data_refs ===

pa2-p2.c:112: note: get vectype with 4 units of type float
pa2-p2.c:112: note: vectype: vector(4) float
pa2-p2.c:112: note: get vectype with 4 units of type float
pa2-p2.c:112: note: vectype: vector(4) float
pa2-p2.c:112: note: === vect_pattern_recog ===
pa2-p2.c:112: note: === vect_analyze_dependences ===
pa2-p2.c:112: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:112: note: vect_compute_data_ref_alignment:
pa2-p2.c:112: note: SLP: step doesn't divide the vector-size.
pa2-p2.c:112: note: Unknown alignment for access: *(wref_16(D) + pretmp_54)
pa2-p2.c:112: note: vect_compute_data_ref_alignment:
pa2-p2.c:112: note: SLP: step doesn't divide the vector-size.
pa2-p2.c:112: note: Unknown alignment for access: *(w_23(D) + pretmp_54)
pa2-p2.c:112: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:112: note: === vect_analyze_slp ===
pa2-p2.c:112: note: Failed to SLP the basic block.
pa2-p2.c:112: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:113: note: ===vect_slp_analyze_bb===

pa2-p2.c:113: note: === vect_analyze_data_refs ===

pa2-p2.c:113: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:114: note: ===vect_slp_analyze_bb===

pa2-p2.c:114: note: === vect_analyze_data_refs ===

pa2-p2.c:114: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:115: note: ===vect_slp_analyze_bb===

pa2-p2.c:115: note: === vect_analyze_data_refs ===

pa2-p2.c:115: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:102: note: ===vect_slp_analyze_bb===

pa2-p2.c:102: note: === vect_analyze_data_refs ===

pa2-p2.c:102: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:110: note: ===vect_slp_analyze_bb===

pa2-p2.c:110: note: === vect_analyze_data_refs ===

pa2-p2.c:110: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:109: note: ===vect_slp_analyze_bb===

pa2-p2.c:109: note: === vect_analyze_data_refs ===

pa2-p2.c:109: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:102: note: ===vect_slp_analyze_bb===

pa2-p2.c:102: note: === vect_analyze_data_refs ===

pa2-p2.c:102: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:102: note: ===vect_slp_analyze_bb===

pa2-p2.c:102: note: === vect_analyze_data_refs ===

pa2-p2.c:102: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:119: note: ===vect_slp_analyze_bb===

pa2-p2.c:119: note: === vect_analyze_data_refs ===

pa2-p2.c:119: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:120: note: ===vect_slp_analyze_bb===

pa2-p2.c:120: note: === vect_analyze_data_refs ===

pa2-p2.c:120: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:123: note: ===vect_slp_analyze_bb===

pa2-p2.c:123: note: === vect_analyze_data_refs ===

pa2-p2.c:123: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:124: note: ===vect_slp_analyze_bb===

pa2-p2.c:124: note: === vect_analyze_data_refs ===

pa2-p2.c:124: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at pa2-p2.c:58

pa2-p2.c:58: note: ===== analyze_loop_nest =====
pa2-p2.c:58: note: === vect_analyze_loop_form ===
pa2-p2.c:58: note: ===== analyze_loop_nest_1 =====
pa2-p2.c:58: note: === vect_analyze_loop_form ===
pa2-p2.c:58: note: === get_loop_niters ===
pa2-p2.c:58: note: ==> get_loop_niters:2000
pa2-p2.c:58: note: Considering outer-loop vectorization.
pa2-p2.c:58: note: === get_loop_niters ===
pa2-p2.c:58: note: ==> get_loop_niters:2000
pa2-p2.c:58: note: === vect_analyze_data_refs ===

pa2-p2.c:58: note: analyze in outer-loop: c
pa2-p2.c:58: note: 	outer base_address: &c
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer aligned to: 128
pa2-p2.c:58: note: get vectype with 4 units of type float
pa2-p2.c:58: note: vectype: vector(4) float
pa2-p2.c:58: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:58: note: Analyze phi: .MEM_56 = PHI <.MEM_73(31), .MEM_77(37)>

pa2-p2.c:58: note: Analyze phi: i_130 = PHI <0(31), i_79(37)>

pa2-p2.c:58: note: Access function of PHI: {0, +, 1}_10
pa2-p2.c:58: note: step: 1,  init: 0
pa2-p2.c:58: note: Detected induction.
pa2-p2.c:58: note: Analyze phi: ivtmp_57 = PHI <2000(31), ivtmp_157(37)>

pa2-p2.c:58: note: Access function of PHI: {2000, +, 4294967295}_10
pa2-p2.c:58: note: step: 4294967295,  init: 2000
pa2-p2.c:58: note: Detected induction.
pa2-p2.c:58: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:58: note: Analyze phi: j_135 = PHI <j_78(34), 0(38)>

pa2-p2.c:58: note: Access function of PHI: {0, +, 1}_11
pa2-p2.c:58: note: step: 1,  init: 0
pa2-p2.c:58: note: Detected induction.
pa2-p2.c:58: note: Analyze phi: .MEM_141 = PHI <.MEM_77(34), .MEM_56(38)>

pa2-p2.c:58: note: Analyze phi: ivtmp_35 = PHI <ivtmp_62(34), 2000(38)>

pa2-p2.c:58: note: Access function of PHI: {2000, +, 4294967295}_11
pa2-p2.c:58: note: step: 4294967295,  init: 2000
pa2-p2.c:58: note: Detected induction.
pa2-p2.c:58: note: === vect_pattern_recog ===
pa2-p2.c:58: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p2.c:58: note: init: phi relevant? .MEM_56 = PHI <.MEM_73(31), .MEM_77(37)>

pa2-p2.c:58: note: init: phi relevant? i_130 = PHI <0(31), i_79(37)>

pa2-p2.c:58: note: init: phi relevant? ivtmp_57 = PHI <2000(31), ivtmp_157(37)>

pa2-p2.c:58: note: init: stmt relevant? # DEBUG i => i_130

pa2-p2.c:58: note: init: stmt relevant? # DEBUG j => 0

pa2-p2.c:58: note: init: phi relevant? j_135 = PHI <j_78(34), 0(38)>

pa2-p2.c:58: note: init: phi relevant? .MEM_141 = PHI <.MEM_77(34), .MEM_56(38)>

pa2-p2.c:58: note: init: phi relevant? ivtmp_35 = PHI <ivtmp_62(34), 2000(38)>

pa2-p2.c:58: note: init: stmt relevant? # DEBUG j => j_135

pa2-p2.c:58: note: init: stmt relevant? c[j_135][i_130] = 0.0;

pa2-p2.c:58: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:58: note: mark relevant 4, live 0.
pa2-p2.c:58: note: init: stmt relevant? j_78 = j_135 + 1;

pa2-p2.c:58: note: init: stmt relevant? # DEBUG j => j_78

pa2-p2.c:58: note: init: stmt relevant? # DEBUG j => j_78

pa2-p2.c:58: note: init: stmt relevant? ivtmp_62 = ivtmp_35 - 1;

pa2-p2.c:58: note: init: stmt relevant? if (ivtmp_62 != 0)

pa2-p2.c:58: note: init: stmt relevant? i_79 = i_130 + 1;

pa2-p2.c:58: note: init: stmt relevant? # DEBUG i => i_79

pa2-p2.c:58: note: init: stmt relevant? # DEBUG i => i_79

pa2-p2.c:58: note: init: stmt relevant? ivtmp_157 = ivtmp_57 - 1;

pa2-p2.c:58: note: init: stmt relevant? if (ivtmp_157 != 0)

pa2-p2.c:58: note: worklist: examine stmt: c[j_135][i_130] = 0.0;

pa2-p2.c:58: note: === vect_analyze_dependences ===
pa2-p2.c:58: note: === vect_determine_vectorization_factor ===
pa2-p2.c:58: note: ==> examining phi: .MEM_56 = PHI <.MEM_73(31), .MEM_77(37)>

pa2-p2.c:58: note: ==> examining phi: i_130 = PHI <0(31), i_79(37)>

pa2-p2.c:58: note: ==> examining phi: ivtmp_57 = PHI <2000(31), ivtmp_157(37)>

pa2-p2.c:58: note: ==> examining statement: # DEBUG i => i_130

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining statement: # DEBUG j => 0

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining phi: j_135 = PHI <j_78(34), 0(38)>

pa2-p2.c:58: note: ==> examining phi: .MEM_141 = PHI <.MEM_77(34), .MEM_56(38)>

pa2-p2.c:58: note: ==> examining phi: ivtmp_35 = PHI <ivtmp_62(34), 2000(38)>

pa2-p2.c:58: note: ==> examining statement: # DEBUG j => j_135

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining statement: c[j_135][i_130] = 0.0;

pa2-p2.c:58: note: get vectype for scalar type:  float
pa2-p2.c:58: note: get vectype with 4 units of type float
pa2-p2.c:58: note: vectype: vector(4) float
pa2-p2.c:58: note: vectype: vector(4) float
pa2-p2.c:58: note: nunits = 4
pa2-p2.c:58: note: ==> examining statement: j_78 = j_135 + 1;

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining statement: # DEBUG j => j_78

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining statement: # DEBUG j => j_78

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining statement: ivtmp_62 = ivtmp_35 - 1;

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining statement: if (ivtmp_62 != 0)

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining statement: i_79 = i_130 + 1;

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining statement: # DEBUG i => i_79

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining statement: # DEBUG i => i_79

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining statement: ivtmp_157 = ivtmp_57 - 1;

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: ==> examining statement: if (ivtmp_157 != 0)

pa2-p2.c:58: note: skip.
pa2-p2.c:58: note: vectorization factor = 4
pa2-p2.c:58: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:58: note: vect_compute_data_ref_alignment:
pa2-p2.c:58: note: inner step divides the vector-size.
pa2-p2.c:58: note: misalign = 0 bytes of ref c[j_135][i_130]
pa2-p2.c:58: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:58: note: === vect_prune_runtime_alias_test_list ===
pa2-p2.c:58: note: === vect_enhance_data_refs_alignment ===
pa2-p2.c:58: note: vect_can_advance_ivs_p:
pa2-p2.c:58: note: Analyze phi: .MEM_56 = PHI <.MEM_73(31), .MEM_77(37)>

pa2-p2.c:58: note: virtual phi. skip.
pa2-p2.c:58: note: Analyze phi: i_130 = PHI <0(31), i_79(37)>

pa2-p2.c:58: note: Access function of PHI: {0, +, 1}_10
pa2-p2.c:58: note: Analyze phi: ivtmp_57 = PHI <2000(31), ivtmp_157(37)>

pa2-p2.c:58: note: Access function of PHI: {2000, +, 4294967295}_10
pa2-p2.c:58: note: === vect_analyze_slp ===
pa2-p2.c:58: note: === vect_make_slp_decision ===
pa2-p2.c:58: note: === vect_detect_hybrid_slp ===
pa2-p2.c:58: note: === vect_analyze_loop_operations ===
pa2-p2.c:58: note: examining phi: .MEM_56 = PHI <.MEM_73(31), .MEM_77(37)>

pa2-p2.c:58: note: examining phi: i_130 = PHI <0(31), i_79(37)>

pa2-p2.c:58: note: examining phi: ivtmp_57 = PHI <2000(31), ivtmp_157(37)>

pa2-p2.c:58: note: ==> examining statement: # DEBUG i => i_130

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: ==> examining statement: # DEBUG j => 0

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: examining phi: j_135 = PHI <j_78(34), 0(38)>

pa2-p2.c:58: note: examining phi: .MEM_141 = PHI <.MEM_77(34), .MEM_56(38)>

pa2-p2.c:58: note: examining phi: ivtmp_35 = PHI <ivtmp_62(34), 2000(38)>

pa2-p2.c:58: note: ==> examining statement: # DEBUG j => j_135

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: ==> examining statement: c[j_135][i_130] = 0.0;

pa2-p2.c:58: note: vect_is_simple_use: operand 0.0
pa2-p2.c:58: note: vect_model_store_cost: aligned.
pa2-p2.c:58: note: vect_model_store_cost: inside_cost = 50, prologue_cost = 1 .
pa2-p2.c:58: note: ==> examining statement: j_78 = j_135 + 1;

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: ==> examining statement: # DEBUG j => j_78

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: ==> examining statement: # DEBUG j => j_78

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: ==> examining statement: ivtmp_62 = ivtmp_35 - 1;

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: ==> examining statement: if (ivtmp_62 != 0)

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: ==> examining statement: i_79 = i_130 + 1;

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: ==> examining statement: # DEBUG i => i_79

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: ==> examining statement: # DEBUG i => i_79

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: ==> examining statement: ivtmp_157 = ivtmp_57 - 1;

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: ==> examining statement: if (ivtmp_157 != 0)

pa2-p2.c:58: note: irrelevant.
pa2-p2.c:58: note: vectorization_factor = 4, niters = 2000
pa2-p2.c:58: note: === vect_update_slp_costs_according_to_vf ===
pa2-p2.c:58: note: Cost model analysis: 
  Vector inside of loop cost: 50
  Vector prologue cost: 1
  Vector epilogue cost: 0
  Scalar iteration cost: 50
  Scalar outside cost: 0
  Vector outside cost: 1
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

pa2-p2.c:58: note:   Runtime profitability threshold = 3

pa2-p2.c:58: note:   Static estimate profitability threshold = 3


Vectorizing loop at pa2-p2.c:58

pa2-p2.c:58: note: === vec_transform_loop ===
pa2-p2.c:58: note: ------>vectorizing phi: .MEM_56 = PHI <.MEM_73(40), .MEM_77(37)>

pa2-p2.c:58: note: ------>vectorizing phi: i_130 = PHI <0(40), i_79(37)>

pa2-p2.c:58: note: ------>vectorizing phi: ivtmp_57 = PHI <2000(40), ivtmp_157(37)>

pa2-p2.c:58: note: ------>vectorizing statement: # DEBUG i => i_130

pa2-p2.c:58: note: ------>vectorizing statement: # DEBUG j => 0

pa2-p2.c:58: note: ------>vectorizing phi: j_135 = PHI <j_78(34), 0(38)>

pa2-p2.c:58: note: ------>vectorizing phi: .MEM_141 = PHI <.MEM_77(34), .MEM_56(38)>

pa2-p2.c:58: note: ------>vectorizing phi: ivtmp_35 = PHI <ivtmp_62(34), 2000(38)>

pa2-p2.c:58: note: ------>vectorizing statement: # DEBUG j => j_135

pa2-p2.c:58: note: ------>vectorizing statement: c[j_135][i_130] = 0.0;

pa2-p2.c:58: note: transform statement.
pa2-p2.c:58: note: vect_is_simple_use: operand 0.0
pa2-p2.c:58: note: transform store. ncopies = 1
pa2-p2.c:58: note: vect_get_vec_def_for_operand: 0.0
pa2-p2.c:58: note: vect_is_simple_use: operand 0.0
pa2-p2.c:58: note: get vectype with 4 units of type float
pa2-p2.c:58: note: vectype: vector(4) float
pa2-p2.c:58: note: Create vector_cst. nunits = 4
pa2-p2.c:58: note: created new init_stmt: vect_cst_.255_113 = { 0.0, 0.0, 0.0, 0.0 };

pa2-p2.c:58: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:58: note: created vect_pc.259_112
pa2-p2.c:58: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.256_109] = vect_cst_.255_113;

pa2-p2.c:58: note: ------>vectorizing statement: j_78 = j_135 + 1;

pa2-p2.c:58: note: ------>vectorizing statement: # DEBUG j => j_78

pa2-p2.c:58: note: ------>vectorizing statement: # DEBUG j => j_78

pa2-p2.c:58: note: ------>vectorizing statement: ivtmp_62 = ivtmp_35 - 1;

pa2-p2.c:58: note: ------>vectorizing statement: vect_pc.256_108 = vect_pc.256_109 + 8000;

pa2-p2.c:58: note: ------>vectorizing statement: if (ivtmp_62 != 0)

pa2-p2.c:58: note: ------>vectorizing statement: i_79 = i_130 + 1;

pa2-p2.c:58: note: ------>vectorizing statement: # DEBUG i => i_79

pa2-p2.c:58: note: ------>vectorizing statement: # DEBUG i => i_79

pa2-p2.c:58: note: ------>vectorizing statement: ivtmp_157 = ivtmp_57 - 1;

pa2-p2.c:58: note: ------>vectorizing statement: vect_pc.256_110 = vect_pc.256_111 + 16;

pa2-p2.c:58: note: ------>vectorizing statement: if (ivtmp_157 != 0)
if (ivtmp_106 < 500)

pa2-p2.c:58: note: LOOP VECTORIZED.
pa2-p2.c:58: note: OUTER LOOP VECTORIZED.
Analyzing loop at pa2-p2.c:58

pa2-p2.c:58: note: ===== analyze_loop_nest =====
pa2-p2.c:58: note: outer-loop already vectorized.
Analyzing loop at pa2-p2.c:51

pa2-p2.c:51: note: ===== analyze_loop_nest =====
pa2-p2.c:51: note: === vect_analyze_loop_form ===
pa2-p2.c:51: note: ===== analyze_loop_nest_1 =====
pa2-p2.c:51: note: === vect_analyze_loop_form ===
pa2-p2.c:51: note: === get_loop_niters ===
pa2-p2.c:51: note: ==> get_loop_niters:2000
pa2-p2.c:51: note: Considering outer-loop vectorization.
pa2-p2.c:51: note: === get_loop_niters ===
pa2-p2.c:51: note: ==> get_loop_niters:2000
pa2-p2.c:51: note: === vect_analyze_data_refs ===

pa2-p2.c:51: note: analyze in outer-loop: c
pa2-p2.c:51: note: 	outer base_address: &c
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer aligned to: 128
pa2-p2.c:51: note: get vectype with 4 units of type float
pa2-p2.c:51: note: vectype: vector(4) float
pa2-p2.c:51: note: analyze in outer-loop: cc
pa2-p2.c:51: note: 	outer base_address: &cc
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer aligned to: 128
pa2-p2.c:51: note: get vectype with 4 units of type float
pa2-p2.c:51: note: vectype: vector(4) float
pa2-p2.c:51: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:51: note: Analyze phi: .MEM_49 = PHI <.MEM_70(27), .MEM_73(32)>

pa2-p2.c:51: note: Analyze phi: i_129 = PHI <0(27), i_75(32)>

pa2-p2.c:51: note: Access function of PHI: {0, +, 1}_8
pa2-p2.c:51: note: step: 1,  init: 0
pa2-p2.c:51: note: Detected induction.
pa2-p2.c:51: note: Analyze phi: ivtmp_145 = PHI <2000(27), ivtmp_144(32)>

pa2-p2.c:51: note: Access function of PHI: {2000, +, 4294967295}_8
pa2-p2.c:51: note: step: 4294967295,  init: 2000
pa2-p2.c:51: note: Detected induction.
pa2-p2.c:51: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:51: note: Analyze phi: j_134 = PHI <j_74(28), 0(33)>

pa2-p2.c:51: note: Access function of PHI: {0, +, 1}_9
pa2-p2.c:51: note: step: 1,  init: 0
pa2-p2.c:51: note: Detected induction.
pa2-p2.c:51: note: Analyze phi: .MEM_140 = PHI <.MEM_73(28), .MEM_49(33)>

pa2-p2.c:51: note: Analyze phi: ivtmp_154 = PHI <ivtmp_146(28), 2000(33)>

pa2-p2.c:51: note: Access function of PHI: {2000, +, 4294967295}_9
pa2-p2.c:51: note: step: 4294967295,  init: 2000
pa2-p2.c:51: note: Detected induction.
pa2-p2.c:51: note: === vect_pattern_recog ===
pa2-p2.c:51: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p2.c:51: note: init: phi relevant? .MEM_49 = PHI <.MEM_70(27), .MEM_73(32)>

pa2-p2.c:51: note: init: phi relevant? i_129 = PHI <0(27), i_75(32)>

pa2-p2.c:51: note: init: phi relevant? ivtmp_145 = PHI <2000(27), ivtmp_144(32)>

pa2-p2.c:51: note: init: stmt relevant? # DEBUG i => i_129

pa2-p2.c:51: note: init: stmt relevant? # DEBUG j => 0

pa2-p2.c:51: note: init: phi relevant? j_134 = PHI <j_74(28), 0(33)>

pa2-p2.c:51: note: init: phi relevant? .MEM_140 = PHI <.MEM_73(28), .MEM_49(33)>

pa2-p2.c:51: note: init: phi relevant? ivtmp_154 = PHI <ivtmp_146(28), 2000(33)>

pa2-p2.c:51: note: init: stmt relevant? # DEBUG j => j_134

pa2-p2.c:51: note: init: stmt relevant? _72 = c[j_134][i_129];

pa2-p2.c:51: note: init: stmt relevant? cc[j_134][i_129] = _72;

pa2-p2.c:51: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:51: note: mark relevant 4, live 0.
pa2-p2.c:51: note: init: stmt relevant? j_74 = j_134 + 1;

pa2-p2.c:51: note: init: stmt relevant? # DEBUG j => j_74

pa2-p2.c:51: note: init: stmt relevant? # DEBUG j => j_74

pa2-p2.c:51: note: init: stmt relevant? ivtmp_146 = ivtmp_154 - 1;

pa2-p2.c:51: note: init: stmt relevant? if (ivtmp_146 != 0)

pa2-p2.c:51: note: init: stmt relevant? i_75 = i_129 + 1;

pa2-p2.c:51: note: init: stmt relevant? # DEBUG i => i_75

pa2-p2.c:51: note: init: stmt relevant? # DEBUG i => i_75

pa2-p2.c:51: note: init: stmt relevant? ivtmp_144 = ivtmp_145 - 1;

pa2-p2.c:51: note: init: stmt relevant? if (ivtmp_144 != 0)

pa2-p2.c:51: note: worklist: examine stmt: cc[j_134][i_129] = _72;

pa2-p2.c:51: note: vect_is_simple_use: operand _72
pa2-p2.c:51: note: def_stmt: _72 = c[j_134][i_129];

pa2-p2.c:51: note: type of def: 3.
pa2-p2.c:51: note: mark relevant 4, live 0.
pa2-p2.c:51: note: worklist: examine stmt: _72 = c[j_134][i_129];

pa2-p2.c:51: note: === vect_analyze_dependences ===
pa2-p2.c:51: note: === vect_determine_vectorization_factor ===
pa2-p2.c:51: note: ==> examining phi: .MEM_49 = PHI <.MEM_70(27), .MEM_73(32)>

pa2-p2.c:51: note: ==> examining phi: i_129 = PHI <0(27), i_75(32)>

pa2-p2.c:51: note: ==> examining phi: ivtmp_145 = PHI <2000(27), ivtmp_144(32)>

pa2-p2.c:51: note: ==> examining statement: # DEBUG i => i_129

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining statement: # DEBUG j => 0

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining phi: j_134 = PHI <j_74(28), 0(33)>

pa2-p2.c:51: note: ==> examining phi: .MEM_140 = PHI <.MEM_73(28), .MEM_49(33)>

pa2-p2.c:51: note: ==> examining phi: ivtmp_154 = PHI <ivtmp_146(28), 2000(33)>

pa2-p2.c:51: note: ==> examining statement: # DEBUG j => j_134

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining statement: _72 = c[j_134][i_129];

pa2-p2.c:51: note: get vectype for scalar type:  float
pa2-p2.c:51: note: get vectype with 4 units of type float
pa2-p2.c:51: note: vectype: vector(4) float
pa2-p2.c:51: note: vectype: vector(4) float
pa2-p2.c:51: note: nunits = 4
pa2-p2.c:51: note: ==> examining statement: cc[j_134][i_129] = _72;

pa2-p2.c:51: note: get vectype for scalar type:  float
pa2-p2.c:51: note: get vectype with 4 units of type float
pa2-p2.c:51: note: vectype: vector(4) float
pa2-p2.c:51: note: vectype: vector(4) float
pa2-p2.c:51: note: nunits = 4
pa2-p2.c:51: note: ==> examining statement: j_74 = j_134 + 1;

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining statement: # DEBUG j => j_74

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining statement: # DEBUG j => j_74

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining statement: ivtmp_146 = ivtmp_154 - 1;

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining statement: if (ivtmp_146 != 0)

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining statement: i_75 = i_129 + 1;

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining statement: # DEBUG i => i_75

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining statement: # DEBUG i => i_75

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining statement: ivtmp_144 = ivtmp_145 - 1;

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: ==> examining statement: if (ivtmp_144 != 0)

pa2-p2.c:51: note: skip.
pa2-p2.c:51: note: vectorization factor = 4
pa2-p2.c:51: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:51: note: vect_compute_data_ref_alignment:
pa2-p2.c:51: note: inner step divides the vector-size.
pa2-p2.c:51: note: misalign = 0 bytes of ref c[j_134][i_129]
pa2-p2.c:51: note: vect_compute_data_ref_alignment:
pa2-p2.c:51: note: inner step divides the vector-size.
pa2-p2.c:51: note: misalign = 0 bytes of ref cc[j_134][i_129]
pa2-p2.c:51: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:51: note: === vect_prune_runtime_alias_test_list ===
pa2-p2.c:51: note: === vect_enhance_data_refs_alignment ===
pa2-p2.c:51: note: vect_can_advance_ivs_p:
pa2-p2.c:51: note: Analyze phi: .MEM_49 = PHI <.MEM_70(27), .MEM_73(32)>

pa2-p2.c:51: note: virtual phi. skip.
pa2-p2.c:51: note: Analyze phi: i_129 = PHI <0(27), i_75(32)>

pa2-p2.c:51: note: Access function of PHI: {0, +, 1}_8
pa2-p2.c:51: note: Analyze phi: ivtmp_145 = PHI <2000(27), ivtmp_144(32)>

pa2-p2.c:51: note: Access function of PHI: {2000, +, 4294967295}_8
pa2-p2.c:51: note: === vect_analyze_slp ===
pa2-p2.c:51: note: === vect_make_slp_decision ===
pa2-p2.c:51: note: === vect_detect_hybrid_slp ===
pa2-p2.c:51: note: === vect_analyze_loop_operations ===
pa2-p2.c:51: note: examining phi: .MEM_49 = PHI <.MEM_70(27), .MEM_73(32)>

pa2-p2.c:51: note: examining phi: i_129 = PHI <0(27), i_75(32)>

pa2-p2.c:51: note: examining phi: ivtmp_145 = PHI <2000(27), ivtmp_144(32)>

pa2-p2.c:51: note: ==> examining statement: # DEBUG i => i_129

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: ==> examining statement: # DEBUG j => 0

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: examining phi: j_134 = PHI <j_74(28), 0(33)>

pa2-p2.c:51: note: examining phi: .MEM_140 = PHI <.MEM_73(28), .MEM_49(33)>

pa2-p2.c:51: note: examining phi: ivtmp_154 = PHI <ivtmp_146(28), 2000(33)>

pa2-p2.c:51: note: ==> examining statement: # DEBUG j => j_134

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: ==> examining statement: _72 = c[j_134][i_129];

pa2-p2.c:51: note: num. args = 4 (not unary/binary/ternary op).
pa2-p2.c:51: note: vect_is_simple_use: operand c[j_134][i_129]
pa2-p2.c:51: note: not ssa-name.
pa2-p2.c:51: note: use not simple.
pa2-p2.c:51: note: vect_model_load_cost: aligned.
pa2-p2.c:51: note: vect_model_load_cost: inside_cost = 50, prologue_cost = 0 .
pa2-p2.c:51: note: ==> examining statement: cc[j_134][i_129] = _72;

pa2-p2.c:51: note: vect_is_simple_use: operand _72
pa2-p2.c:51: note: def_stmt: _72 = c[j_134][i_129];

pa2-p2.c:51: note: type of def: 3.
pa2-p2.c:51: note: vect_model_store_cost: aligned.
pa2-p2.c:51: note: vect_model_store_cost: inside_cost = 50, prologue_cost = 0 .
pa2-p2.c:51: note: ==> examining statement: j_74 = j_134 + 1;

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: ==> examining statement: # DEBUG j => j_74

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: ==> examining statement: # DEBUG j => j_74

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: ==> examining statement: ivtmp_146 = ivtmp_154 - 1;

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: ==> examining statement: if (ivtmp_146 != 0)

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: ==> examining statement: i_75 = i_129 + 1;

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: ==> examining statement: # DEBUG i => i_75

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: ==> examining statement: # DEBUG i => i_75

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: ==> examining statement: ivtmp_144 = ivtmp_145 - 1;

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: ==> examining statement: if (ivtmp_144 != 0)

pa2-p2.c:51: note: irrelevant.
pa2-p2.c:51: note: vectorization_factor = 4, niters = 2000
pa2-p2.c:51: note: === vect_update_slp_costs_according_to_vf ===
pa2-p2.c:51: note: Cost model analysis: 
  Vector inside of loop cost: 100
  Vector prologue cost: 0
  Vector epilogue cost: 0
  Scalar iteration cost: 100
  Scalar outside cost: 0
  Vector outside cost: 0
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

pa2-p2.c:51: note:   Runtime profitability threshold = 3

pa2-p2.c:51: note:   Static estimate profitability threshold = 3


Vectorizing loop at pa2-p2.c:51

pa2-p2.c:51: note: === vec_transform_loop ===
pa2-p2.c:51: note: ------>vectorizing phi: .MEM_49 = PHI <.MEM_70(41), .MEM_73(32)>

pa2-p2.c:51: note: ------>vectorizing phi: i_129 = PHI <0(41), i_75(32)>

pa2-p2.c:51: note: ------>vectorizing phi: ivtmp_145 = PHI <2000(41), ivtmp_144(32)>

pa2-p2.c:51: note: ------>vectorizing statement: # DEBUG i => i_129

pa2-p2.c:51: note: ------>vectorizing statement: # DEBUG j => 0

pa2-p2.c:51: note: ------>vectorizing phi: j_134 = PHI <j_74(28), 0(33)>

pa2-p2.c:51: note: ------>vectorizing phi: .MEM_140 = PHI <.MEM_73(28), .MEM_49(33)>

pa2-p2.c:51: note: ------>vectorizing phi: ivtmp_154 = PHI <ivtmp_146(28), 2000(33)>

pa2-p2.c:51: note: ------>vectorizing statement: # DEBUG j => j_134

pa2-p2.c:51: note: ------>vectorizing statement: _72 = c[j_134][i_129];

pa2-p2.c:51: note: transform statement.
pa2-p2.c:51: note: transform load. ncopies = 1
pa2-p2.c:51: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:51: note: created vect_pc.263_105
pa2-p2.c:51: note: add new stmt: vect_var_.264_22 = MEM[(float[2000][2000] *)vect_pc.260_71];

pa2-p2.c:51: note: ------>vectorizing statement: cc[j_134][i_129] = _72;

pa2-p2.c:51: note: transform statement.
pa2-p2.c:51: note: vect_is_simple_use: operand _72
pa2-p2.c:51: note: def_stmt: _72 = c[j_134][i_129];

pa2-p2.c:51: note: type of def: 3.
pa2-p2.c:51: note: transform store. ncopies = 1
pa2-p2.c:51: note: vect_get_vec_def_for_operand: _72
pa2-p2.c:51: note: vect_is_simple_use: operand _72
pa2-p2.c:51: note: def_stmt: _72 = c[j_134][i_129];

pa2-p2.c:51: note: type of def: 3.
pa2-p2.c:51: note: def =  _72  def_stmt =  _72 = c[j_134][i_129];

pa2-p2.c:51: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: cc
pa2-p2.c:51: note: created vect_pcc.268_21
pa2-p2.c:51: note: add new stmt: MEM[(float[2000][2000] *)vect_pcc.265_18] = vect_var_.264_22;

pa2-p2.c:51: note: ------>vectorizing statement: j_74 = j_134 + 1;

pa2-p2.c:51: note: ------>vectorizing statement: # DEBUG j => j_74

pa2-p2.c:51: note: ------>vectorizing statement: # DEBUG j => j_74

pa2-p2.c:51: note: ------>vectorizing statement: ivtmp_146 = ivtmp_154 - 1;

pa2-p2.c:51: note: ------>vectorizing statement: vect_pc.260_34 = vect_pc.260_71 + 8000;

pa2-p2.c:51: note: ------>vectorizing statement: vect_pcc.265_11 = vect_pcc.265_18 + 8000;

pa2-p2.c:51: note: ------>vectorizing statement: if (ivtmp_146 != 0)

pa2-p2.c:51: note: ------>vectorizing statement: i_75 = i_129 + 1;

pa2-p2.c:51: note: ------>vectorizing statement: # DEBUG i => i_75

pa2-p2.c:51: note: ------>vectorizing statement: # DEBUG i => i_75

pa2-p2.c:51: note: ------>vectorizing statement: ivtmp_144 = ivtmp_145 - 1;

pa2-p2.c:51: note: ------>vectorizing statement: vect_pc.260_76 = vect_pc.260_104 + 16;

pa2-p2.c:51: note: ------>vectorizing statement: vect_pcc.265_19 = vect_pcc.265_20 + 16;

pa2-p2.c:51: note: ------>vectorizing statement: if (ivtmp_144 != 0)
if (ivtmp_9 < 500)

pa2-p2.c:51: note: LOOP VECTORIZED.
pa2-p2.c:51: note: OUTER LOOP VECTORIZED.
Analyzing loop at pa2-p2.c:52

pa2-p2.c:52: note: ===== analyze_loop_nest =====
pa2-p2.c:52: note: outer-loop already vectorized.
Analyzing loop at pa2-p2.c:44

pa2-p2.c:44: note: ===== analyze_loop_nest =====
pa2-p2.c:44: note: === vect_analyze_loop_form ===
pa2-p2.c:44: note: not vectorized: multiple nested loops.
pa2-p2.c:44: note: bad loop form.
Analyzing loop at pa2-p2.c:45

pa2-p2.c:45: note: ===== analyze_loop_nest =====
pa2-p2.c:45: note: === vect_analyze_loop_form ===
pa2-p2.c:45: note: ===== analyze_loop_nest_1 =====
pa2-p2.c:45: note: === vect_analyze_loop_form ===
pa2-p2.c:45: note: === get_loop_niters ===
pa2-p2.c:45: note: ==> get_loop_niters:2000
pa2-p2.c:45: note: Considering outer-loop vectorization.
pa2-p2.c:45: note: === get_loop_niters ===
pa2-p2.c:45: note: ==> get_loop_niters:2000
pa2-p2.c:45: note: === vect_analyze_data_refs ===

pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: analyze in outer-loop: a
pa2-p2.c:45: note: 	outer base_address: &a
	outer offset from base address: (ssizetype) ((sizetype) i_128 * 4)
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 4
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: analyze in outer-loop: b
pa2-p2.c:45: note: 	outer base_address: &b
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer aligned to: 128
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:45: note: Analyze phi: .MEM_97 = PHI <.MEM_88(26), .MEM_156(22)>

pa2-p2.c:45: note: Analyze phi: j_133 = PHI <0(26), j_64(22)>

pa2-p2.c:45: note: Access function of PHI: {0, +, 1}_6
pa2-p2.c:45: note: step: 1,  init: 0
pa2-p2.c:45: note: Detected induction.
pa2-p2.c:45: note: Analyze phi: ivtmp_125 = PHI <2000(26), ivtmp_124(22)>

pa2-p2.c:45: note: Access function of PHI: {2000, +, 4294967295}_6
pa2-p2.c:45: note: step: 4294967295,  init: 2000
pa2-p2.c:45: note: Detected induction.
pa2-p2.c:45: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:45: note: Analyze phi: k_136 = PHI <k_63(19), 0(23)>

pa2-p2.c:45: note: Access function of PHI: {0, +, 1}_7
pa2-p2.c:45: note: step: 1,  init: 0
pa2-p2.c:45: note: Detected induction.
pa2-p2.c:45: note: Analyze phi: .MEM_139 = PHI <.MEM_139(19), .MEM_97(23)>

pa2-p2.c:45: note: Analyze phi: prephitmp_152 = PHI <_61(19), pretmp_151(23)>

pa2-p2.c:45: note: Access function of PHI: {pretmp_151, +, _60}_7
pa2-p2.c:45: note: step: _60,  init: pretmp_151
pa2-p2.c:45: note: step unknown.
pa2-p2.c:45: note: Analyze phi: ivtmp_143 = PHI <ivtmp_142(19), 2000(23)>

pa2-p2.c:45: note: Access function of PHI: {2000, +, 4294967295}_7
pa2-p2.c:45: note: step: 4294967295,  init: 2000
pa2-p2.c:45: note: Detected induction.
pa2-p2.c:45: note: Analyze phi: prephitmp_152 = PHI <_61(19), pretmp_151(23)>

pa2-p2.c:45: note: detected reduction: _61 = _60 + prephitmp_152;

pa2-p2.c:45: note: Detected vectorizable nested cycle.
pa2-p2.c:45: note: === vect_pattern_recog ===
pa2-p2.c:45: note: vect_is_simple_use: operand _58
pa2-p2.c:45: note: def_stmt: _58 = a[k_136][i_128];

pa2-p2.c:45: note: type of def: 3.
pa2-p2.c:45: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p2.c:45: note: init: phi relevant? .MEM_97 = PHI <.MEM_88(26), .MEM_156(22)>

pa2-p2.c:45: note: init: phi relevant? j_133 = PHI <0(26), j_64(22)>

pa2-p2.c:45: note: init: phi relevant? ivtmp_125 = PHI <2000(26), ivtmp_124(22)>

pa2-p2.c:45: note: init: stmt relevant? # DEBUG j => j_133

pa2-p2.c:45: note: init: stmt relevant? # DEBUG k => 0

pa2-p2.c:45: note: init: stmt relevant? pretmp_151 = c[j_133][i_128];

pa2-p2.c:45: note: init: phi relevant? k_136 = PHI <k_63(19), 0(23)>

pa2-p2.c:45: note: init: phi relevant? .MEM_139 = PHI <.MEM_139(19), .MEM_97(23)>

pa2-p2.c:45: note: init: phi relevant? prephitmp_152 = PHI <_61(19), pretmp_151(23)>

pa2-p2.c:45: note: init: phi relevant? ivtmp_143 = PHI <ivtmp_142(19), 2000(23)>

pa2-p2.c:45: note: init: stmt relevant? # DEBUG k => k_136

pa2-p2.c:45: note: init: stmt relevant? _58 = a[k_136][i_128];

pa2-p2.c:45: note: init: stmt relevant? _59 = b[k_136][j_133];

pa2-p2.c:45: note: init: stmt relevant? _60 = _58 * _59;

pa2-p2.c:45: note: init: stmt relevant? _61 = _60 + prephitmp_152;

pa2-p2.c:45: note: init: stmt relevant? k_63 = k_136 + 1;

pa2-p2.c:45: note: init: stmt relevant? # DEBUG k => k_63

pa2-p2.c:45: note: init: stmt relevant? # DEBUG k => k_63

pa2-p2.c:45: note: init: stmt relevant? ivtmp_142 = ivtmp_143 - 1;

pa2-p2.c:45: note: init: stmt relevant? if (ivtmp_142 != 0)

pa2-p2.c:45: note: init: phi relevant? c_I_I_lsm.254_155 = PHI <_61(20)>

pa2-p2.c:45: note: init: stmt relevant? c[j_133][i_128] = c_I_I_lsm.254_155;

pa2-p2.c:45: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:45: note: mark relevant 4, live 0.
pa2-p2.c:45: note: init: stmt relevant? j_64 = j_133 + 1;

pa2-p2.c:45: note: init: stmt relevant? # DEBUG j => j_64

pa2-p2.c:45: note: init: stmt relevant? # DEBUG j => j_64

pa2-p2.c:45: note: init: stmt relevant? ivtmp_124 = ivtmp_125 - 1;

pa2-p2.c:45: note: init: stmt relevant? if (ivtmp_124 != 0)

pa2-p2.c:45: note: worklist: examine stmt: c[j_133][i_128] = c_I_I_lsm.254_155;

pa2-p2.c:45: note: vect_is_simple_use: operand c_I_I_lsm.254_155
pa2-p2.c:45: note: def_stmt: c_I_I_lsm.254_155 = PHI <_61(20)>

pa2-p2.c:45: note: type of def: 3.
pa2-p2.c:45: note: mark relevant 4, live 0.
pa2-p2.c:45: note: worklist: examine stmt: c_I_I_lsm.254_155 = PHI <_61(20)>

pa2-p2.c:45: note: vect_is_simple_use: operand _61
pa2-p2.c:45: note: def_stmt: _61 = _60 + prephitmp_152;

pa2-p2.c:45: note: type of def: 7.
pa2-p2.c:45: note: inner-loop def-stmt defining outer-loop stmt.
pa2-p2.c:45: note: mark relevant 2, live 0.
pa2-p2.c:45: note: worklist: examine stmt: _61 = _60 + prephitmp_152;

pa2-p2.c:45: note: vect_is_simple_use: operand _60
pa2-p2.c:45: note: def_stmt: _60 = _58 * _59;

pa2-p2.c:45: note: type of def: 3.
pa2-p2.c:45: note: mark relevant 2, live 0.
pa2-p2.c:45: note: vect_is_simple_use: operand prephitmp_152
pa2-p2.c:45: note: def_stmt: prephitmp_152 = PHI <_61(19), pretmp_151(23)>

pa2-p2.c:45: note: type of def: 7.
pa2-p2.c:45: note: mark relevant 2, live 0.
pa2-p2.c:45: note: worklist: examine stmt: prephitmp_152 = PHI <_61(19), pretmp_151(23)>

pa2-p2.c:45: note: vect_is_simple_use: operand _61
pa2-p2.c:45: note: def_stmt: _61 = _60 + prephitmp_152;

pa2-p2.c:45: note: type of def: 7.
pa2-p2.c:45: note: mark relevant 2, live 0.
pa2-p2.c:45: note: already marked relevant/live.
pa2-p2.c:45: note: vect_is_simple_use: operand pretmp_151
pa2-p2.c:45: note: def_stmt: pretmp_151 = c[j_133][i_128];

pa2-p2.c:45: note: type of def: 3.
pa2-p2.c:45: note: outer-loop def-stmt defining inner-loop stmt.
pa2-p2.c:45: note: mark relevant 4, live 0.
pa2-p2.c:45: note: worklist: examine stmt: pretmp_151 = c[j_133][i_128];

pa2-p2.c:45: note: worklist: examine stmt: _60 = _58 * _59;

pa2-p2.c:45: note: vect_is_simple_use: operand _58
pa2-p2.c:45: note: def_stmt: _58 = a[k_136][i_128];

pa2-p2.c:45: note: type of def: 3.
pa2-p2.c:45: note: mark relevant 2, live 0.
pa2-p2.c:45: note: vect_is_simple_use: operand _59
pa2-p2.c:45: note: def_stmt: _59 = b[k_136][j_133];

pa2-p2.c:45: note: type of def: 3.
pa2-p2.c:45: note: mark relevant 2, live 0.
pa2-p2.c:45: note: worklist: examine stmt: _59 = b[k_136][j_133];

pa2-p2.c:45: note: worklist: examine stmt: _58 = a[k_136][i_128];

pa2-p2.c:45: note: === vect_analyze_dependences ===
pa2-p2.c:45: note: dependence distance  = 0.
pa2-p2.c:45: note: dependence distance == 0 between c[j_133][i_128] and c[j_133][i_128]
pa2-p2.c:45: note: === vect_determine_vectorization_factor ===
pa2-p2.c:45: note: ==> examining phi: .MEM_97 = PHI <.MEM_88(26), .MEM_156(22)>

pa2-p2.c:45: note: ==> examining phi: j_133 = PHI <0(26), j_64(22)>

pa2-p2.c:45: note: ==> examining phi: ivtmp_125 = PHI <2000(26), ivtmp_124(22)>

pa2-p2.c:45: note: ==> examining statement: # DEBUG j => j_133

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining statement: # DEBUG k => 0

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining statement: pretmp_151 = c[j_133][i_128];

pa2-p2.c:45: note: get vectype for scalar type:  float
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: nunits = 4
pa2-p2.c:45: note: ==> examining phi: k_136 = PHI <k_63(19), 0(23)>

pa2-p2.c:45: note: ==> examining phi: .MEM_139 = PHI <.MEM_139(19), .MEM_97(23)>

pa2-p2.c:45: note: ==> examining phi: prephitmp_152 = PHI <_61(19), pretmp_151(23)>

pa2-p2.c:45: note: get vectype for scalar type:  float
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: nunits = 4
pa2-p2.c:45: note: ==> examining phi: ivtmp_143 = PHI <ivtmp_142(19), 2000(23)>

pa2-p2.c:45: note: ==> examining statement: # DEBUG k => k_136

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining statement: _58 = a[k_136][i_128];

pa2-p2.c:45: note: get vectype for scalar type:  float
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: nunits = 4
pa2-p2.c:45: note: ==> examining statement: _59 = b[k_136][j_133];

pa2-p2.c:45: note: get vectype for scalar type:  float
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: nunits = 4
pa2-p2.c:45: note: ==> examining statement: _60 = _58 * _59;

pa2-p2.c:45: note: get vectype for scalar type:  float
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: get vectype for scalar type:  float
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: nunits = 4
pa2-p2.c:45: note: ==> examining statement: _61 = _60 + prephitmp_152;

pa2-p2.c:45: note: get vectype for scalar type:  float
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: get vectype for scalar type:  float
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: nunits = 4
pa2-p2.c:45: note: ==> examining statement: k_63 = k_136 + 1;

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining statement: # DEBUG k => k_63

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining statement: # DEBUG k => k_63

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining statement: ivtmp_142 = ivtmp_143 - 1;

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining statement: if (ivtmp_142 != 0)

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining phi: c_I_I_lsm.254_155 = PHI <_61(20)>

pa2-p2.c:45: note: get vectype for scalar type:  float
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: nunits = 4
pa2-p2.c:45: note: ==> examining statement: c[j_133][i_128] = c_I_I_lsm.254_155;

pa2-p2.c:45: note: get vectype for scalar type:  float
pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: nunits = 4
pa2-p2.c:45: note: ==> examining statement: j_64 = j_133 + 1;

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining statement: # DEBUG j => j_64

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining statement: # DEBUG j => j_64

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining statement: ivtmp_124 = ivtmp_125 - 1;

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: ==> examining statement: if (ivtmp_124 != 0)

pa2-p2.c:45: note: skip.
pa2-p2.c:45: note: vectorization factor = 4
pa2-p2.c:45: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:45: note: dependence distance  = 0.
pa2-p2.c:45: note: accesses have the same alignment.dependence distance modulo vf == 0 between c[j_133][i_128] and c[j_133][i_128]
pa2-p2.c:45: note: vect_compute_data_ref_alignment:
pa2-p2.c:45: note: Unknown alignment for access: c
pa2-p2.c:45: note: vect_compute_data_ref_alignment:
pa2-p2.c:45: note: inner step divides the vector-size.
pa2-p2.c:45: note: Unknown alignment for access: a
pa2-p2.c:45: note: vect_compute_data_ref_alignment:
pa2-p2.c:45: note: inner step divides the vector-size.
pa2-p2.c:45: note: misalign = 0 bytes of ref b[k_136][j_133]
pa2-p2.c:45: note: vect_compute_data_ref_alignment:
pa2-p2.c:45: note: Unknown alignment for access: c
pa2-p2.c:45: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:45: note: not consecutive access pretmp_151 = c[j_133][i_128];

pa2-p2.c:45: note: not vectorized: complicated access pattern.
pa2-p2.c:45: note: bad data access.
Analyzing loop at pa2-p2.c:46

pa2-p2.c:46: note: ===== analyze_loop_nest =====
pa2-p2.c:46: note: === vect_analyze_loop_form ===
pa2-p2.c:46: note: === get_loop_niters ===
pa2-p2.c:46: note: ==> get_loop_niters:2000
pa2-p2.c:46: note: === vect_analyze_data_refs ===

pa2-p2.c:46: note: get vectype with 4 units of type float
pa2-p2.c:46: note: vectype: vector(4) float
pa2-p2.c:46: note: get vectype with 4 units of type float
pa2-p2.c:46: note: vectype: vector(4) float
pa2-p2.c:46: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:46: note: Analyze phi: k_136 = PHI <k_63(19), 0(23)>

pa2-p2.c:46: note: Access function of PHI: {0, +, 1}_7
pa2-p2.c:46: note: step: 1,  init: 0
pa2-p2.c:46: note: Detected induction.
pa2-p2.c:46: note: Analyze phi: .MEM_139 = PHI <.MEM_139(19), .MEM_97(23)>

pa2-p2.c:46: note: Analyze phi: prephitmp_152 = PHI <_61(19), pretmp_151(23)>

pa2-p2.c:46: note: Access function of PHI: {pretmp_151, +, _60}_7
pa2-p2.c:46: note: step: _60,  init: pretmp_151
pa2-p2.c:46: note: step unknown.
pa2-p2.c:46: note: Analyze phi: ivtmp_143 = PHI <ivtmp_142(19), 2000(23)>

pa2-p2.c:46: note: Access function of PHI: {2000, +, 4294967295}_7
pa2-p2.c:46: note: step: 4294967295,  init: 2000
pa2-p2.c:46: note: Detected induction.
pa2-p2.c:46: note: Analyze phi: prephitmp_152 = PHI <_61(19), pretmp_151(23)>

pa2-p2.c:46: note: reduction: unsafe fp math optimization: _61 = _60 + prephitmp_152;

pa2-p2.c:46: note: Unknown def-use cycle pattern.
pa2-p2.c:46: note: === vect_pattern_recog ===
pa2-p2.c:46: note: vect_is_simple_use: operand _58
pa2-p2.c:46: note: def_stmt: _58 = a[k_136][i_128];

pa2-p2.c:46: note: type of def: 3.
pa2-p2.c:46: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p2.c:46: note: init: phi relevant? k_136 = PHI <k_63(19), 0(23)>

pa2-p2.c:46: note: init: phi relevant? .MEM_139 = PHI <.MEM_139(19), .MEM_97(23)>

pa2-p2.c:46: note: init: phi relevant? prephitmp_152 = PHI <_61(19), pretmp_151(23)>

pa2-p2.c:46: note: init: phi relevant? ivtmp_143 = PHI <ivtmp_142(19), 2000(23)>

pa2-p2.c:46: note: init: stmt relevant? # DEBUG k => k_136

pa2-p2.c:46: note: init: stmt relevant? _58 = a[k_136][i_128];

pa2-p2.c:46: note: init: stmt relevant? _59 = b[k_136][j_133];

pa2-p2.c:46: note: init: stmt relevant? _60 = _58 * _59;

pa2-p2.c:46: note: init: stmt relevant? _61 = _60 + prephitmp_152;

pa2-p2.c:46: note: vec_stmt_relevant_p: used out of loop.
pa2-p2.c:46: note: mark relevant 0, live 1.
pa2-p2.c:46: note: init: stmt relevant? k_63 = k_136 + 1;

pa2-p2.c:46: note: init: stmt relevant? # DEBUG k => k_63

pa2-p2.c:46: note: init: stmt relevant? # DEBUG k => k_63

pa2-p2.c:46: note: init: stmt relevant? ivtmp_142 = ivtmp_143 - 1;

pa2-p2.c:46: note: init: stmt relevant? if (ivtmp_142 != 0)

pa2-p2.c:46: note: worklist: examine stmt: _61 = _60 + prephitmp_152;

pa2-p2.c:46: note: vect_is_simple_use: operand _60
pa2-p2.c:46: note: def_stmt: _60 = _58 * _59;

pa2-p2.c:46: note: type of def: 3.
pa2-p2.c:46: note: mark relevant 0, live 1.
pa2-p2.c:46: note: vect_is_simple_use: operand prephitmp_152
pa2-p2.c:46: note: def_stmt: prephitmp_152 = PHI <_61(19), pretmp_151(23)>

pa2-p2.c:46: note: Unsupported pattern.
pa2-p2.c:46: note: not vectorized: unsupported use in stmt.
pa2-p2.c:46: note: unexpected pattern.
Analyzing loop at pa2-p2.c:42

pa2-p2.c:42: note: ===== analyze_loop_nest =====
pa2-p2.c:42: note: === vect_analyze_loop_form ===
pa2-p2.c:42: note: ===== analyze_loop_nest_1 =====
pa2-p2.c:42: note: === vect_analyze_loop_form ===
pa2-p2.c:42: note: === get_loop_niters ===
pa2-p2.c:42: note: ==> get_loop_niters:2000
pa2-p2.c:42: note: Considering outer-loop vectorization.
pa2-p2.c:42: note: === get_loop_niters ===
pa2-p2.c:42: note: ==> get_loop_niters:2000
pa2-p2.c:42: note: === vect_analyze_data_refs ===

pa2-p2.c:42: note: analyze in outer-loop: c
pa2-p2.c:42: note: 	outer base_address: &c
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer aligned to: 128
pa2-p2.c:42: note: get vectype with 4 units of type float
pa2-p2.c:42: note: vectype: vector(4) float
pa2-p2.c:42: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:42: note: Analyze phi: .MEM_101 = PHI <.MEM_46(10), .MEM_50(16)>

pa2-p2.c:42: note: Analyze phi: i_127 = PHI <0(10), i_52(16)>

pa2-p2.c:42: note: Access function of PHI: {0, +, 1}_3
pa2-p2.c:42: note: step: 1,  init: 0
pa2-p2.c:42: note: Detected induction.
pa2-p2.c:42: note: Analyze phi: ivtmp_119 = PHI <2000(10), ivtmp_118(16)>

pa2-p2.c:42: note: Access function of PHI: {2000, +, 4294967295}_3
pa2-p2.c:42: note: step: 4294967295,  init: 2000
pa2-p2.c:42: note: Detected induction.
pa2-p2.c:42: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:42: note: Analyze phi: j_132 = PHI <j_51(13), 0(17)>

pa2-p2.c:42: note: Access function of PHI: {0, +, 1}_4
pa2-p2.c:42: note: step: 1,  init: 0
pa2-p2.c:42: note: Detected induction.
pa2-p2.c:42: note: Analyze phi: .MEM_138 = PHI <.MEM_50(13), .MEM_101(17)>

pa2-p2.c:42: note: Analyze phi: ivtmp_121 = PHI <ivtmp_120(13), 2000(17)>

pa2-p2.c:42: note: Access function of PHI: {2000, +, 4294967295}_4
pa2-p2.c:42: note: step: 4294967295,  init: 2000
pa2-p2.c:42: note: Detected induction.
pa2-p2.c:42: note: === vect_pattern_recog ===
pa2-p2.c:42: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p2.c:42: note: init: phi relevant? .MEM_101 = PHI <.MEM_46(10), .MEM_50(16)>

pa2-p2.c:42: note: init: phi relevant? i_127 = PHI <0(10), i_52(16)>

pa2-p2.c:42: note: init: phi relevant? ivtmp_119 = PHI <2000(10), ivtmp_118(16)>

pa2-p2.c:42: note: init: stmt relevant? # DEBUG i => i_127

pa2-p2.c:42: note: init: stmt relevant? # DEBUG j => 0

pa2-p2.c:42: note: init: phi relevant? j_132 = PHI <j_51(13), 0(17)>

pa2-p2.c:42: note: init: phi relevant? .MEM_138 = PHI <.MEM_50(13), .MEM_101(17)>

pa2-p2.c:42: note: init: phi relevant? ivtmp_121 = PHI <ivtmp_120(13), 2000(17)>

pa2-p2.c:42: note: init: stmt relevant? # DEBUG j => j_132

pa2-p2.c:42: note: init: stmt relevant? c[j_132][i_127] = 0.0;

pa2-p2.c:42: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:42: note: mark relevant 4, live 0.
pa2-p2.c:42: note: init: stmt relevant? j_51 = j_132 + 1;

pa2-p2.c:42: note: init: stmt relevant? # DEBUG j => j_51

pa2-p2.c:42: note: init: stmt relevant? # DEBUG j => j_51

pa2-p2.c:42: note: init: stmt relevant? ivtmp_120 = ivtmp_121 - 1;

pa2-p2.c:42: note: init: stmt relevant? if (ivtmp_120 != 0)

pa2-p2.c:42: note: init: stmt relevant? i_52 = i_127 + 1;

pa2-p2.c:42: note: init: stmt relevant? # DEBUG i => i_52

pa2-p2.c:42: note: init: stmt relevant? # DEBUG i => i_52

pa2-p2.c:42: note: init: stmt relevant? ivtmp_118 = ivtmp_119 - 1;

pa2-p2.c:42: note: init: stmt relevant? if (ivtmp_118 != 0)

pa2-p2.c:42: note: worklist: examine stmt: c[j_132][i_127] = 0.0;

pa2-p2.c:42: note: === vect_analyze_dependences ===
pa2-p2.c:42: note: === vect_determine_vectorization_factor ===
pa2-p2.c:42: note: ==> examining phi: .MEM_101 = PHI <.MEM_46(10), .MEM_50(16)>

pa2-p2.c:42: note: ==> examining phi: i_127 = PHI <0(10), i_52(16)>

pa2-p2.c:42: note: ==> examining phi: ivtmp_119 = PHI <2000(10), ivtmp_118(16)>

pa2-p2.c:42: note: ==> examining statement: # DEBUG i => i_127

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining statement: # DEBUG j => 0

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining phi: j_132 = PHI <j_51(13), 0(17)>

pa2-p2.c:42: note: ==> examining phi: .MEM_138 = PHI <.MEM_50(13), .MEM_101(17)>

pa2-p2.c:42: note: ==> examining phi: ivtmp_121 = PHI <ivtmp_120(13), 2000(17)>

pa2-p2.c:42: note: ==> examining statement: # DEBUG j => j_132

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining statement: c[j_132][i_127] = 0.0;

pa2-p2.c:42: note: get vectype for scalar type:  float
pa2-p2.c:42: note: get vectype with 4 units of type float
pa2-p2.c:42: note: vectype: vector(4) float
pa2-p2.c:42: note: vectype: vector(4) float
pa2-p2.c:42: note: nunits = 4
pa2-p2.c:42: note: ==> examining statement: j_51 = j_132 + 1;

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining statement: # DEBUG j => j_51

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining statement: # DEBUG j => j_51

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining statement: ivtmp_120 = ivtmp_121 - 1;

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining statement: if (ivtmp_120 != 0)

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining statement: i_52 = i_127 + 1;

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining statement: # DEBUG i => i_52

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining statement: # DEBUG i => i_52

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining statement: ivtmp_118 = ivtmp_119 - 1;

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: ==> examining statement: if (ivtmp_118 != 0)

pa2-p2.c:42: note: skip.
pa2-p2.c:42: note: vectorization factor = 4
pa2-p2.c:42: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:42: note: vect_compute_data_ref_alignment:
pa2-p2.c:42: note: inner step divides the vector-size.
pa2-p2.c:42: note: misalign = 0 bytes of ref c[j_132][i_127]
pa2-p2.c:42: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:42: note: === vect_prune_runtime_alias_test_list ===
pa2-p2.c:42: note: === vect_enhance_data_refs_alignment ===
pa2-p2.c:42: note: vect_can_advance_ivs_p:
pa2-p2.c:42: note: Analyze phi: .MEM_101 = PHI <.MEM_46(10), .MEM_50(16)>

pa2-p2.c:42: note: virtual phi. skip.
pa2-p2.c:42: note: Analyze phi: i_127 = PHI <0(10), i_52(16)>

pa2-p2.c:42: note: Access function of PHI: {0, +, 1}_3
pa2-p2.c:42: note: Analyze phi: ivtmp_119 = PHI <2000(10), ivtmp_118(16)>

pa2-p2.c:42: note: Access function of PHI: {2000, +, 4294967295}_3
pa2-p2.c:42: note: === vect_analyze_slp ===
pa2-p2.c:42: note: === vect_make_slp_decision ===
pa2-p2.c:42: note: === vect_detect_hybrid_slp ===
pa2-p2.c:42: note: === vect_analyze_loop_operations ===
pa2-p2.c:42: note: examining phi: .MEM_101 = PHI <.MEM_46(10), .MEM_50(16)>

pa2-p2.c:42: note: examining phi: i_127 = PHI <0(10), i_52(16)>

pa2-p2.c:42: note: examining phi: ivtmp_119 = PHI <2000(10), ivtmp_118(16)>

pa2-p2.c:42: note: ==> examining statement: # DEBUG i => i_127

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: ==> examining statement: # DEBUG j => 0

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: examining phi: j_132 = PHI <j_51(13), 0(17)>

pa2-p2.c:42: note: examining phi: .MEM_138 = PHI <.MEM_50(13), .MEM_101(17)>

pa2-p2.c:42: note: examining phi: ivtmp_121 = PHI <ivtmp_120(13), 2000(17)>

pa2-p2.c:42: note: ==> examining statement: # DEBUG j => j_132

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: ==> examining statement: c[j_132][i_127] = 0.0;

pa2-p2.c:42: note: vect_is_simple_use: operand 0.0
pa2-p2.c:42: note: vect_model_store_cost: aligned.
pa2-p2.c:42: note: vect_model_store_cost: inside_cost = 50, prologue_cost = 1 .
pa2-p2.c:42: note: ==> examining statement: j_51 = j_132 + 1;

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: ==> examining statement: # DEBUG j => j_51

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: ==> examining statement: # DEBUG j => j_51

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: ==> examining statement: ivtmp_120 = ivtmp_121 - 1;

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: ==> examining statement: if (ivtmp_120 != 0)

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: ==> examining statement: i_52 = i_127 + 1;

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: ==> examining statement: # DEBUG i => i_52

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: ==> examining statement: # DEBUG i => i_52

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: ==> examining statement: ivtmp_118 = ivtmp_119 - 1;

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: ==> examining statement: if (ivtmp_118 != 0)

pa2-p2.c:42: note: irrelevant.
pa2-p2.c:42: note: vectorization_factor = 4, niters = 2000
pa2-p2.c:42: note: === vect_update_slp_costs_according_to_vf ===
pa2-p2.c:42: note: Cost model analysis: 
  Vector inside of loop cost: 50
  Vector prologue cost: 1
  Vector epilogue cost: 0
  Scalar iteration cost: 50
  Scalar outside cost: 0
  Vector outside cost: 1
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

pa2-p2.c:42: note:   Runtime profitability threshold = 3

pa2-p2.c:42: note:   Static estimate profitability threshold = 3


Vectorizing loop at pa2-p2.c:42

pa2-p2.c:42: note: === vec_transform_loop ===
pa2-p2.c:42: note: ------>vectorizing phi: .MEM_101 = PHI <.MEM_46(42), .MEM_50(16)>

pa2-p2.c:42: note: ------>vectorizing phi: i_127 = PHI <0(42), i_52(16)>

pa2-p2.c:42: note: ------>vectorizing phi: ivtmp_119 = PHI <2000(42), ivtmp_118(16)>

pa2-p2.c:42: note: ------>vectorizing statement: # DEBUG i => i_127

pa2-p2.c:42: note: ------>vectorizing statement: # DEBUG j => 0

pa2-p2.c:42: note: ------>vectorizing phi: j_132 = PHI <j_51(13), 0(17)>

pa2-p2.c:42: note: ------>vectorizing phi: .MEM_138 = PHI <.MEM_50(13), .MEM_101(17)>

pa2-p2.c:42: note: ------>vectorizing phi: ivtmp_121 = PHI <ivtmp_120(13), 2000(17)>

pa2-p2.c:42: note: ------>vectorizing statement: # DEBUG j => j_132

pa2-p2.c:42: note: ------>vectorizing statement: c[j_132][i_127] = 0.0;

pa2-p2.c:42: note: transform statement.
pa2-p2.c:42: note: vect_is_simple_use: operand 0.0
pa2-p2.c:42: note: transform store. ncopies = 1
pa2-p2.c:42: note: vect_get_vec_def_for_operand: 0.0
pa2-p2.c:42: note: vect_is_simple_use: operand 0.0
pa2-p2.c:42: note: get vectype with 4 units of type float
pa2-p2.c:42: note: vectype: vector(4) float
pa2-p2.c:42: note: Create vector_cst. nunits = 4
pa2-p2.c:42: note: created new init_stmt: vect_cst_.269_8 = { 0.0, 0.0, 0.0, 0.0 };

pa2-p2.c:42: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p2.c:42: note: created vect_pc.273_7
pa2-p2.c:42: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.270_4] = vect_cst_.269_8;

pa2-p2.c:42: note: ------>vectorizing statement: j_51 = j_132 + 1;

pa2-p2.c:42: note: ------>vectorizing statement: # DEBUG j => j_51

pa2-p2.c:42: note: ------>vectorizing statement: # DEBUG j => j_51

pa2-p2.c:42: note: ------>vectorizing statement: ivtmp_120 = ivtmp_121 - 1;

pa2-p2.c:42: note: ------>vectorizing statement: vect_pc.270_3 = vect_pc.270_4 + 8000;

pa2-p2.c:42: note: ------>vectorizing statement: if (ivtmp_120 != 0)

pa2-p2.c:42: note: ------>vectorizing statement: i_52 = i_127 + 1;

pa2-p2.c:42: note: ------>vectorizing statement: # DEBUG i => i_52

pa2-p2.c:42: note: ------>vectorizing statement: # DEBUG i => i_52

pa2-p2.c:42: note: ------>vectorizing statement: ivtmp_118 = ivtmp_119 - 1;

pa2-p2.c:42: note: ------>vectorizing statement: vect_pc.270_5 = vect_pc.270_6 + 16;

pa2-p2.c:42: note: ------>vectorizing statement: if (ivtmp_118 != 0)
if (ivtmp_1 < 500)

pa2-p2.c:42: note: LOOP VECTORIZED.
pa2-p2.c:42: note: OUTER LOOP VECTORIZED.
Analyzing loop at pa2-p2.c:42

pa2-p2.c:42: note: ===== analyze_loop_nest =====
pa2-p2.c:42: note: outer-loop already vectorized.
Analyzing loop at pa2-p2.c:36

pa2-p2.c:36: note: ===== analyze_loop_nest =====
pa2-p2.c:36: note: === vect_analyze_loop_form ===
pa2-p2.c:36: note: ===== analyze_loop_nest_1 =====
pa2-p2.c:36: note: === vect_analyze_loop_form ===
pa2-p2.c:36: note: === get_loop_niters ===
pa2-p2.c:36: note: ==> get_loop_niters:2000
pa2-p2.c:36: note: Considering outer-loop vectorization.
pa2-p2.c:36: note: === get_loop_niters ===
pa2-p2.c:36: note: ==> get_loop_niters:2000
pa2-p2.c:36: note: === vect_analyze_data_refs ===

pa2-p2.c:36: note: analyze in outer-loop: a
pa2-p2.c:36: note: 	outer base_address: &a
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 8000
	outer aligned to: 128
pa2-p2.c:36: note: get vectype with 4 units of type float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: analyze in outer-loop: b
pa2-p2.c:36: note: 	outer base_address: &b
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 8000
	outer aligned to: 128
pa2-p2.c:36: note: get vectype with 4 units of type float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:36: note: Analyze phi: .MEM_103 = PHI <.MEM_33(6), .MEM_46(11)>

pa2-p2.c:36: note: Analyze phi: i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:36: note: Access function of PHI: {0, +, 1}_1
pa2-p2.c:36: note: step: 1,  init: 0
pa2-p2.c:36: note: Detected induction.
pa2-p2.c:36: note: Analyze phi: ivtmp_115 = PHI <2000(6), ivtmp_114(11)>

pa2-p2.c:36: note: Access function of PHI: {2000, +, 4294967295}_1
pa2-p2.c:36: note: step: 4294967295,  init: 2000
pa2-p2.c:36: note: Detected induction.
pa2-p2.c:36: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:36: note: Analyze phi: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:36: note: Access function of PHI: {0, +, 1}_2
pa2-p2.c:36: note: step: 1,  init: 0
pa2-p2.c:36: note: Detected induction.
pa2-p2.c:36: note: Analyze phi: .MEM_137 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p2.c:36: note: Analyze phi: ivtmp_117 = PHI <ivtmp_116(7), 2000(12)>

pa2-p2.c:36: note: Access function of PHI: {2000, +, 4294967295}_2
pa2-p2.c:36: note: step: 4294967295,  init: 2000
pa2-p2.c:36: note: Detected induction.
pa2-p2.c:36: note: === vect_pattern_recog ===
pa2-p2.c:36: note: vect_is_simple_use: operand i_126
pa2-p2.c:36: note: def_stmt: i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:36: note: type of def: 4.
pa2-p2.c:36: note: vect_is_simple_use: operand _37
pa2-p2.c:36: note: def_stmt: _37 = (double) _36;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: vect_is_simple_use: operand j_131
pa2-p2.c:36: note: def_stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:36: note: type of def: 4.
pa2-p2.c:36: note: vect_is_simple_use: operand _43
pa2-p2.c:36: note: def_stmt: _43 = (double) _42;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p2.c:36: note: init: phi relevant? .MEM_103 = PHI <.MEM_33(6), .MEM_46(11)>

pa2-p2.c:36: note: init: phi relevant? i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:36: note: init: phi relevant? ivtmp_115 = PHI <2000(6), ivtmp_114(11)>

pa2-p2.c:36: note: init: stmt relevant? # DEBUG i => i_126

pa2-p2.c:36: note: init: stmt relevant? # DEBUG j => 0

pa2-p2.c:36: note: init: stmt relevant? pretmp_28 = i_126 * 2;

pa2-p2.c:36: note: init: phi relevant? j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:36: note: init: phi relevant? .MEM_137 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p2.c:36: note: init: phi relevant? ivtmp_117 = PHI <ivtmp_116(7), 2000(12)>

pa2-p2.c:36: note: init: stmt relevant? # DEBUG j => j_131

pa2-p2.c:36: note: init: stmt relevant? _36 = pretmp_28 + j_131;

pa2-p2.c:36: note: init: stmt relevant? _37 = (double) _36;

pa2-p2.c:36: note: init: stmt relevant? _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:36: note: init: stmt relevant? _39 = (float) _38;

pa2-p2.c:36: note: init: stmt relevant? a[i_126][j_131] = _39;

pa2-p2.c:36: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: init: stmt relevant? _41 = j_131 * 2;

pa2-p2.c:36: note: init: stmt relevant? _42 = _41 + i_126;

pa2-p2.c:36: note: init: stmt relevant? _43 = (double) _42;

pa2-p2.c:36: note: init: stmt relevant? _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:36: note: init: stmt relevant? _45 = (float) _44;

pa2-p2.c:36: note: init: stmt relevant? b[i_126][j_131] = _45;

pa2-p2.c:36: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: init: stmt relevant? j_47 = j_131 + 1;

pa2-p2.c:36: note: init: stmt relevant? # DEBUG j => j_47

pa2-p2.c:36: note: init: stmt relevant? # DEBUG j => j_47

pa2-p2.c:36: note: init: stmt relevant? ivtmp_116 = ivtmp_117 - 1;

pa2-p2.c:36: note: init: stmt relevant? if (ivtmp_116 != 0)

pa2-p2.c:36: note: init: stmt relevant? i_48 = i_126 + 1;

pa2-p2.c:36: note: init: stmt relevant? # DEBUG i => i_48

pa2-p2.c:36: note: init: stmt relevant? # DEBUG i => i_48

pa2-p2.c:36: note: init: stmt relevant? ivtmp_114 = ivtmp_115 - 1;

pa2-p2.c:36: note: init: stmt relevant? if (ivtmp_114 != 0)

pa2-p2.c:36: note: worklist: examine stmt: b[i_126][j_131] = _45;

pa2-p2.c:36: note: vect_is_simple_use: operand _45
pa2-p2.c:36: note: def_stmt: _45 = (float) _44;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: worklist: examine stmt: _45 = (float) _44;

pa2-p2.c:36: note: vect_is_simple_use: operand _44
pa2-p2.c:36: note: def_stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: worklist: examine stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:36: note: vect_is_simple_use: operand _43
pa2-p2.c:36: note: def_stmt: _43 = (double) _42;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: worklist: examine stmt: _43 = (double) _42;

pa2-p2.c:36: note: vect_is_simple_use: operand _42
pa2-p2.c:36: note: def_stmt: _42 = _41 + i_126;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: worklist: examine stmt: _42 = _41 + i_126;

pa2-p2.c:36: note: vect_is_simple_use: operand _41
pa2-p2.c:36: note: def_stmt: _41 = j_131 * 2;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: vect_is_simple_use: operand i_126
pa2-p2.c:36: note: def_stmt: i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:36: note: type of def: 4.
pa2-p2.c:36: note: outer-loop def-stmt defining inner-loop stmt.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: worklist: examine stmt: i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:36: note: vect_is_simple_use: operand 0
pa2-p2.c:36: note: vect_is_simple_use: operand i_48
pa2-p2.c:36: note: def_stmt: i_48 = i_126 + 1;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: worklist: examine stmt: i_48 = i_126 + 1;

pa2-p2.c:36: note: vect_is_simple_use: operand i_126
pa2-p2.c:36: note: def_stmt: i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:36: note: type of def: 4.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: already marked relevant/live.
pa2-p2.c:36: note: worklist: examine stmt: _41 = j_131 * 2;

pa2-p2.c:36: note: vect_is_simple_use: operand j_131
pa2-p2.c:36: note: def_stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:36: note: type of def: 4.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: worklist: examine stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:36: note: vect_is_simple_use: operand j_47
pa2-p2.c:36: note: def_stmt: j_47 = j_131 + 1;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: vect_is_simple_use: operand 0
pa2-p2.c:36: note: worklist: examine stmt: j_47 = j_131 + 1;

pa2-p2.c:36: note: vect_is_simple_use: operand j_131
pa2-p2.c:36: note: def_stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:36: note: type of def: 4.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: already marked relevant/live.
pa2-p2.c:36: note: worklist: examine stmt: a[i_126][j_131] = _39;

pa2-p2.c:36: note: vect_is_simple_use: operand _39
pa2-p2.c:36: note: def_stmt: _39 = (float) _38;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: worklist: examine stmt: _39 = (float) _38;

pa2-p2.c:36: note: vect_is_simple_use: operand _38
pa2-p2.c:36: note: def_stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: worklist: examine stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:36: note: vect_is_simple_use: operand _37
pa2-p2.c:36: note: def_stmt: _37 = (double) _36;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: worklist: examine stmt: _37 = (double) _36;

pa2-p2.c:36: note: vect_is_simple_use: operand _36
pa2-p2.c:36: note: def_stmt: _36 = pretmp_28 + j_131;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: worklist: examine stmt: _36 = pretmp_28 + j_131;

pa2-p2.c:36: note: vect_is_simple_use: operand pretmp_28
pa2-p2.c:36: note: def_stmt: pretmp_28 = i_126 * 2;

pa2-p2.c:36: note: type of def: 3.
pa2-p2.c:36: note: outer-loop def-stmt defining inner-loop stmt.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: vect_is_simple_use: operand j_131
pa2-p2.c:36: note: def_stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:36: note: type of def: 4.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: already marked relevant/live.
pa2-p2.c:36: note: worklist: examine stmt: pretmp_28 = i_126 * 2;

pa2-p2.c:36: note: vect_is_simple_use: operand i_126
pa2-p2.c:36: note: def_stmt: i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:36: note: type of def: 4.
pa2-p2.c:36: note: mark relevant 4, live 0.
pa2-p2.c:36: note: already marked relevant/live.
pa2-p2.c:36: note: === vect_analyze_dependences ===
pa2-p2.c:36: note: === vect_determine_vectorization_factor ===
pa2-p2.c:36: note: ==> examining phi: .MEM_103 = PHI <.MEM_33(6), .MEM_46(11)>

pa2-p2.c:36: note: ==> examining phi: i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining phi: ivtmp_115 = PHI <2000(6), ivtmp_114(11)>

pa2-p2.c:36: note: ==> examining statement: # DEBUG i => i_126

pa2-p2.c:36: note: skip.
pa2-p2.c:36: note: ==> examining statement: # DEBUG j => 0

pa2-p2.c:36: note: skip.
pa2-p2.c:36: note: ==> examining statement: pretmp_28 = i_126 * 2;

pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining phi: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining phi: .MEM_137 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p2.c:36: note: ==> examining phi: ivtmp_117 = PHI <ivtmp_116(7), 2000(12)>

pa2-p2.c:36: note: ==> examining statement: # DEBUG j => j_131

pa2-p2.c:36: note: skip.
pa2-p2.c:36: note: ==> examining statement: _36 = pretmp_28 + j_131;

pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining statement: _37 = (double) _36;

pa2-p2.c:36: note: get vectype for scalar type:  double
pa2-p2.c:36: note: get vectype with 2 units of type double
pa2-p2.c:36: note: vectype: vector(2) double
pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining statement: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:36: note: get vectype for scalar type:  double
pa2-p2.c:36: note: get vectype with 2 units of type double
pa2-p2.c:36: note: vectype: vector(2) double
pa2-p2.c:36: note: get vectype for scalar type:  double
pa2-p2.c:36: note: get vectype with 2 units of type double
pa2-p2.c:36: note: vectype: vector(2) double
pa2-p2.c:36: note: vectype: vector(2) double
pa2-p2.c:36: note: nunits = 2
pa2-p2.c:36: note: ==> examining statement: _39 = (float) _38;

pa2-p2.c:36: note: get vectype for scalar type:  float
pa2-p2.c:36: note: get vectype with 4 units of type float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: get vectype for scalar type:  float
pa2-p2.c:36: note: get vectype with 4 units of type float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining statement: a[i_126][j_131] = _39;

pa2-p2.c:36: note: get vectype for scalar type:  float
pa2-p2.c:36: note: get vectype with 4 units of type float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining statement: _41 = j_131 * 2;

pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining statement: _42 = _41 + i_126;

pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining statement: _43 = (double) _42;

pa2-p2.c:36: note: get vectype for scalar type:  double
pa2-p2.c:36: note: get vectype with 2 units of type double
pa2-p2.c:36: note: vectype: vector(2) double
pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining statement: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:36: note: get vectype for scalar type:  double
pa2-p2.c:36: note: get vectype with 2 units of type double
pa2-p2.c:36: note: vectype: vector(2) double
pa2-p2.c:36: note: get vectype for scalar type:  double
pa2-p2.c:36: note: get vectype with 2 units of type double
pa2-p2.c:36: note: vectype: vector(2) double
pa2-p2.c:36: note: vectype: vector(2) double
pa2-p2.c:36: note: nunits = 2
pa2-p2.c:36: note: ==> examining statement: _45 = (float) _44;

pa2-p2.c:36: note: get vectype for scalar type:  float
pa2-p2.c:36: note: get vectype with 4 units of type float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: get vectype for scalar type:  float
pa2-p2.c:36: note: get vectype with 4 units of type float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining statement: b[i_126][j_131] = _45;

pa2-p2.c:36: note: get vectype for scalar type:  float
pa2-p2.c:36: note: get vectype with 4 units of type float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: vectype: vector(4) float
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining statement: j_47 = j_131 + 1;

pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining statement: # DEBUG j => j_47

pa2-p2.c:36: note: skip.
pa2-p2.c:36: note: ==> examining statement: # DEBUG j => j_47

pa2-p2.c:36: note: skip.
pa2-p2.c:36: note: ==> examining statement: ivtmp_116 = ivtmp_117 - 1;

pa2-p2.c:36: note: skip.
pa2-p2.c:36: note: ==> examining statement: if (ivtmp_116 != 0)

pa2-p2.c:36: note: skip.
pa2-p2.c:36: note: ==> examining statement: i_48 = i_126 + 1;

pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: get vectype for scalar type:  int
pa2-p2.c:36: note: get vectype with 4 units of type int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: vectype: vector(4) int
pa2-p2.c:36: note: nunits = 4
pa2-p2.c:36: note: ==> examining statement: # DEBUG i => i_48

pa2-p2.c:36: note: skip.
pa2-p2.c:36: note: ==> examining statement: # DEBUG i => i_48

pa2-p2.c:36: note: skip.
pa2-p2.c:36: note: ==> examining statement: ivtmp_114 = ivtmp_115 - 1;

pa2-p2.c:36: note: skip.
pa2-p2.c:36: note: ==> examining statement: if (ivtmp_114 != 0)

pa2-p2.c:36: note: skip.
pa2-p2.c:36: note: vectorization factor = 4
pa2-p2.c:36: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:36: note: vect_compute_data_ref_alignment:
pa2-p2.c:36: note: inner step doesn't divide the vector-size.
pa2-p2.c:36: note: Unknown alignment for access: a
pa2-p2.c:36: note: vect_compute_data_ref_alignment:
pa2-p2.c:36: note: inner step doesn't divide the vector-size.
pa2-p2.c:36: note: Unknown alignment for access: b
pa2-p2.c:36: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:36: note: grouped access in outer loop.
pa2-p2.c:36: note: not vectorized: complicated access pattern.
pa2-p2.c:36: note: bad data access.
Analyzing loop at pa2-p2.c:37

pa2-p2.c:37: note: ===== analyze_loop_nest =====
pa2-p2.c:37: note: === vect_analyze_loop_form ===
pa2-p2.c:37: note: === get_loop_niters ===
pa2-p2.c:37: note: ==> get_loop_niters:2000
pa2-p2.c:37: note: === vect_analyze_data_refs ===

pa2-p2.c:37: note: get vectype with 4 units of type float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: get vectype with 4 units of type float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: === vect_analyze_scalar_cycles ===
pa2-p2.c:37: note: Analyze phi: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: Access function of PHI: {0, +, 1}_2
pa2-p2.c:37: note: step: 1,  init: 0
pa2-p2.c:37: note: Detected induction.
pa2-p2.c:37: note: Analyze phi: .MEM_137 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p2.c:37: note: Analyze phi: ivtmp_117 = PHI <ivtmp_116(7), 2000(12)>

pa2-p2.c:37: note: Access function of PHI: {2000, +, 4294967295}_2
pa2-p2.c:37: note: step: 4294967295,  init: 2000
pa2-p2.c:37: note: Detected induction.
pa2-p2.c:37: note: === vect_pattern_recog ===
pa2-p2.c:37: note: vect_is_simple_use: operand _37
pa2-p2.c:37: note: def_stmt: _37 = (double) _36;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: vect_is_simple_use: operand _43
pa2-p2.c:37: note: def_stmt: _43 = (double) _42;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p2.c:37: note: init: phi relevant? j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: init: phi relevant? .MEM_137 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p2.c:37: note: init: phi relevant? ivtmp_117 = PHI <ivtmp_116(7), 2000(12)>

pa2-p2.c:37: note: init: stmt relevant? # DEBUG j => j_131

pa2-p2.c:37: note: init: stmt relevant? _36 = pretmp_28 + j_131;

pa2-p2.c:37: note: init: stmt relevant? _37 = (double) _36;

pa2-p2.c:37: note: init: stmt relevant? _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:37: note: init: stmt relevant? _39 = (float) _38;

pa2-p2.c:37: note: init: stmt relevant? a[i_126][j_131] = _39;

pa2-p2.c:37: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: init: stmt relevant? _41 = j_131 * 2;

pa2-p2.c:37: note: init: stmt relevant? _42 = _41 + i_126;

pa2-p2.c:37: note: init: stmt relevant? _43 = (double) _42;

pa2-p2.c:37: note: init: stmt relevant? _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:37: note: init: stmt relevant? _45 = (float) _44;

pa2-p2.c:37: note: init: stmt relevant? b[i_126][j_131] = _45;

pa2-p2.c:37: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: init: stmt relevant? j_47 = j_131 + 1;

pa2-p2.c:37: note: init: stmt relevant? # DEBUG j => j_47

pa2-p2.c:37: note: init: stmt relevant? # DEBUG j => j_47

pa2-p2.c:37: note: init: stmt relevant? ivtmp_116 = ivtmp_117 - 1;

pa2-p2.c:37: note: init: stmt relevant? if (ivtmp_116 != 0)

pa2-p2.c:37: note: worklist: examine stmt: b[i_126][j_131] = _45;

pa2-p2.c:37: note: vect_is_simple_use: operand _45
pa2-p2.c:37: note: def_stmt: _45 = (float) _44;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: worklist: examine stmt: _45 = (float) _44;

pa2-p2.c:37: note: vect_is_simple_use: operand _44
pa2-p2.c:37: note: def_stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: worklist: examine stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:37: note: vect_is_simple_use: operand _43
pa2-p2.c:37: note: def_stmt: _43 = (double) _42;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: worklist: examine stmt: _43 = (double) _42;

pa2-p2.c:37: note: vect_is_simple_use: operand _42
pa2-p2.c:37: note: def_stmt: _42 = _41 + i_126;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: worklist: examine stmt: _42 = _41 + i_126;

pa2-p2.c:37: note: vect_is_simple_use: operand _41
pa2-p2.c:37: note: def_stmt: _41 = j_131 * 2;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: vect_is_simple_use: operand i_126
pa2-p2.c:37: note: def_stmt: i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:37: note: type of def: 2.
pa2-p2.c:37: note: def_stmt is out of loop.
pa2-p2.c:37: note: worklist: examine stmt: _41 = j_131 * 2;

pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: worklist: examine stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: vect_is_simple_use: operand j_47
pa2-p2.c:37: note: def_stmt: j_47 = j_131 + 1;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: vect_is_simple_use: operand 0
pa2-p2.c:37: note: worklist: examine stmt: j_47 = j_131 + 1;

pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: already marked relevant/live.
pa2-p2.c:37: note: worklist: examine stmt: a[i_126][j_131] = _39;

pa2-p2.c:37: note: vect_is_simple_use: operand _39
pa2-p2.c:37: note: def_stmt: _39 = (float) _38;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: worklist: examine stmt: _39 = (float) _38;

pa2-p2.c:37: note: vect_is_simple_use: operand _38
pa2-p2.c:37: note: def_stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: worklist: examine stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:37: note: vect_is_simple_use: operand _37
pa2-p2.c:37: note: def_stmt: _37 = (double) _36;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: worklist: examine stmt: _37 = (double) _36;

pa2-p2.c:37: note: vect_is_simple_use: operand _36
pa2-p2.c:37: note: def_stmt: _36 = pretmp_28 + j_131;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: worklist: examine stmt: _36 = pretmp_28 + j_131;

pa2-p2.c:37: note: vect_is_simple_use: operand pretmp_28
pa2-p2.c:37: note: def_stmt: pretmp_28 = i_126 * 2;

pa2-p2.c:37: note: type of def: 2.
pa2-p2.c:37: note: def_stmt is out of loop.
pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: mark relevant 4, live 0.
pa2-p2.c:37: note: already marked relevant/live.
pa2-p2.c:37: note: === vect_analyze_dependences ===
pa2-p2.c:37: note: === vect_determine_vectorization_factor ===
pa2-p2.c:37: note: ==> examining phi: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: get vectype for scalar type:  int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: nunits = 4
pa2-p2.c:37: note: ==> examining phi: .MEM_137 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p2.c:37: note: ==> examining phi: ivtmp_117 = PHI <ivtmp_116(7), 2000(12)>

pa2-p2.c:37: note: ==> examining statement: # DEBUG j => j_131

pa2-p2.c:37: note: skip.
pa2-p2.c:37: note: ==> examining statement: _36 = pretmp_28 + j_131;

pa2-p2.c:37: note: get vectype for scalar type:  int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: get vectype for scalar type:  int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: nunits = 4
pa2-p2.c:37: note: ==> examining statement: _37 = (double) _36;

pa2-p2.c:37: note: get vectype for scalar type:  double
pa2-p2.c:37: note: get vectype with 2 units of type double
pa2-p2.c:37: note: vectype: vector(2) double
pa2-p2.c:37: note: get vectype for scalar type:  int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: nunits = 4
pa2-p2.c:37: note: ==> examining statement: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:37: note: get vectype for scalar type:  double
pa2-p2.c:37: note: get vectype with 2 units of type double
pa2-p2.c:37: note: vectype: vector(2) double
pa2-p2.c:37: note: get vectype for scalar type:  double
pa2-p2.c:37: note: get vectype with 2 units of type double
pa2-p2.c:37: note: vectype: vector(2) double
pa2-p2.c:37: note: vectype: vector(2) double
pa2-p2.c:37: note: nunits = 2
pa2-p2.c:37: note: ==> examining statement: _39 = (float) _38;

pa2-p2.c:37: note: get vectype for scalar type:  float
pa2-p2.c:37: note: get vectype with 4 units of type float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: get vectype for scalar type:  float
pa2-p2.c:37: note: get vectype with 4 units of type float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: nunits = 4
pa2-p2.c:37: note: ==> examining statement: a[i_126][j_131] = _39;

pa2-p2.c:37: note: get vectype for scalar type:  float
pa2-p2.c:37: note: get vectype with 4 units of type float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: nunits = 4
pa2-p2.c:37: note: ==> examining statement: _41 = j_131 * 2;

pa2-p2.c:37: note: get vectype for scalar type:  int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: get vectype for scalar type:  int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: nunits = 4
pa2-p2.c:37: note: ==> examining statement: _42 = _41 + i_126;

pa2-p2.c:37: note: get vectype for scalar type:  int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: get vectype for scalar type:  int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: nunits = 4
pa2-p2.c:37: note: ==> examining statement: _43 = (double) _42;

pa2-p2.c:37: note: get vectype for scalar type:  double
pa2-p2.c:37: note: get vectype with 2 units of type double
pa2-p2.c:37: note: vectype: vector(2) double
pa2-p2.c:37: note: get vectype for scalar type:  int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: nunits = 4
pa2-p2.c:37: note: ==> examining statement: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:37: note: get vectype for scalar type:  double
pa2-p2.c:37: note: get vectype with 2 units of type double
pa2-p2.c:37: note: vectype: vector(2) double
pa2-p2.c:37: note: get vectype for scalar type:  double
pa2-p2.c:37: note: get vectype with 2 units of type double
pa2-p2.c:37: note: vectype: vector(2) double
pa2-p2.c:37: note: vectype: vector(2) double
pa2-p2.c:37: note: nunits = 2
pa2-p2.c:37: note: ==> examining statement: _45 = (float) _44;

pa2-p2.c:37: note: get vectype for scalar type:  float
pa2-p2.c:37: note: get vectype with 4 units of type float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: get vectype for scalar type:  float
pa2-p2.c:37: note: get vectype with 4 units of type float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: nunits = 4
pa2-p2.c:37: note: ==> examining statement: b[i_126][j_131] = _45;

pa2-p2.c:37: note: get vectype for scalar type:  float
pa2-p2.c:37: note: get vectype with 4 units of type float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: vectype: vector(4) float
pa2-p2.c:37: note: nunits = 4
pa2-p2.c:37: note: ==> examining statement: j_47 = j_131 + 1;

pa2-p2.c:37: note: get vectype for scalar type:  int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: get vectype for scalar type:  int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: nunits = 4
pa2-p2.c:37: note: ==> examining statement: # DEBUG j => j_47

pa2-p2.c:37: note: skip.
pa2-p2.c:37: note: ==> examining statement: # DEBUG j => j_47

pa2-p2.c:37: note: skip.
pa2-p2.c:37: note: ==> examining statement: ivtmp_116 = ivtmp_117 - 1;

pa2-p2.c:37: note: skip.
pa2-p2.c:37: note: ==> examining statement: if (ivtmp_116 != 0)

pa2-p2.c:37: note: skip.
pa2-p2.c:37: note: vectorization factor = 4
pa2-p2.c:37: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:37: note: vect_compute_data_ref_alignment:
pa2-p2.c:37: note: misalign = 0 bytes of ref a[i_126][j_131]
pa2-p2.c:37: note: vect_compute_data_ref_alignment:
pa2-p2.c:37: note: misalign = 0 bytes of ref b[i_126][j_131]
pa2-p2.c:37: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:37: note: === vect_prune_runtime_alias_test_list ===
pa2-p2.c:37: note: === vect_enhance_data_refs_alignment ===
pa2-p2.c:37: note: vect_can_advance_ivs_p:
pa2-p2.c:37: note: Analyze phi: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: Access function of PHI: {0, +, 1}_2
pa2-p2.c:37: note: Analyze phi: .MEM_137 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p2.c:37: note: virtual phi. skip.
pa2-p2.c:37: note: Analyze phi: ivtmp_117 = PHI <ivtmp_116(7), 2000(12)>

pa2-p2.c:37: note: Access function of PHI: {2000, +, 4294967295}_2
pa2-p2.c:37: note: vect_model_store_cost: aligned.
pa2-p2.c:37: note: vect_get_data_access_cost: inside_cost = 1, outside_cost = 0.
pa2-p2.c:37: note: vect_model_store_cost: aligned.
pa2-p2.c:37: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
pa2-p2.c:37: note: === vect_analyze_slp ===
pa2-p2.c:37: note: === vect_make_slp_decision ===
pa2-p2.c:37: note: === vect_detect_hybrid_slp ===
pa2-p2.c:37: note: === vect_analyze_loop_operations ===
pa2-p2.c:37: note: examining phi: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: === vectorizable_induction ===
pa2-p2.c:37: note: vect_model_induction_cost: inside_cost = 1, prologue_cost = 2 .
pa2-p2.c:37: note: examining phi: .MEM_137 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p2.c:37: note: examining phi: ivtmp_117 = PHI <ivtmp_116(7), 2000(12)>

pa2-p2.c:37: note: ==> examining statement: # DEBUG j => j_131

pa2-p2.c:37: note: irrelevant.
pa2-p2.c:37: note: ==> examining statement: _36 = pretmp_28 + j_131;

pa2-p2.c:37: note: vect_is_simple_use: operand pretmp_28
pa2-p2.c:37: note: def_stmt: pretmp_28 = i_126 * 2;

pa2-p2.c:37: note: type of def: 2.
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: === vectorizable_operation ===
pa2-p2.c:37: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p2.c:37: note: ==> examining statement: _37 = (double) _36;

pa2-p2.c:37: note: vect_is_simple_use: operand _36
pa2-p2.c:37: note: def_stmt: _36 = pretmp_28 + j_131;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: === vectorizable_conversion ===
pa2-p2.c:37: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:37: note: ==> examining statement: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:37: note: vect_is_simple_use: operand _37
pa2-p2.c:37: note: def_stmt: _37 = (double) _36;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: vect_is_simple_use: operand 1.100000000000000088817841970012523233890533447265625e+0
pa2-p2.c:37: note: === vectorizable_operation ===
pa2-p2.c:37: note: vect_model_simple_cost: inside_cost = 2, prologue_cost = 1 .
pa2-p2.c:37: note: ==> examining statement: _39 = (float) _38;

pa2-p2.c:37: note: vect_is_simple_use: operand _38
pa2-p2.c:37: note: def_stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: === vectorizable_conversion ===
pa2-p2.c:37: note: vect_model_promotion_demotion_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:37: note: ==> examining statement: a[i_126][j_131] = _39;

pa2-p2.c:37: note: vect_is_simple_use: operand _39
pa2-p2.c:37: note: def_stmt: _39 = (float) _38;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: vect_model_store_cost: aligned.
pa2-p2.c:37: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:37: note: ==> examining statement: _41 = j_131 * 2;

pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: vect_is_simple_use: operand 2
pa2-p2.c:37: note: === vectorizable_operation ===
pa2-p2.c:37: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p2.c:37: note: ==> examining statement: _42 = _41 + i_126;

pa2-p2.c:37: note: vect_is_simple_use: operand _41
pa2-p2.c:37: note: def_stmt: _41 = j_131 * 2;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: vect_is_simple_use: operand i_126
pa2-p2.c:37: note: def_stmt: i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:37: note: type of def: 2.
pa2-p2.c:37: note: === vectorizable_operation ===
pa2-p2.c:37: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p2.c:37: note: ==> examining statement: _43 = (double) _42;

pa2-p2.c:37: note: vect_is_simple_use: operand _42
pa2-p2.c:37: note: def_stmt: _42 = _41 + i_126;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: === vectorizable_conversion ===
pa2-p2.c:37: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:37: note: ==> examining statement: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:37: note: vect_is_simple_use: operand _43
pa2-p2.c:37: note: def_stmt: _43 = (double) _42;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: vect_is_simple_use: operand 1.1999999999999999555910790149937383830547332763671875e+0
pa2-p2.c:37: note: === vectorizable_operation ===
pa2-p2.c:37: note: vect_model_simple_cost: inside_cost = 2, prologue_cost = 1 .
pa2-p2.c:37: note: ==> examining statement: _45 = (float) _44;

pa2-p2.c:37: note: vect_is_simple_use: operand _44
pa2-p2.c:37: note: def_stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: === vectorizable_conversion ===
pa2-p2.c:37: note: vect_model_promotion_demotion_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:37: note: ==> examining statement: b[i_126][j_131] = _45;

pa2-p2.c:37: note: vect_is_simple_use: operand _45
pa2-p2.c:37: note: def_stmt: _45 = (float) _44;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: vect_model_store_cost: aligned.
pa2-p2.c:37: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p2.c:37: note: ==> examining statement: j_47 = j_131 + 1;

pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(12)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: vect_is_simple_use: operand 1
pa2-p2.c:37: note: === vectorizable_operation ===
pa2-p2.c:37: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p2.c:37: note: ==> examining statement: # DEBUG j => j_47

pa2-p2.c:37: note: irrelevant.
pa2-p2.c:37: note: ==> examining statement: # DEBUG j => j_47

pa2-p2.c:37: note: irrelevant.
pa2-p2.c:37: note: ==> examining statement: ivtmp_116 = ivtmp_117 - 1;

pa2-p2.c:37: note: irrelevant.
pa2-p2.c:37: note: ==> examining statement: if (ivtmp_116 != 0)

pa2-p2.c:37: note: irrelevant.
pa2-p2.c:37: note: vectorization_factor = 4, niters = 2000
pa2-p2.c:37: note: === vect_update_slp_costs_according_to_vf ===
pa2-p2.c:37: note: Cost model analysis: 
  Vector inside of loop cost: 15
  Vector prologue cost: 8
  Vector epilogue cost: 0
  Scalar iteration cost: 12
  Scalar outside cost: 0
  Vector outside cost: 8
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

pa2-p2.c:37: note:   Runtime profitability threshold = 3

pa2-p2.c:37: note:   Static estimate profitability threshold = 3


Vectorizing loop at pa2-p2.c:37

pa2-p2.c:37: note: === vec_transform_loop ===
pa2-p2.c:37: note: ------>vectorizing phi: j_131 = PHI <j_47(7), 0(43)>

pa2-p2.c:37: note: transform phi.
pa2-p2.c:37: note: transform induction phi.
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: created new init_stmt: stmp_var_.274_161 = 0 + 1;

pa2-p2.c:37: note: created new init_stmt: stmp_var_.274_160 = stmp_var_.274_161 + 1;

pa2-p2.c:37: note: created new init_stmt: stmp_var_.274_159 = stmp_var_.274_160 + 1;

pa2-p2.c:37: note: created new init_stmt: vect_cst_.275_158 = {0, stmp_var_.274_161, stmp_var_.274_160, stmp_var_.274_159};

pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: created new init_stmt: vect_cst_.276_153 = { 4, 4, 4, 4 };

pa2-p2.c:37: note: transform induction: created def-use cycle: vect_vec_iv_.277_150 = PHI <vect_vec_iv_.277_149(7), vect_cst_.275_158(43)>

vect_vec_iv_.277_149 = vect_vec_iv_.277_150 + vect_cst_.276_153;

pa2-p2.c:37: note: ------>vectorizing phi: .MEM_137 = PHI <.MEM_46(7), .MEM_103(43)>

pa2-p2.c:37: note: ------>vectorizing phi: ivtmp_117 = PHI <ivtmp_116(7), 2000(43)>

pa2-p2.c:37: note: ------>vectorizing phi: vect_vec_iv_.277_150 = PHI <vect_vec_iv_.277_149(7), vect_cst_.275_158(43)>

pa2-p2.c:37: note: ------>vectorizing statement: vect_vec_iv_.277_149 = vect_vec_iv_.277_150 + vect_cst_.276_153;

pa2-p2.c:37: note: ------>vectorizing statement: # DEBUG j => j_131

pa2-p2.c:37: note: ------>vectorizing statement: _36 = pretmp_28 + j_131;

pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand pretmp_28
pa2-p2.c:37: note: def_stmt: pretmp_28 = i_126 * 2;

pa2-p2.c:37: note: type of def: 2.
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(43)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: transform binary/unary operation.
pa2-p2.c:37: note: vect_get_vec_def_for_operand: pretmp_28
pa2-p2.c:37: note: vect_is_simple_use: operand pretmp_28
pa2-p2.c:37: note: def_stmt: pretmp_28 = i_126 * 2;

pa2-p2.c:37: note: type of def: 2.
pa2-p2.c:37: note: def =  pretmp_28  def_stmt =  pretmp_28 = i_126 * 2;

pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: Create vector_inv.
pa2-p2.c:37: note: created new init_stmt: vect_cst_.279_148 = {pretmp_28, pretmp_28, pretmp_28, pretmp_28};

pa2-p2.c:37: note: vect_get_vec_def_for_operand: j_131
pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(43)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: def =  j_131  def_stmt =  j_131 = PHI <j_47(7), 0(43)>

pa2-p2.c:37: note: add new stmt: vect_var_.278_147 = vect_cst_.279_148 + vect_vec_iv_.277_150;

pa2-p2.c:37: note: ------>vectorizing statement: _37 = (double) _36;

pa2-p2.c:37: note: multiple-types.
pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand _36
pa2-p2.c:37: note: def_stmt: _36 = pretmp_28 + j_131;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: transform conversion. ncopies = 1.
pa2-p2.c:37: note: vect_get_vec_def_for_operand: _36
pa2-p2.c:37: note: vect_is_simple_use: operand _36
pa2-p2.c:37: note: def_stmt: _36 = pretmp_28 + j_131;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: def =  _36  def_stmt =  _36 = pretmp_28 + j_131;

pa2-p2.c:37: note: add new stmt: vect_var_.280_102 = [vec_unpack_float_lo_expr] vect_var_.278_147;

pa2-p2.c:37: note: add new stmt: vect_var_.280_100 = [vec_unpack_float_hi_expr] vect_var_.278_147;

pa2-p2.c:37: note: ------>vectorizing statement: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:37: note: multiple-types.
pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand _37
pa2-p2.c:37: note: def_stmt: _37 = (double) _36;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: vect_is_simple_use: operand 1.100000000000000088817841970012523233890533447265625e+0
pa2-p2.c:37: note: transform binary/unary operation.
pa2-p2.c:37: note: vect_get_vec_def_for_operand: _37
pa2-p2.c:37: note: vect_is_simple_use: operand _37
pa2-p2.c:37: note: def_stmt: _37 = (double) _36;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: def =  _37  def_stmt =  _37 = (double) _36;

pa2-p2.c:37: note: vect_get_vec_def_for_operand: 1.100000000000000088817841970012523233890533447265625e+0
pa2-p2.c:37: note: vect_is_simple_use: operand 1.100000000000000088817841970012523233890533447265625e+0
pa2-p2.c:37: note: get vectype with 2 units of type double
pa2-p2.c:37: note: vectype: vector(2) double
pa2-p2.c:37: note: Create vector_cst. nunits = 2
pa2-p2.c:37: note: created new init_stmt: vect_cst_.282_99 = { 1.100000000000000088817841970012523233890533447265625e+0, 1.100000000000000088817841970012523233890533447265625e+0 };

pa2-p2.c:37: note: add new stmt: vect_var_.281_98 = vect_var_.280_102 * vect_cst_.282_99;

pa2-p2.c:37: note: add new stmt: vect_var_.281_96 = vect_var_.280_100 * vect_cst_.282_99;

pa2-p2.c:37: note: ------>vectorizing statement: _39 = (float) _38;

pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand _38
pa2-p2.c:37: note: def_stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: transform conversion. ncopies = 1.
pa2-p2.c:37: note: vect_get_vec_def_for_operand: _38
pa2-p2.c:37: note: vect_is_simple_use: operand _38
pa2-p2.c:37: note: def_stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: def =  _38  def_stmt =  _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p2.c:37: note: add new stmt: vect_var_.283_55 = VEC_PACK_TRUNC_EXPR <vect_var_.281_98, vect_var_.281_96>;

pa2-p2.c:37: note: ------>vectorizing statement: a[i_126][j_131] = _39;

pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand _39
pa2-p2.c:37: note: def_stmt: _39 = (float) _38;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: transform store. ncopies = 1
pa2-p2.c:37: note: vect_get_vec_def_for_operand: _39
pa2-p2.c:37: note: vect_is_simple_use: operand _39
pa2-p2.c:37: note: def_stmt: _39 = (float) _38;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: def =  _39  def_stmt =  _39 = (float) _38;

pa2-p2.c:37: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: a
pa2-p2.c:37: note: created vect_pa.287_15
pa2-p2.c:37: note: add new stmt: MEM[(float[2000][2000] *)vect_pa.284_14] = vect_var_.283_55;

pa2-p2.c:37: note: ------>vectorizing statement: _41 = j_131 * 2;

pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(43)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: vect_is_simple_use: operand 2
pa2-p2.c:37: note: transform binary/unary operation.
pa2-p2.c:37: note: vect_get_vec_def_for_operand: j_131
pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(43)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: def =  j_131  def_stmt =  j_131 = PHI <j_47(7), 0(43)>

pa2-p2.c:37: note: vect_get_vec_def_for_operand: 2
pa2-p2.c:37: note: vect_is_simple_use: operand 2
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: Create vector_cst. nunits = 4
pa2-p2.c:37: note: created new init_stmt: vect_cst_.289_40 = { 2, 2, 2, 2 };

pa2-p2.c:37: note: add new stmt: vect_var_.288_162 = vect_vec_iv_.277_150 * vect_cst_.289_40;

pa2-p2.c:37: note: ------>vectorizing statement: _42 = _41 + i_126;

pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand _41
pa2-p2.c:37: note: def_stmt: _41 = j_131 * 2;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: vect_is_simple_use: operand i_126
pa2-p2.c:37: note: def_stmt: i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:37: note: type of def: 2.
pa2-p2.c:37: note: transform binary/unary operation.
pa2-p2.c:37: note: vect_get_vec_def_for_operand: _41
pa2-p2.c:37: note: vect_is_simple_use: operand _41
pa2-p2.c:37: note: def_stmt: _41 = j_131 * 2;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: def =  _41  def_stmt =  _41 = j_131 * 2;

pa2-p2.c:37: note: vect_get_vec_def_for_operand: i_126
pa2-p2.c:37: note: vect_is_simple_use: operand i_126
pa2-p2.c:37: note: def_stmt: i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:37: note: type of def: 2.
pa2-p2.c:37: note: def =  i_126  def_stmt =  i_126 = PHI <0(6), i_48(11)>

pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: Create vector_inv.
pa2-p2.c:37: note: created new init_stmt: vect_cst_.291_163 = {i_126, i_126, i_126, i_126};

pa2-p2.c:37: note: add new stmt: vect_var_.290_164 = vect_var_.288_162 + vect_cst_.291_163;

pa2-p2.c:37: note: ------>vectorizing statement: _43 = (double) _42;

pa2-p2.c:37: note: multiple-types.
pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand _42
pa2-p2.c:37: note: def_stmt: _42 = _41 + i_126;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: transform conversion. ncopies = 1.
pa2-p2.c:37: note: vect_get_vec_def_for_operand: _42
pa2-p2.c:37: note: vect_is_simple_use: operand _42
pa2-p2.c:37: note: def_stmt: _42 = _41 + i_126;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: def =  _42  def_stmt =  _42 = _41 + i_126;

pa2-p2.c:37: note: add new stmt: vect_var_.292_165 = [vec_unpack_float_lo_expr] vect_var_.290_164;

pa2-p2.c:37: note: add new stmt: vect_var_.292_166 = [vec_unpack_float_hi_expr] vect_var_.290_164;

pa2-p2.c:37: note: ------>vectorizing statement: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:37: note: multiple-types.
pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand _43
pa2-p2.c:37: note: def_stmt: _43 = (double) _42;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: vect_is_simple_use: operand 1.1999999999999999555910790149937383830547332763671875e+0
pa2-p2.c:37: note: transform binary/unary operation.
pa2-p2.c:37: note: vect_get_vec_def_for_operand: _43
pa2-p2.c:37: note: vect_is_simple_use: operand _43
pa2-p2.c:37: note: def_stmt: _43 = (double) _42;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: def =  _43  def_stmt =  _43 = (double) _42;

pa2-p2.c:37: note: vect_get_vec_def_for_operand: 1.1999999999999999555910790149937383830547332763671875e+0
pa2-p2.c:37: note: vect_is_simple_use: operand 1.1999999999999999555910790149937383830547332763671875e+0
pa2-p2.c:37: note: get vectype with 2 units of type double
pa2-p2.c:37: note: vectype: vector(2) double
pa2-p2.c:37: note: Create vector_cst. nunits = 2
pa2-p2.c:37: note: created new init_stmt: vect_cst_.294_167 = { 1.1999999999999999555910790149937383830547332763671875e+0, 1.1999999999999999555910790149937383830547332763671875e+0 };

pa2-p2.c:37: note: add new stmt: vect_var_.293_168 = vect_var_.292_165 * vect_cst_.294_167;

pa2-p2.c:37: note: add new stmt: vect_var_.293_169 = vect_var_.292_166 * vect_cst_.294_167;

pa2-p2.c:37: note: ------>vectorizing statement: _45 = (float) _44;

pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand _44
pa2-p2.c:37: note: def_stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: transform conversion. ncopies = 1.
pa2-p2.c:37: note: vect_get_vec_def_for_operand: _44
pa2-p2.c:37: note: vect_is_simple_use: operand _44
pa2-p2.c:37: note: def_stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: def =  _44  def_stmt =  _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p2.c:37: note: add new stmt: vect_var_.295_170 = VEC_PACK_TRUNC_EXPR <vect_var_.293_168, vect_var_.293_169>;

pa2-p2.c:37: note: ------>vectorizing statement: b[i_126][j_131] = _45;

pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand _45
pa2-p2.c:37: note: def_stmt: _45 = (float) _44;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: transform store. ncopies = 1
pa2-p2.c:37: note: vect_get_vec_def_for_operand: _45
pa2-p2.c:37: note: vect_is_simple_use: operand _45
pa2-p2.c:37: note: def_stmt: _45 = (float) _44;

pa2-p2.c:37: note: type of def: 3.
pa2-p2.c:37: note: def =  _45  def_stmt =  _45 = (float) _44;

pa2-p2.c:37: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: b
pa2-p2.c:37: note: created vect_pb.299_173
pa2-p2.c:37: note: add new stmt: MEM[(float[2000][2000] *)vect_pb.296_174] = vect_var_.295_170;

pa2-p2.c:37: note: ------>vectorizing statement: j_47 = j_131 + 1;

pa2-p2.c:37: note: transform statement.
pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(43)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: vect_is_simple_use: operand 1
pa2-p2.c:37: note: transform binary/unary operation.
pa2-p2.c:37: note: vect_get_vec_def_for_operand: j_131
pa2-p2.c:37: note: vect_is_simple_use: operand j_131
pa2-p2.c:37: note: def_stmt: j_131 = PHI <j_47(7), 0(43)>

pa2-p2.c:37: note: type of def: 4.
pa2-p2.c:37: note: def =  j_131  def_stmt =  j_131 = PHI <j_47(7), 0(43)>

pa2-p2.c:37: note: vect_get_vec_def_for_operand: 1
pa2-p2.c:37: note: vect_is_simple_use: operand 1
pa2-p2.c:37: note: get vectype with 4 units of type int
pa2-p2.c:37: note: vectype: vector(4) int
pa2-p2.c:37: note: Create vector_cst. nunits = 4
pa2-p2.c:37: note: created new init_stmt: vect_cst_.301_46 = { 1, 1, 1, 1 };

pa2-p2.c:37: note: add new stmt: vect_j.300_177 = vect_vec_iv_.277_150 + vect_cst_.301_46;

pa2-p2.c:37: note: ------>vectorizing statement: # DEBUG j => j_47

pa2-p2.c:37: note: ------>vectorizing statement: # DEBUG j => j_47

pa2-p2.c:37: note: ------>vectorizing statement: ivtmp_116 = ivtmp_117 - 1;

pa2-p2.c:37: note: ------>vectorizing statement: vect_pa.284_13 = vect_pa.284_14 + 16;

pa2-p2.c:37: note: ------>vectorizing statement: vect_pb.296_175 = vect_pb.296_174 + 16;

pa2-p2.c:37: note: ------>vectorizing statement: if (ivtmp_116 != 0)

loop at pa2-p2.c:38: if (ivtmp_179 < 500)

pa2-p2.c:37: note: LOOP VECTORIZED.
pa2-p2.c:16: note: vectorized 4 loops in function.

pa2-p2.c:24: note: ===vect_slp_analyze_bb===

pa2-p2.c:24: note: === vect_analyze_data_refs ===

pa2-p2.c:24: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:25: note: ===vect_slp_analyze_bb===

pa2-p2.c:25: note: === vect_analyze_data_refs ===

pa2-p2.c:25: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:28: note: ===vect_slp_analyze_bb===

pa2-p2.c:28: note: === vect_analyze_data_refs ===

pa2-p2.c:28: note: get vectype with 2 units of type long unsigned int
pa2-p2.c:28: note: vectype: vector(2) long unsigned int
pa2-p2.c:28: note: === vect_pattern_recog ===
pa2-p2.c:28: note: === vect_analyze_dependences ===
pa2-p2.c:28: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:28: note: vect_compute_data_ref_alignment:
pa2-p2.c:28: note: can't force alignment of ref: MEM[(char * *)argv_27(D) + 8B]
pa2-p2.c:28: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:28: note: not consecutive access _29 = MEM[(char * *)argv_27(D) + 8B];

pa2-p2.c:28: note: === vect_analyze_slp ===
pa2-p2.c:28: note: Failed to SLP the basic block.
pa2-p2.c:28: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:30: note: ===vect_slp_analyze_bb===

pa2-p2.c:30: note: === vect_analyze_data_refs ===

pa2-p2.c:30: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:33: note: ===vect_slp_analyze_bb===

pa2-p2.c:33: note: === vect_analyze_data_refs ===

pa2-p2.c:33: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:38: note: ===vect_slp_analyze_bb===

pa2-p2.c:38: note: === vect_analyze_data_refs ===

pa2-p2.c:38: note: not vectorized: no vectype for stmt: MEM[(float[2000][2000] *)vect_pa.284_14] = vect_var_.283_55;
 scalar_type: vector(4) float
pa2-p2.c:38: note: === vect_pattern_recog ===
pa2-p2.c:38: note: vect_is_simple_use: operand vect_var_.280_102
pa2-p2.c:38: note: def_stmt: vect_var_.280_102 = [vec_unpack_float_lo_expr] vect_var_.278_147;

pa2-p2.c:38: note: type of def: 3.
pa2-p2.c:38: note: vect_is_simple_use: operand vect_var_.280_100
pa2-p2.c:38: note: def_stmt: vect_var_.280_100 = [vec_unpack_float_hi_expr] vect_var_.278_147;

pa2-p2.c:38: note: type of def: 3.
pa2-p2.c:38: note: vect_is_simple_use: operand vect_vec_iv_.277_150
pa2-p2.c:38: note: def_stmt: vect_vec_iv_.277_150 = PHI <vect_vec_iv_.277_149(7), vect_cst_.275_158(12)>

pa2-p2.c:38: note: type of def: 2.
pa2-p2.c:38: note: vect_is_simple_use: operand vect_var_.292_165
pa2-p2.c:38: note: def_stmt: vect_var_.292_165 = [vec_unpack_float_lo_expr] vect_var_.290_164;

pa2-p2.c:38: note: type of def: 3.
pa2-p2.c:38: note: vect_is_simple_use: operand vect_var_.292_166
pa2-p2.c:38: note: def_stmt: vect_var_.292_166 = [vec_unpack_float_hi_expr] vect_var_.290_164;

pa2-p2.c:38: note: type of def: 3.
pa2-p2.c:38: note: === vect_analyze_dependences ===
pa2-p2.c:38: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:38: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:38: note: === vect_analyze_slp ===
pa2-p2.c:38: note: Failed to SLP the basic block.
pa2-p2.c:38: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:36: note: ===vect_slp_analyze_bb===

pa2-p2.c:36: note: === vect_analyze_data_refs ===

pa2-p2.c:36: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:42: note: ===vect_slp_analyze_bb===

pa2-p2.c:42: note: === vect_analyze_data_refs ===

pa2-p2.c:42: note: not vectorized: no vectype for stmt: MEM[(float[2000][2000] *)vect_pc.270_4] = vect_cst_.269_8;
 scalar_type: vector(4) float
pa2-p2.c:42: note: === vect_pattern_recog ===
pa2-p2.c:42: note: === vect_analyze_dependences ===
pa2-p2.c:42: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:42: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:42: note: === vect_analyze_slp ===
pa2-p2.c:42: note: Failed to SLP the basic block.
pa2-p2.c:42: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:42: note: ===vect_slp_analyze_bb===

pa2-p2.c:42: note: === vect_analyze_data_refs ===

pa2-p2.c:42: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:43: note: ===vect_slp_analyze_bb===

pa2-p2.c:43: note: === vect_analyze_data_refs ===

pa2-p2.c:43: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:47: note: ===vect_slp_analyze_bb===

pa2-p2.c:47: note: === vect_analyze_data_refs ===

pa2-p2.c:47: note: get vectype with 4 units of type float
pa2-p2.c:47: note: vectype: vector(4) float
pa2-p2.c:47: note: get vectype with 4 units of type float
pa2-p2.c:47: note: vectype: vector(4) float
pa2-p2.c:47: note: === vect_pattern_recog ===
pa2-p2.c:47: note: vect_is_simple_use: operand _58
pa2-p2.c:47: note: def_stmt: _58 = a[k_136][i_128];

pa2-p2.c:47: note: type of def: 3.
pa2-p2.c:47: note: === vect_analyze_dependences ===
pa2-p2.c:47: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:47: note: vect_compute_data_ref_alignment:
pa2-p2.c:47: note: Unknown alignment for access: a
pa2-p2.c:47: note: vect_compute_data_ref_alignment:
pa2-p2.c:47: note: Unknown alignment for access: b
pa2-p2.c:47: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:47: note: not consecutive access _58 = a[k_136][i_128];

pa2-p2.c:47: note: not consecutive access _59 = b[k_136][j_133];

pa2-p2.c:47: note: === vect_analyze_slp ===
pa2-p2.c:47: note: Failed to SLP the basic block.
pa2-p2.c:47: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:45: note: ===vect_slp_analyze_bb===

pa2-p2.c:45: note: === vect_analyze_data_refs ===

pa2-p2.c:45: note: get vectype with 4 units of type float
pa2-p2.c:45: note: vectype: vector(4) float
pa2-p2.c:45: note: === vect_pattern_recog ===
pa2-p2.c:45: note: === vect_analyze_dependences ===
pa2-p2.c:45: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:45: note: vect_compute_data_ref_alignment:
pa2-p2.c:45: note: Unknown alignment for access: c
pa2-p2.c:45: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:45: note: not consecutive access c[j_133][i_128] = c_I_I_lsm.254_155;

pa2-p2.c:45: note: === vect_analyze_slp ===
pa2-p2.c:45: note: Failed to SLP the basic block.
pa2-p2.c:45: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: get vectype with 4 units of type float
pa2-p2.c:16: note: vectype: vector(4) float
pa2-p2.c:16: note: === vect_pattern_recog ===
pa2-p2.c:16: note: === vect_analyze_dependences ===
pa2-p2.c:16: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:16: note: vect_compute_data_ref_alignment:
pa2-p2.c:16: note: Unknown alignment for access: c
pa2-p2.c:16: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:16: note: not consecutive access pretmp_151 = c[j_133][i_128];

pa2-p2.c:16: note: === vect_analyze_slp ===
pa2-p2.c:16: note: Failed to SLP the basic block.
pa2-p2.c:16: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:44: note: ===vect_slp_analyze_bb===

pa2-p2.c:44: note: === vect_analyze_data_refs ===

pa2-p2.c:44: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:48: note: ===vect_slp_analyze_bb===

pa2-p2.c:48: note: === vect_analyze_data_refs ===

pa2-p2.c:48: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:53: note: ===vect_slp_analyze_bb===

pa2-p2.c:53: note: === vect_analyze_data_refs ===

pa2-p2.c:53: note: not vectorized: no vectype for stmt: vect_var_.264_22 = MEM[(float[2000][2000] *)vect_pc.260_71];
 scalar_type: vector(4) float
pa2-p2.c:53: note: === vect_pattern_recog ===
pa2-p2.c:53: note: === vect_analyze_dependences ===
pa2-p2.c:53: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:53: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:53: note: === vect_analyze_slp ===
pa2-p2.c:53: note: Failed to SLP the basic block.
pa2-p2.c:53: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:51: note: ===vect_slp_analyze_bb===

pa2-p2.c:51: note: === vect_analyze_data_refs ===

pa2-p2.c:51: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:58: note: ===vect_slp_analyze_bb===

pa2-p2.c:58: note: === vect_analyze_data_refs ===

pa2-p2.c:58: note: not vectorized: no vectype for stmt: MEM[(float[2000][2000] *)vect_pc.256_109] = vect_cst_.255_113;
 scalar_type: vector(4) float
pa2-p2.c:58: note: === vect_pattern_recog ===
pa2-p2.c:58: note: === vect_analyze_dependences ===
pa2-p2.c:58: note: === vect_analyze_data_refs_alignment ===
pa2-p2.c:58: note: === vect_analyze_data_ref_accesses ===
pa2-p2.c:58: note: === vect_analyze_slp ===
pa2-p2.c:58: note: Failed to SLP the basic block.
pa2-p2.c:58: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p2.c:58: note: ===vect_slp_analyze_bb===

pa2-p2.c:58: note: === vect_analyze_data_refs ===

pa2-p2.c:58: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:16: note: ===vect_slp_analyze_bb===

pa2-p2.c:16: note: === vect_analyze_data_refs ===

pa2-p2.c:16: note: not vectorized: not enough data-refs in basic block.

pa2-p2.c:59: note: ===vect_slp_analyze_bb===

pa2-p2.c:59: note: === vect_analyze_data_refs ===

pa2-p2.c:59: note: not vectorized: not enough data-refs in basic block.
