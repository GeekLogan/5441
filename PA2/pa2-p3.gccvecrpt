
pa2-p3.c:65: note: ===== analyze_loop_nest =====
pa2-p3.c:65: note: === vect_analyze_loop_form ===
pa2-p3.c:65: note: not vectorized: multiple nested loops.
pa2-p3.c:65: note: bad loop form.
Analyzing loop at pa2-p3.c:67

pa2-p3.c:67: note: ===== analyze_loop_nest =====
pa2-p3.c:67: note: === vect_analyze_loop_form ===
pa2-p3.c:67: note: not vectorized: multiple nested loops.
pa2-p3.c:67: note: bad loop form.
Analyzing loop at pa2-p3.c:67

pa2-p3.c:67: note: ===== analyze_loop_nest =====
pa2-p3.c:67: note: === vect_analyze_loop_form ===
pa2-p3.c:67: note: not vectorized: multiple nested loops.
pa2-p3.c:67: note: bad loop form.
Analyzing loop at pa2-p3.c:72

pa2-p3.c:72: note: ===== analyze_loop_nest =====
pa2-p3.c:72: note: === vect_analyze_loop_form ===
pa2-p3.c:72: note: not vectorized: multiple nested loops.
pa2-p3.c:72: note: bad loop form.
Analyzing loop at pa2-p3.c:74

pa2-p3.c:74: note: ===== analyze_loop_nest =====
pa2-p3.c:74: note: === vect_analyze_loop_form ===
pa2-p3.c:74: note: ===== analyze_loop_nest_1 =====
pa2-p3.c:74: note: === vect_analyze_loop_form ===
pa2-p3.c:74: note: === get_loop_niters ===
pa2-p3.c:74: note: ==> get_loop_niters:1999 - (unsigned int) i_82
pa2-p3.c:74: note: Symbolic number of iterations is 1999 - (unsigned int) i_82
pa2-p3.c:74: note: not vectorized: inner-loop count not invariant.
pa2-p3.c:74: note: bad loop form.
Analyzing loop at pa2-p3.c:74

pa2-p3.c:74: note: ===== analyze_loop_nest =====
pa2-p3.c:74: note: === vect_analyze_loop_form ===
pa2-p3.c:74: note: === get_loop_niters ===
pa2-p3.c:74: note: ==> get_loop_niters:1999 - (unsigned int) i_82
pa2-p3.c:74: note: Symbolic number of iterations is 1999 - (unsigned int) i_82
pa2-p3.c:74: note: === vect_analyze_data_refs ===

pa2-p3.c:74: note: get vectype with 4 units of type float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: get vectype with 4 units of type float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: get vectype with 4 units of type float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:74: note: Analyze phi: i_69 = PHI <i_79(30), i_71(28)>

pa2-p3.c:74: note: Access function of PHI: {i_71, +, 1}_9
pa2-p3.c:74: note: step: 1,  init: i_71
pa2-p3.c:74: note: Detected induction.
pa2-p3.c:74: note: Analyze phi: .MEM_94 = PHI <.MEM_78(30), .MEM_90(28)>

pa2-p3.c:74: note: === vect_pattern_recog ===
pa2-p3.c:74: note: vect_is_simple_use: operand _74
pa2-p3.c:74: note: def_stmt: _74 = a[i_82][i_69];

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p3.c:74: note: init: phi relevant? i_69 = PHI <i_79(30), i_71(28)>

pa2-p3.c:74: note: init: phi relevant? .MEM_94 = PHI <.MEM_78(30), .MEM_90(28)>

pa2-p3.c:74: note: init: stmt relevant? # DEBUG i => i_69

pa2-p3.c:74: note: init: stmt relevant? _73 = c[j_18][i_69];

pa2-p3.c:74: note: init: stmt relevant? _74 = a[i_82][i_69];

pa2-p3.c:74: note: init: stmt relevant? _76 = _74 * pretmp_155;

pa2-p3.c:74: note: init: stmt relevant? _77 = _73 + _76;

pa2-p3.c:74: note: init: stmt relevant? c[j_18][i_69] = _77;

pa2-p3.c:74: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:74: note: mark relevant 4, live 0.
pa2-p3.c:74: note: init: stmt relevant? i_79 = i_69 + 1;

pa2-p3.c:74: note: init: stmt relevant? # DEBUG i => i_79

pa2-p3.c:74: note: init: stmt relevant? # DEBUG i => i_79

pa2-p3.c:74: note: init: stmt relevant? if (i_79 != 2000)

pa2-p3.c:74: note: worklist: examine stmt: c[j_18][i_69] = _77;

pa2-p3.c:74: note: vect_is_simple_use: operand _77
pa2-p3.c:74: note: def_stmt: _77 = _73 + _76;

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: mark relevant 4, live 0.
pa2-p3.c:74: note: worklist: examine stmt: _77 = _73 + _76;

pa2-p3.c:74: note: vect_is_simple_use: operand _73
pa2-p3.c:74: note: def_stmt: _73 = c[j_18][i_69];

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: mark relevant 4, live 0.
pa2-p3.c:74: note: vect_is_simple_use: operand _76
pa2-p3.c:74: note: def_stmt: _76 = _74 * pretmp_155;

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: mark relevant 4, live 0.
pa2-p3.c:74: note: worklist: examine stmt: _76 = _74 * pretmp_155;

pa2-p3.c:74: note: vect_is_simple_use: operand _74
pa2-p3.c:74: note: def_stmt: _74 = a[i_82][i_69];

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: mark relevant 4, live 0.
pa2-p3.c:74: note: vect_is_simple_use: operand pretmp_155
pa2-p3.c:74: note: def_stmt: pretmp_155 = b[i_82][j_18];

pa2-p3.c:74: note: type of def: 2.
pa2-p3.c:74: note: def_stmt is out of loop.
pa2-p3.c:74: note: worklist: examine stmt: _74 = a[i_82][i_69];

pa2-p3.c:74: note: worklist: examine stmt: _73 = c[j_18][i_69];

pa2-p3.c:74: note: === vect_analyze_dependences ===
pa2-p3.c:74: note: dependence distance  = 0.
pa2-p3.c:74: note: dependence distance == 0 between c[j_18][i_69] and c[j_18][i_69]
pa2-p3.c:74: note: === vect_determine_vectorization_factor ===
pa2-p3.c:74: note: ==> examining phi: i_69 = PHI <i_79(30), i_71(28)>

pa2-p3.c:74: note: ==> examining phi: .MEM_94 = PHI <.MEM_78(30), .MEM_90(28)>

pa2-p3.c:74: note: ==> examining statement: # DEBUG i => i_69

pa2-p3.c:74: note: skip.
pa2-p3.c:74: note: ==> examining statement: _73 = c[j_18][i_69];

pa2-p3.c:74: note: get vectype for scalar type:  float
pa2-p3.c:74: note: get vectype with 4 units of type float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: nunits = 4
pa2-p3.c:74: note: ==> examining statement: _74 = a[i_82][i_69];

pa2-p3.c:74: note: get vectype for scalar type:  float
pa2-p3.c:74: note: get vectype with 4 units of type float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: nunits = 4
pa2-p3.c:74: note: ==> examining statement: _76 = _74 * pretmp_155;

pa2-p3.c:74: note: get vectype for scalar type:  float
pa2-p3.c:74: note: get vectype with 4 units of type float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: get vectype for scalar type:  float
pa2-p3.c:74: note: get vectype with 4 units of type float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: nunits = 4
pa2-p3.c:74: note: ==> examining statement: _77 = _73 + _76;

pa2-p3.c:74: note: get vectype for scalar type:  float
pa2-p3.c:74: note: get vectype with 4 units of type float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: get vectype for scalar type:  float
pa2-p3.c:74: note: get vectype with 4 units of type float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: nunits = 4
pa2-p3.c:74: note: ==> examining statement: c[j_18][i_69] = _77;

pa2-p3.c:74: note: get vectype for scalar type:  float
pa2-p3.c:74: note: get vectype with 4 units of type float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: nunits = 4
pa2-p3.c:74: note: ==> examining statement: i_79 = i_69 + 1;

pa2-p3.c:74: note: skip.
pa2-p3.c:74: note: ==> examining statement: # DEBUG i => i_79

pa2-p3.c:74: note: skip.
pa2-p3.c:74: note: ==> examining statement: # DEBUG i => i_79

pa2-p3.c:74: note: skip.
pa2-p3.c:74: note: ==> examining statement: if (i_79 != 2000)

pa2-p3.c:74: note: skip.
pa2-p3.c:74: note: vectorization factor = 4
pa2-p3.c:74: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:74: note: dependence distance  = 0.
pa2-p3.c:74: note: accesses have the same alignment.dependence distance modulo vf == 0 between c[j_18][i_69] and c[j_18][i_69]
pa2-p3.c:74: note: vect_compute_data_ref_alignment:
pa2-p3.c:74: note: Unknown alignment for access: c
pa2-p3.c:74: note: vect_compute_data_ref_alignment:
pa2-p3.c:74: note: Unknown alignment for access: a
pa2-p3.c:74: note: vect_compute_data_ref_alignment:
pa2-p3.c:74: note: Unknown alignment for access: c
pa2-p3.c:74: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:74: note: === vect_prune_runtime_alias_test_list ===
pa2-p3.c:74: note: === vect_enhance_data_refs_alignment ===
pa2-p3.c:74: note: Unknown misalignment, is_packed = 0
pa2-p3.c:74: note: Unknown misalignment, is_packed = 0
pa2-p3.c:74: note: Unknown misalignment, is_packed = 0
pa2-p3.c:74: note: vect_can_advance_ivs_p:
pa2-p3.c:74: note: Analyze phi: i_69 = PHI <i_79(30), i_71(28)>

pa2-p3.c:74: note: Access function of PHI: {i_71, +, 1}_9
pa2-p3.c:74: note: Analyze phi: .MEM_94 = PHI <.MEM_78(30), .MEM_90(28)>

pa2-p3.c:74: note: virtual phi. skip.
pa2-p3.c:74: note: vect_model_load_cost: unaligned supported by hardware.
pa2-p3.c:74: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
pa2-p3.c:74: note: vect_model_store_cost: unaligned supported by hardware.
pa2-p3.c:74: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
pa2-p3.c:74: note: Setting misalignment to -1.
pa2-p3.c:74: note: Setting misalignment to -1.
pa2-p3.c:74: note: Alignment of access forced using peeling.
pa2-p3.c:74: note: Peeling for alignment will be applied.
pa2-p3.c:74: note: Vectorizing an unaligned access.
pa2-p3.c:74: note: === vect_analyze_slp ===
pa2-p3.c:74: note: === vect_make_slp_decision ===
pa2-p3.c:74: note: === vect_detect_hybrid_slp ===
pa2-p3.c:74: note: === vect_analyze_loop_operations ===
pa2-p3.c:74: note: examining phi: i_69 = PHI <i_79(30), i_71(28)>

pa2-p3.c:74: note: examining phi: .MEM_94 = PHI <.MEM_78(30), .MEM_90(28)>

pa2-p3.c:74: note: ==> examining statement: # DEBUG i => i_69

pa2-p3.c:74: note: irrelevant.
pa2-p3.c:74: note: ==> examining statement: _73 = c[j_18][i_69];

pa2-p3.c:74: note: num. args = 4 (not unary/binary/ternary op).
pa2-p3.c:74: note: vect_is_simple_use: operand c[j_18][i_69]
pa2-p3.c:74: note: not ssa-name.
pa2-p3.c:74: note: use not simple.
pa2-p3.c:74: note: vect_model_load_cost: aligned.
pa2-p3.c:74: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:74: note: ==> examining statement: _74 = a[i_82][i_69];

pa2-p3.c:74: note: num. args = 4 (not unary/binary/ternary op).
pa2-p3.c:74: note: vect_is_simple_use: operand a[i_82][i_69]
pa2-p3.c:74: note: not ssa-name.
pa2-p3.c:74: note: use not simple.
pa2-p3.c:74: note: vect_model_load_cost: unaligned supported by hardware.
pa2-p3.c:74: note: vect_model_load_cost: inside_cost = 2, prologue_cost = 0 .
pa2-p3.c:74: note: ==> examining statement: _76 = _74 * pretmp_155;

pa2-p3.c:74: note: vect_is_simple_use: operand _74
pa2-p3.c:74: note: def_stmt: _74 = a[i_82][i_69];

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: vect_is_simple_use: operand pretmp_155
pa2-p3.c:74: note: def_stmt: pretmp_155 = b[i_82][j_18];

pa2-p3.c:74: note: type of def: 2.
pa2-p3.c:74: note: === vectorizable_operation ===
pa2-p3.c:74: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p3.c:74: note: ==> examining statement: _77 = _73 + _76;

pa2-p3.c:74: note: vect_is_simple_use: operand _73
pa2-p3.c:74: note: def_stmt: _73 = c[j_18][i_69];

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: vect_is_simple_use: operand _76
pa2-p3.c:74: note: def_stmt: _76 = _74 * pretmp_155;

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: === vectorizable_operation ===
pa2-p3.c:74: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:74: note: ==> examining statement: c[j_18][i_69] = _77;

pa2-p3.c:74: note: vect_is_simple_use: operand _77
pa2-p3.c:74: note: def_stmt: _77 = _73 + _76;

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: vect_model_store_cost: aligned.
pa2-p3.c:74: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:74: note: ==> examining statement: i_79 = i_69 + 1;

pa2-p3.c:74: note: irrelevant.
pa2-p3.c:74: note: ==> examining statement: # DEBUG i => i_79

pa2-p3.c:74: note: irrelevant.
pa2-p3.c:74: note: ==> examining statement: # DEBUG i => i_79

pa2-p3.c:74: note: irrelevant.
pa2-p3.c:74: note: ==> examining statement: if (i_79 != 2000)

pa2-p3.c:74: note: irrelevant.
pa2-p3.c:74: note: === vect_update_slp_costs_according_to_vf ===cost model: prologue peel iters set to vf/2.cost model: epilogue peel iters set to vf/2 because peeling for alignment is unknown.
pa2-p3.c:74: note: Cost model analysis: 
  Vector inside of loop cost: 6
  Vector prologue cost: 19
  Vector epilogue cost: 10
  Scalar iteration cost: 5
  Scalar outside cost: 7
  Vector outside cost: 29
  prologue iterations: 2
  epilogue iterations: 2
  Calculated minimum iters for profitability: 5

pa2-p3.c:74: note:   Runtime profitability threshold = 4

pa2-p3.c:74: note:   Static estimate profitability threshold = 4

pa2-p3.c:74: note: epilog loop required.
pa2-p3.c:74: note: vect_can_advance_ivs_p:
pa2-p3.c:74: note: Analyze phi: i_69 = PHI <i_79(30), i_71(28)>

pa2-p3.c:74: note: Access function of PHI: {i_71, +, 1}_9
pa2-p3.c:74: note: Analyze phi: .MEM_94 = PHI <.MEM_78(30), .MEM_90(28)>

pa2-p3.c:74: note: virtual phi. skip.

Vectorizing loop at pa2-p3.c:74

pa2-p3.c:74: note: === vec_transform_loop ===
pa2-p3.c:74: note: Profitability threshold is 4 loop iterations.
pa2-p3.c:74: note: === vect_do_peeling_for_alignment ===
pa2-p3.c:74: note: created vect_pc.17_72
pa2-p3.c:74: note: niters for prolog loop: MIN_EXPR <(unsigned int) -(((unsigned long) vect_pc.17_72 & 15) >> 2) & 3, niters.14_40>
loop at pa2-p3.c:75: if (ivtmp_114 < prologue_after_cost_adjust.19_122)
Setting upper bound of nb iterations for prologue loop to 3

pa2-p3.c:74: note: === vect_update_inits_of_dr ===
pa2-p3.c:74: note: === vect_do_peeling_for_loop_bound ===
pa2-p3.c:74: note: vect_update_ivs_after_vectorizer: phi: i_69 = PHI <i_79(30), i_121(50)>

pa2-p3.c:74: note: vect_update_ivs_after_vectorizer: phi: .MEM_94 = PHI <.MEM_78(30), .MEM_119(50)>

pa2-p3.c:74: note: virtual phi. skip.Setting upper bound of nb iterations for epilogue loop to 2

pa2-p3.c:74: note: ------>vectorizing phi: i_69 = PHI <i_79(30), i_121(54)>

pa2-p3.c:74: note: ------>vectorizing phi: .MEM_94 = PHI <.MEM_78(30), .MEM_119(54)>

pa2-p3.c:74: note: ------>vectorizing statement: # DEBUG i => i_69

pa2-p3.c:74: note: ------>vectorizing statement: _73 = c[j_18][i_69];

pa2-p3.c:74: note: transform statement.
pa2-p3.c:74: note: transform load. ncopies = 1
pa2-p3.c:74: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:74: note: created vect_pc.28_17
pa2-p3.c:74: note: add new stmt: vect_var_.29_14 = MEM[(float[2000][2000] *)vect_pc.25_16];

pa2-p3.c:74: note: ------>vectorizing statement: _74 = a[i_82][i_69];

pa2-p3.c:74: note: transform statement.
pa2-p3.c:74: note: transform load. ncopies = 1
pa2-p3.c:74: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: a
pa2-p3.c:74: note: created vect_pa.33_6
pa2-p3.c:74: note: add new stmt: vect_var_.34_3 = MEM[(float[2000][2000] *)vect_pa.30_5];

pa2-p3.c:74: note: ------>vectorizing statement: _76 = _74 * pretmp_155;

pa2-p3.c:74: note: transform statement.
pa2-p3.c:74: note: vect_is_simple_use: operand _74
pa2-p3.c:74: note: def_stmt: _74 = a[i_82][i_69];

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: vect_is_simple_use: operand pretmp_155
pa2-p3.c:74: note: def_stmt: pretmp_155 = b[i_82][j_18];

pa2-p3.c:74: note: type of def: 2.
pa2-p3.c:74: note: transform binary/unary operation.
pa2-p3.c:74: note: vect_get_vec_def_for_operand: _74
pa2-p3.c:74: note: vect_is_simple_use: operand _74
pa2-p3.c:74: note: def_stmt: _74 = a[i_82][i_69];

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: def =  _74  def_stmt =  _74 = a[i_82][i_69];

pa2-p3.c:74: note: vect_get_vec_def_for_operand: pretmp_155
pa2-p3.c:74: note: vect_is_simple_use: operand pretmp_155
pa2-p3.c:74: note: def_stmt: pretmp_155 = b[i_82][j_18];

pa2-p3.c:74: note: type of def: 2.
pa2-p3.c:74: note: def =  pretmp_155  def_stmt =  pretmp_155 = b[i_82][j_18];

pa2-p3.c:74: note: get vectype with 4 units of type float
pa2-p3.c:74: note: vectype: vector(4) float
pa2-p3.c:74: note: Create vector_inv.
pa2-p3.c:74: note: created new init_stmt: vect_cst_.36_2 = {pretmp_155, pretmp_155, pretmp_155, pretmp_155};

pa2-p3.c:74: note: add new stmt: vect_var_.35_128 = vect_var_.34_3 * vect_cst_.36_2;

pa2-p3.c:74: note: ------>vectorizing statement: _77 = _73 + _76;

pa2-p3.c:74: note: transform statement.
pa2-p3.c:74: note: vect_is_simple_use: operand _73
pa2-p3.c:74: note: def_stmt: _73 = c[j_18][i_69];

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: vect_is_simple_use: operand _76
pa2-p3.c:74: note: def_stmt: _76 = _74 * pretmp_155;

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: transform binary/unary operation.
pa2-p3.c:74: note: vect_get_vec_def_for_operand: _73
pa2-p3.c:74: note: vect_is_simple_use: operand _73
pa2-p3.c:74: note: def_stmt: _73 = c[j_18][i_69];

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: def =  _73  def_stmt =  _73 = c[j_18][i_69];

pa2-p3.c:74: note: vect_get_vec_def_for_operand: _76
pa2-p3.c:74: note: vect_is_simple_use: operand _76
pa2-p3.c:74: note: def_stmt: _76 = _74 * pretmp_155;

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: def =  _76  def_stmt =  _76 = _74 * pretmp_155;

pa2-p3.c:74: note: add new stmt: vect_var_.37_141 = vect_var_.29_14 + vect_var_.35_128;

pa2-p3.c:74: note: ------>vectorizing statement: c[j_18][i_69] = _77;

pa2-p3.c:74: note: transform statement.
pa2-p3.c:74: note: vect_is_simple_use: operand _77
pa2-p3.c:74: note: def_stmt: _77 = _73 + _76;

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: transform store. ncopies = 1
pa2-p3.c:74: note: vect_get_vec_def_for_operand: _77
pa2-p3.c:74: note: vect_is_simple_use: operand _77
pa2-p3.c:74: note: def_stmt: _77 = _73 + _76;

pa2-p3.c:74: note: type of def: 3.
pa2-p3.c:74: note: def =  _77  def_stmt =  _77 = _73 + _76;

pa2-p3.c:74: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:74: note: created vect_pc.41_165
pa2-p3.c:74: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.38_166] = vect_var_.37_141;

pa2-p3.c:74: note: ------>vectorizing statement: i_79 = i_69 + 1;

pa2-p3.c:74: note: ------>vectorizing statement: # DEBUG i => i_79

pa2-p3.c:74: note: ------>vectorizing statement: # DEBUG i => i_79

pa2-p3.c:74: note: ------>vectorizing statement: vect_pc.25_15 = vect_pc.25_16 + 16;

pa2-p3.c:74: note: ------>vectorizing statement: vect_pa.30_4 = vect_pa.30_5 + 16;

pa2-p3.c:74: note: ------>vectorizing statement: vect_pc.38_167 = vect_pc.38_166 + 16;

pa2-p3.c:74: note: ------>vectorizing statement: if (i_79 != 2000)

loop at pa2-p3.c:75: if (ivtmp_169 < bnd.22_108)

pa2-p3.c:74: note: LOOP VECTORIZED.
Analyzing loop at pa2-p3.c:78

pa2-p3.c:78: note: ===== analyze_loop_nest =====
pa2-p3.c:78: note: === vect_analyze_loop_form ===
pa2-p3.c:78: note: not vectorized: multiple nested loops.
pa2-p3.c:78: note: bad loop form.
Analyzing loop at pa2-p3.c:79

pa2-p3.c:79: note: ===== analyze_loop_nest =====
pa2-p3.c:79: note: === vect_analyze_loop_form ===
pa2-p3.c:79: note: ===== analyze_loop_nest_1 =====
pa2-p3.c:79: note: === vect_analyze_loop_form ===
pa2-p3.c:79: note: === get_loop_niters ===
pa2-p3.c:79: note: ==> get_loop_niters:1999 - (unsigned int) i_47
pa2-p3.c:79: note: Symbolic number of iterations is 1999 - (unsigned int) i_47
pa2-p3.c:79: note: not vectorized: inner-loop count not invariant.
pa2-p3.c:79: note: bad loop form.
Analyzing loop at pa2-p3.c:80

pa2-p3.c:80: note: ===== analyze_loop_nest =====
pa2-p3.c:80: note: === vect_analyze_loop_form ===
pa2-p3.c:80: note: === get_loop_niters ===
pa2-p3.c:80: note: ==> get_loop_niters:1999 - (unsigned int) i_47
pa2-p3.c:80: note: Symbolic number of iterations is 1999 - (unsigned int) i_47
pa2-p3.c:80: note: === vect_analyze_data_refs ===

pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:80: note: Analyze phi: i_92 = PHI <i_67(25), i_37(23)>

pa2-p3.c:80: note: Access function of PHI: {i_37, +, 1}_6
pa2-p3.c:80: note: step: 1,  init: i_37
pa2-p3.c:80: note: Detected induction.
pa2-p3.c:80: note: Analyze phi: .MEM_81 = PHI <.MEM_66(25), .MEM_97(23)>

pa2-p3.c:80: note: === vect_pattern_recog ===
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p3.c:80: note: init: phi relevant? i_92 = PHI <i_67(25), i_37(23)>

pa2-p3.c:80: note: init: phi relevant? .MEM_81 = PHI <.MEM_66(25), .MEM_97(23)>

pa2-p3.c:80: note: init: stmt relevant? # DEBUG i => i_92

pa2-p3.c:80: note: init: stmt relevant? _38 = c[j_68][i_92];

pa2-p3.c:80: note: init: stmt relevant? _39 = a[i_47][i_92];

pa2-p3.c:80: note: init: stmt relevant? _41 = _39 * pretmp_140;

pa2-p3.c:80: note: init: stmt relevant? _42 = _38 + _41;

pa2-p3.c:80: note: init: stmt relevant? c[j_68][i_92] = _42;

pa2-p3.c:80: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: init: stmt relevant? _45 = c[pretmp_137][i_92];

pa2-p3.c:80: note: init: stmt relevant? _49 = _39 * pretmp_143;

pa2-p3.c:80: note: init: stmt relevant? _50 = _45 + _49;

pa2-p3.c:80: note: init: stmt relevant? c[pretmp_137][i_92] = _50;

pa2-p3.c:80: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: init: stmt relevant? _53 = c[pretmp_138][i_92];

pa2-p3.c:80: note: init: stmt relevant? _57 = _39 * pretmp_145;

pa2-p3.c:80: note: init: stmt relevant? _58 = _53 + _57;

pa2-p3.c:80: note: init: stmt relevant? c[pretmp_138][i_92] = _58;

pa2-p3.c:80: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: init: stmt relevant? _61 = c[pretmp_139][i_92];

pa2-p3.c:80: note: init: stmt relevant? _64 = _39 * pretmp_147;

pa2-p3.c:80: note: init: stmt relevant? _65 = _61 + _64;

pa2-p3.c:80: note: init: stmt relevant? c[pretmp_139][i_92] = _65;

pa2-p3.c:80: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: init: stmt relevant? i_67 = i_92 + 1;

pa2-p3.c:80: note: init: stmt relevant? # DEBUG i => i_67

pa2-p3.c:80: note: init: stmt relevant? # DEBUG i => i_67

pa2-p3.c:80: note: init: stmt relevant? if (i_67 != 2000)

pa2-p3.c:80: note: worklist: examine stmt: c[pretmp_139][i_92] = _65;

pa2-p3.c:80: note: vect_is_simple_use: operand _65
pa2-p3.c:80: note: def_stmt: _65 = _61 + _64;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: worklist: examine stmt: _65 = _61 + _64;

pa2-p3.c:80: note: vect_is_simple_use: operand _61
pa2-p3.c:80: note: def_stmt: _61 = c[pretmp_139][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: vect_is_simple_use: operand _64
pa2-p3.c:80: note: def_stmt: _64 = _39 * pretmp_147;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: worklist: examine stmt: _64 = _39 * pretmp_147;

pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_147
pa2-p3.c:80: note: def_stmt: pretmp_147 = b[i_47][pretmp_139];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: def_stmt is out of loop.
pa2-p3.c:80: note: worklist: examine stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: worklist: examine stmt: _61 = c[pretmp_139][i_92];

pa2-p3.c:80: note: worklist: examine stmt: c[pretmp_138][i_92] = _58;

pa2-p3.c:80: note: vect_is_simple_use: operand _58
pa2-p3.c:80: note: def_stmt: _58 = _53 + _57;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: worklist: examine stmt: _58 = _53 + _57;

pa2-p3.c:80: note: vect_is_simple_use: operand _53
pa2-p3.c:80: note: def_stmt: _53 = c[pretmp_138][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: vect_is_simple_use: operand _57
pa2-p3.c:80: note: def_stmt: _57 = _39 * pretmp_145;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: worklist: examine stmt: _57 = _39 * pretmp_145;

pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: already marked relevant/live.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_145
pa2-p3.c:80: note: def_stmt: pretmp_145 = b[i_47][pretmp_138];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: def_stmt is out of loop.
pa2-p3.c:80: note: worklist: examine stmt: _53 = c[pretmp_138][i_92];

pa2-p3.c:80: note: worklist: examine stmt: c[pretmp_137][i_92] = _50;

pa2-p3.c:80: note: vect_is_simple_use: operand _50
pa2-p3.c:80: note: def_stmt: _50 = _45 + _49;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: worklist: examine stmt: _50 = _45 + _49;

pa2-p3.c:80: note: vect_is_simple_use: operand _45
pa2-p3.c:80: note: def_stmt: _45 = c[pretmp_137][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: vect_is_simple_use: operand _49
pa2-p3.c:80: note: def_stmt: _49 = _39 * pretmp_143;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: worklist: examine stmt: _49 = _39 * pretmp_143;

pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: already marked relevant/live.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_143
pa2-p3.c:80: note: def_stmt: pretmp_143 = b[i_47][pretmp_137];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: def_stmt is out of loop.
pa2-p3.c:80: note: worklist: examine stmt: _45 = c[pretmp_137][i_92];

pa2-p3.c:80: note: worklist: examine stmt: c[j_68][i_92] = _42;

pa2-p3.c:80: note: vect_is_simple_use: operand _42
pa2-p3.c:80: note: def_stmt: _42 = _38 + _41;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: worklist: examine stmt: _42 = _38 + _41;

pa2-p3.c:80: note: vect_is_simple_use: operand _38
pa2-p3.c:80: note: def_stmt: _38 = c[j_68][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: vect_is_simple_use: operand _41
pa2-p3.c:80: note: def_stmt: _41 = _39 * pretmp_140;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: worklist: examine stmt: _41 = _39 * pretmp_140;

pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: mark relevant 4, live 0.
pa2-p3.c:80: note: already marked relevant/live.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_140
pa2-p3.c:80: note: def_stmt: pretmp_140 = b[i_47][j_68];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: def_stmt is out of loop.
pa2-p3.c:80: note: worklist: examine stmt: _38 = c[j_68][i_92];

pa2-p3.c:80: note: === vect_analyze_dependences ===
pa2-p3.c:80: note: dependence distance  = 0.
pa2-p3.c:80: note: dependence distance == 0 between c[j_68][i_92] and c[j_68][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[j_68][i_92] and c[pretmp_137][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[j_68][i_92] and c[pretmp_137][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[j_68][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[j_68][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[j_68][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[j_68][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[j_68][i_92] and c[pretmp_137][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[j_68][i_92] and c[pretmp_137][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[j_68][i_92] and c[pretmp_137][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[j_68][i_92] and c[pretmp_137][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[j_68][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[j_68][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[j_68][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[j_68][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[j_68][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[j_68][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[j_68][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[j_68][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: dependence distance  = 0.
pa2-p3.c:80: note: dependence distance == 0 between c[pretmp_137][i_92] and c[pretmp_137][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[pretmp_137][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[pretmp_137][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[pretmp_137][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[pretmp_137][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[pretmp_137][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[pretmp_137][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[pretmp_137][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[pretmp_137][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[pretmp_137][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[pretmp_137][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[pretmp_137][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[pretmp_137][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: dependence distance  = 0.
pa2-p3.c:80: note: dependence distance == 0 between c[pretmp_138][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[pretmp_138][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[pretmp_138][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[pretmp_138][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[pretmp_138][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: versioning for alias required: can't determine dependence between c[pretmp_138][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: mark for run-time aliasing test between c[pretmp_138][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: dependence distance  = 0.
pa2-p3.c:80: note: dependence distance == 0 between c[pretmp_139][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: === vect_determine_vectorization_factor ===
pa2-p3.c:80: note: ==> examining phi: i_92 = PHI <i_67(25), i_37(23)>

pa2-p3.c:80: note: ==> examining phi: .MEM_81 = PHI <.MEM_66(25), .MEM_97(23)>

pa2-p3.c:80: note: ==> examining statement: # DEBUG i => i_92

pa2-p3.c:80: note: skip.
pa2-p3.c:80: note: ==> examining statement: _38 = c[j_68][i_92];

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _39 = a[i_47][i_92];

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _41 = _39 * pretmp_140;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _42 = _38 + _41;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: c[j_68][i_92] = _42;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _45 = c[pretmp_137][i_92];

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _49 = _39 * pretmp_143;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _50 = _45 + _49;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: c[pretmp_137][i_92] = _50;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _53 = c[pretmp_138][i_92];

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _57 = _39 * pretmp_145;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _58 = _53 + _57;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: c[pretmp_138][i_92] = _58;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _61 = c[pretmp_139][i_92];

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _64 = _39 * pretmp_147;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: _65 = _61 + _64;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: c[pretmp_139][i_92] = _65;

pa2-p3.c:80: note: get vectype for scalar type:  float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: nunits = 4
pa2-p3.c:80: note: ==> examining statement: i_67 = i_92 + 1;

pa2-p3.c:80: note: skip.
pa2-p3.c:80: note: ==> examining statement: # DEBUG i => i_67

pa2-p3.c:80: note: skip.
pa2-p3.c:80: note: ==> examining statement: # DEBUG i => i_67

pa2-p3.c:80: note: skip.
pa2-p3.c:80: note: ==> examining statement: if (i_67 != 2000)

pa2-p3.c:80: note: skip.
pa2-p3.c:80: note: vectorization factor = 4
pa2-p3.c:80: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:80: note: dependence distance  = 0.
pa2-p3.c:80: note: accesses have the same alignment.dependence distance modulo vf == 0 between c[j_68][i_92] and c[j_68][i_92]
pa2-p3.c:80: note: dependence distance  = 0.
pa2-p3.c:80: note: accesses have the same alignment.dependence distance modulo vf == 0 between c[pretmp_137][i_92] and c[pretmp_137][i_92]
pa2-p3.c:80: note: dependence distance  = 0.
pa2-p3.c:80: note: accesses have the same alignment.dependence distance modulo vf == 0 between c[pretmp_138][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: dependence distance  = 0.
pa2-p3.c:80: note: accesses have the same alignment.dependence distance modulo vf == 0 between c[pretmp_139][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: c
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: a
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: c
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: c
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: c
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: c
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: c
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: c
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: c
pa2-p3.c:80: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:80: note: === vect_prune_runtime_alias_test_list ===
pa2-p3.c:80: note: found equal ranges c[j_68][i_92], c[pretmp_137][i_92] and c[j_68][i_92], c[pretmp_137][i_92]
pa2-p3.c:80: note: found equal ranges c[j_68][i_92], c[pretmp_137][i_92] and c[j_68][i_92], c[pretmp_137][i_92]
pa2-p3.c:80: note: found equal ranges c[j_68][i_92], c[pretmp_138][i_92] and c[j_68][i_92], c[pretmp_138][i_92]
pa2-p3.c:80: note: found equal ranges c[j_68][i_92], c[pretmp_138][i_92] and c[j_68][i_92], c[pretmp_138][i_92]
pa2-p3.c:80: note: found equal ranges c[j_68][i_92], c[pretmp_139][i_92] and c[j_68][i_92], c[pretmp_139][i_92]
pa2-p3.c:80: note: found equal ranges c[j_68][i_92], c[pretmp_139][i_92] and c[j_68][i_92], c[pretmp_139][i_92]
pa2-p3.c:80: note: found equal ranges c[pretmp_137][i_92], c[pretmp_138][i_92] and c[pretmp_137][i_92], c[pretmp_138][i_92]
pa2-p3.c:80: note: found equal ranges c[pretmp_137][i_92], c[pretmp_138][i_92] and c[pretmp_137][i_92], c[pretmp_138][i_92]
pa2-p3.c:80: note: found equal ranges c[pretmp_137][i_92], c[pretmp_139][i_92] and c[pretmp_137][i_92], c[pretmp_139][i_92]
pa2-p3.c:80: note: found equal ranges c[pretmp_137][i_92], c[pretmp_139][i_92] and c[pretmp_137][i_92], c[pretmp_139][i_92]
pa2-p3.c:80: note: found equal ranges c[pretmp_138][i_92], c[pretmp_139][i_92] and c[pretmp_138][i_92], c[pretmp_139][i_92]
pa2-p3.c:80: note: found equal ranges c[pretmp_138][i_92], c[pretmp_139][i_92] and c[pretmp_138][i_92], c[pretmp_139][i_92]
pa2-p3.c:80: note: === vect_enhance_data_refs_alignment ===
pa2-p3.c:80: note: Unknown misalignment, is_packed = 0
pa2-p3.c:80: note: Unknown misalignment, is_packed = 0
pa2-p3.c:80: note: Unknown misalignment, is_packed = 0
pa2-p3.c:80: note: Unknown misalignment, is_packed = 0
pa2-p3.c:80: note: Unknown misalignment, is_packed = 0
pa2-p3.c:80: note: Unknown misalignment, is_packed = 0
pa2-p3.c:80: note: Unknown misalignment, is_packed = 0
pa2-p3.c:80: note: Unknown misalignment, is_packed = 0
pa2-p3.c:80: note: Unknown misalignment, is_packed = 0
pa2-p3.c:80: note: Vectorizing an unaligned access.
pa2-p3.c:80: note: Vectorizing an unaligned access.
pa2-p3.c:80: note: Vectorizing an unaligned access.
pa2-p3.c:80: note: Vectorizing an unaligned access.
pa2-p3.c:80: note: Vectorizing an unaligned access.
pa2-p3.c:80: note: Vectorizing an unaligned access.
pa2-p3.c:80: note: Vectorizing an unaligned access.
pa2-p3.c:80: note: Vectorizing an unaligned access.
pa2-p3.c:80: note: Vectorizing an unaligned access.
pa2-p3.c:80: note: === vect_analyze_slp ===
pa2-p3.c:80: note: === vect_make_slp_decision ===
pa2-p3.c:80: note: === vect_detect_hybrid_slp ===
pa2-p3.c:80: note: === vect_analyze_loop_operations ===
pa2-p3.c:80: note: examining phi: i_92 = PHI <i_67(25), i_37(23)>

pa2-p3.c:80: note: examining phi: .MEM_81 = PHI <.MEM_66(25), .MEM_97(23)>

pa2-p3.c:80: note: ==> examining statement: # DEBUG i => i_92

pa2-p3.c:80: note: irrelevant.
pa2-p3.c:80: note: ==> examining statement: _38 = c[j_68][i_92];

pa2-p3.c:80: note: num. args = 4 (not unary/binary/ternary op).
pa2-p3.c:80: note: vect_is_simple_use: operand c[j_68][i_92]
pa2-p3.c:80: note: not ssa-name.
pa2-p3.c:80: note: use not simple.
pa2-p3.c:80: note: vect_model_load_cost: unaligned supported by hardware.
pa2-p3.c:80: note: vect_model_load_cost: inside_cost = 2, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: _39 = a[i_47][i_92];

pa2-p3.c:80: note: num. args = 4 (not unary/binary/ternary op).
pa2-p3.c:80: note: vect_is_simple_use: operand a[i_47][i_92]
pa2-p3.c:80: note: not ssa-name.
pa2-p3.c:80: note: use not simple.
pa2-p3.c:80: note: vect_model_load_cost: unaligned supported by hardware.
pa2-p3.c:80: note: vect_model_load_cost: inside_cost = 2, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: _41 = _39 * pretmp_140;

pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_140
pa2-p3.c:80: note: def_stmt: pretmp_140 = b[i_47][j_68];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: === vectorizable_operation ===
pa2-p3.c:80: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p3.c:80: note: ==> examining statement: _42 = _38 + _41;

pa2-p3.c:80: note: vect_is_simple_use: operand _38
pa2-p3.c:80: note: def_stmt: _38 = c[j_68][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _41
pa2-p3.c:80: note: def_stmt: _41 = _39 * pretmp_140;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: === vectorizable_operation ===
pa2-p3.c:80: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: c[j_68][i_92] = _42;

pa2-p3.c:80: note: vect_is_simple_use: operand _42
pa2-p3.c:80: note: def_stmt: _42 = _38 + _41;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_model_store_cost: unaligned supported by hardware.
pa2-p3.c:80: note: vect_model_store_cost: inside_cost = 2, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: _45 = c[pretmp_137][i_92];

pa2-p3.c:80: note: num. args = 4 (not unary/binary/ternary op).
pa2-p3.c:80: note: vect_is_simple_use: operand c[pretmp_137][i_92]
pa2-p3.c:80: note: not ssa-name.
pa2-p3.c:80: note: use not simple.
pa2-p3.c:80: note: vect_model_load_cost: unaligned supported by hardware.
pa2-p3.c:80: note: vect_model_load_cost: inside_cost = 2, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: _49 = _39 * pretmp_143;

pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_143
pa2-p3.c:80: note: def_stmt: pretmp_143 = b[i_47][pretmp_137];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: === vectorizable_operation ===
pa2-p3.c:80: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p3.c:80: note: ==> examining statement: _50 = _45 + _49;

pa2-p3.c:80: note: vect_is_simple_use: operand _45
pa2-p3.c:80: note: def_stmt: _45 = c[pretmp_137][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _49
pa2-p3.c:80: note: def_stmt: _49 = _39 * pretmp_143;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: === vectorizable_operation ===
pa2-p3.c:80: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: c[pretmp_137][i_92] = _50;

pa2-p3.c:80: note: vect_is_simple_use: operand _50
pa2-p3.c:80: note: def_stmt: _50 = _45 + _49;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_model_store_cost: unaligned supported by hardware.
pa2-p3.c:80: note: vect_model_store_cost: inside_cost = 2, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: _53 = c[pretmp_138][i_92];

pa2-p3.c:80: note: num. args = 4 (not unary/binary/ternary op).
pa2-p3.c:80: note: vect_is_simple_use: operand c[pretmp_138][i_92]
pa2-p3.c:80: note: not ssa-name.
pa2-p3.c:80: note: use not simple.
pa2-p3.c:80: note: vect_model_load_cost: unaligned supported by hardware.
pa2-p3.c:80: note: vect_model_load_cost: inside_cost = 2, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: _57 = _39 * pretmp_145;

pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_145
pa2-p3.c:80: note: def_stmt: pretmp_145 = b[i_47][pretmp_138];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: === vectorizable_operation ===
pa2-p3.c:80: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p3.c:80: note: ==> examining statement: _58 = _53 + _57;

pa2-p3.c:80: note: vect_is_simple_use: operand _53
pa2-p3.c:80: note: def_stmt: _53 = c[pretmp_138][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _57
pa2-p3.c:80: note: def_stmt: _57 = _39 * pretmp_145;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: === vectorizable_operation ===
pa2-p3.c:80: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: c[pretmp_138][i_92] = _58;

pa2-p3.c:80: note: vect_is_simple_use: operand _58
pa2-p3.c:80: note: def_stmt: _58 = _53 + _57;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_model_store_cost: unaligned supported by hardware.
pa2-p3.c:80: note: vect_model_store_cost: inside_cost = 2, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: _61 = c[pretmp_139][i_92];

pa2-p3.c:80: note: num. args = 4 (not unary/binary/ternary op).
pa2-p3.c:80: note: vect_is_simple_use: operand c[pretmp_139][i_92]
pa2-p3.c:80: note: not ssa-name.
pa2-p3.c:80: note: use not simple.
pa2-p3.c:80: note: vect_model_load_cost: unaligned supported by hardware.
pa2-p3.c:80: note: vect_model_load_cost: inside_cost = 2, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: _64 = _39 * pretmp_147;

pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_147
pa2-p3.c:80: note: def_stmt: pretmp_147 = b[i_47][pretmp_139];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: === vectorizable_operation ===
pa2-p3.c:80: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p3.c:80: note: ==> examining statement: _65 = _61 + _64;

pa2-p3.c:80: note: vect_is_simple_use: operand _61
pa2-p3.c:80: note: def_stmt: _61 = c[pretmp_139][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _64
pa2-p3.c:80: note: def_stmt: _64 = _39 * pretmp_147;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: === vectorizable_operation ===
pa2-p3.c:80: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: c[pretmp_139][i_92] = _65;

pa2-p3.c:80: note: vect_is_simple_use: operand _65
pa2-p3.c:80: note: def_stmt: _65 = _61 + _64;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_model_store_cost: unaligned supported by hardware.
pa2-p3.c:80: note: vect_model_store_cost: inside_cost = 2, prologue_cost = 0 .
pa2-p3.c:80: note: ==> examining statement: i_67 = i_92 + 1;

pa2-p3.c:80: note: irrelevant.
pa2-p3.c:80: note: ==> examining statement: # DEBUG i => i_67

pa2-p3.c:80: note: irrelevant.
pa2-p3.c:80: note: ==> examining statement: # DEBUG i => i_67

pa2-p3.c:80: note: irrelevant.
pa2-p3.c:80: note: ==> examining statement: if (i_67 != 2000)

pa2-p3.c:80: note: irrelevant.
pa2-p3.c:80: note: === vect_update_slp_costs_according_to_vf ===cost model: Adding cost of checks for loop versioning aliasing.

pa2-p3.c:80: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
pa2-p3.c:80: note: Cost model analysis: 
  Vector inside of loop cost: 26
  Vector prologue cost: 19
  Vector epilogue cost: 34
  Scalar iteration cost: 17
  Scalar outside cost: 1
  Vector outside cost: 53
  prologue iterations: 0
  epilogue iterations: 2
  Calculated minimum iters for profitability: 4

pa2-p3.c:80: note:   Runtime profitability threshold = 3

pa2-p3.c:80: note:   Static estimate profitability threshold = 3

pa2-p3.c:80: note: epilog loop required.
pa2-p3.c:80: note: vect_can_advance_ivs_p:
pa2-p3.c:80: note: Analyze phi: i_92 = PHI <i_67(25), i_37(23)>

pa2-p3.c:80: note: Access function of PHI: {i_37, +, 1}_6
pa2-p3.c:80: note: Analyze phi: .MEM_81 = PHI <.MEM_66(25), .MEM_97(23)>

pa2-p3.c:80: note: virtual phi. skip.

Vectorizing loop at pa2-p3.c:80

pa2-p3.c:80: note: === vec_transform_loop ===
pa2-p3.c:80: note: Profitability threshold is 3 loop iterations.
pa2-p3.c:80: note: created vect_pc.44_178
pa2-p3.c:80: note: created vect_pc.47_185
pa2-p3.c:80: note: create runtime check for data references c[j_68][i_92] and c[pretmp_137][i_92]
pa2-p3.c:80: note: created vect_pc.50_192
pa2-p3.c:80: note: created vect_pc.53_199
pa2-p3.c:80: note: create runtime check for data references c[j_68][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: created vect_pc.56_206
pa2-p3.c:80: note: created vect_pc.59_213
pa2-p3.c:80: note: create runtime check for data references c[j_68][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: created vect_pc.62_220
pa2-p3.c:80: note: created vect_pc.65_227
pa2-p3.c:80: note: create runtime check for data references c[pretmp_137][i_92] and c[pretmp_138][i_92]
pa2-p3.c:80: note: created vect_pc.68_234
pa2-p3.c:80: note: created vect_pc.71_241
pa2-p3.c:80: note: create runtime check for data references c[pretmp_137][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: created vect_pc.74_248
pa2-p3.c:80: note: created vect_pc.77_255
pa2-p3.c:80: note: create runtime check for data references c[pretmp_138][i_92] and c[pretmp_139][i_92]
pa2-p3.c:80: note: created 6 versioning for alias checks.

pa2-p3.c:80: note: === vect_do_peeling_for_loop_bound ===
pa2-p3.c:80: note: vect_update_ivs_after_vectorizer: phi: i_92 = PHI <i_67(25), i_37(65)>

pa2-p3.c:80: note: vect_update_ivs_after_vectorizer: phi: .MEM_81 = PHI <.MEM_66(25), .MEM_97(65)>

pa2-p3.c:80: note: virtual phi. skip.Setting upper bound of nb iterations for epilogue loop to 2

pa2-p3.c:80: note: ------>vectorizing phi: i_92 = PHI <i_67(25), i_37(69)>

pa2-p3.c:80: note: ------>vectorizing phi: .MEM_81 = PHI <.MEM_66(25), .MEM_97(69)>

pa2-p3.c:80: note: ------>vectorizing statement: # DEBUG i => i_92

pa2-p3.c:80: note: ------>vectorizing statement: _38 = c[j_68][i_92];

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: transform load. ncopies = 1
pa2-p3.c:80: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:80: note: created vect_pc.85_352
pa2-p3.c:80: note: add new stmt: vect_var_.86_355 = MEM[(float[2000][2000] *)vect_pc.82_353];

pa2-p3.c:80: note: ------>vectorizing statement: _39 = a[i_47][i_92];

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: transform load. ncopies = 1
pa2-p3.c:80: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: a
pa2-p3.c:80: note: created vect_pa.90_359
pa2-p3.c:80: note: add new stmt: vect_var_.91_362 = MEM[(float[2000][2000] *)vect_pa.87_360];

pa2-p3.c:80: note: ------>vectorizing statement: _41 = _39 * pretmp_140;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_140
pa2-p3.c:80: note: def_stmt: pretmp_140 = b[i_47][j_68];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: transform binary/unary operation.
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _39
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _39  def_stmt =  _39 = a[i_47][i_92];

pa2-p3.c:80: note: vect_get_vec_def_for_operand: pretmp_140
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_140
pa2-p3.c:80: note: def_stmt: pretmp_140 = b[i_47][j_68];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: def =  pretmp_140  def_stmt =  pretmp_140 = b[i_47][j_68];

pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: Create vector_inv.
pa2-p3.c:80: note: created new init_stmt: vect_cst_.93_363 = {pretmp_140, pretmp_140, pretmp_140, pretmp_140};

pa2-p3.c:80: note: add new stmt: vect_var_.92_364 = vect_var_.91_362 * vect_cst_.93_363;

pa2-p3.c:80: note: ------>vectorizing statement: _42 = _38 + _41;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _38
pa2-p3.c:80: note: def_stmt: _38 = c[j_68][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _41
pa2-p3.c:80: note: def_stmt: _41 = _39 * pretmp_140;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: transform binary/unary operation.
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _38
pa2-p3.c:80: note: vect_is_simple_use: operand _38
pa2-p3.c:80: note: def_stmt: _38 = c[j_68][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _38  def_stmt =  _38 = c[j_68][i_92];

pa2-p3.c:80: note: vect_get_vec_def_for_operand: _41
pa2-p3.c:80: note: vect_is_simple_use: operand _41
pa2-p3.c:80: note: def_stmt: _41 = _39 * pretmp_140;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _41  def_stmt =  _41 = _39 * pretmp_140;

pa2-p3.c:80: note: add new stmt: vect_var_.94_365 = vect_var_.86_355 + vect_var_.92_364;

pa2-p3.c:80: note: ------>vectorizing statement: c[j_68][i_92] = _42;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _42
pa2-p3.c:80: note: def_stmt: _42 = _38 + _41;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: transform store. ncopies = 1
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _42
pa2-p3.c:80: note: vect_is_simple_use: operand _42
pa2-p3.c:80: note: def_stmt: _42 = _38 + _41;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _42  def_stmt =  _42 = _38 + _41;

pa2-p3.c:80: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:80: note: created vect_pc.98_372
pa2-p3.c:80: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.95_373] = vect_var_.94_365;

pa2-p3.c:80: note: ------>vectorizing statement: _45 = c[pretmp_137][i_92];

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: transform load. ncopies = 1
pa2-p3.c:80: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:80: note: created vect_pc.102_381
pa2-p3.c:80: note: add new stmt: vect_var_.103_384 = MEM[(float[2000][2000] *)vect_pc.99_382];

pa2-p3.c:80: note: ------>vectorizing statement: _49 = _39 * pretmp_143;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_143
pa2-p3.c:80: note: def_stmt: pretmp_143 = b[i_47][pretmp_137];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: transform binary/unary operation.
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _39
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _39  def_stmt =  _39 = a[i_47][i_92];

pa2-p3.c:80: note: vect_get_vec_def_for_operand: pretmp_143
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_143
pa2-p3.c:80: note: def_stmt: pretmp_143 = b[i_47][pretmp_137];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: def =  pretmp_143  def_stmt =  pretmp_143 = b[i_47][pretmp_137];

pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: Create vector_inv.
pa2-p3.c:80: note: created new init_stmt: vect_cst_.105_385 = {pretmp_143, pretmp_143, pretmp_143, pretmp_143};

pa2-p3.c:80: note: add new stmt: vect_var_.104_386 = vect_var_.91_362 * vect_cst_.105_385;

pa2-p3.c:80: note: ------>vectorizing statement: _50 = _45 + _49;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _45
pa2-p3.c:80: note: def_stmt: _45 = c[pretmp_137][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _49
pa2-p3.c:80: note: def_stmt: _49 = _39 * pretmp_143;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: transform binary/unary operation.
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _45
pa2-p3.c:80: note: vect_is_simple_use: operand _45
pa2-p3.c:80: note: def_stmt: _45 = c[pretmp_137][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _45  def_stmt =  _45 = c[pretmp_137][i_92];

pa2-p3.c:80: note: vect_get_vec_def_for_operand: _49
pa2-p3.c:80: note: vect_is_simple_use: operand _49
pa2-p3.c:80: note: def_stmt: _49 = _39 * pretmp_143;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _49  def_stmt =  _49 = _39 * pretmp_143;

pa2-p3.c:80: note: add new stmt: vect_var_.106_387 = vect_var_.103_384 + vect_var_.104_386;

pa2-p3.c:80: note: ------>vectorizing statement: c[pretmp_137][i_92] = _50;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _50
pa2-p3.c:80: note: def_stmt: _50 = _45 + _49;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: transform store. ncopies = 1
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _50
pa2-p3.c:80: note: vect_is_simple_use: operand _50
pa2-p3.c:80: note: def_stmt: _50 = _45 + _49;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _50  def_stmt =  _50 = _45 + _49;

pa2-p3.c:80: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:80: note: created vect_pc.110_394
pa2-p3.c:80: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.107_395] = vect_var_.106_387;

pa2-p3.c:80: note: ------>vectorizing statement: _53 = c[pretmp_138][i_92];

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: transform load. ncopies = 1
pa2-p3.c:80: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:80: note: created vect_pc.114_403
pa2-p3.c:80: note: add new stmt: vect_var_.115_406 = MEM[(float[2000][2000] *)vect_pc.111_404];

pa2-p3.c:80: note: ------>vectorizing statement: _57 = _39 * pretmp_145;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_145
pa2-p3.c:80: note: def_stmt: pretmp_145 = b[i_47][pretmp_138];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: transform binary/unary operation.
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _39
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _39  def_stmt =  _39 = a[i_47][i_92];

pa2-p3.c:80: note: vect_get_vec_def_for_operand: pretmp_145
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_145
pa2-p3.c:80: note: def_stmt: pretmp_145 = b[i_47][pretmp_138];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: def =  pretmp_145  def_stmt =  pretmp_145 = b[i_47][pretmp_138];

pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: Create vector_inv.
pa2-p3.c:80: note: created new init_stmt: vect_cst_.117_407 = {pretmp_145, pretmp_145, pretmp_145, pretmp_145};

pa2-p3.c:80: note: add new stmt: vect_var_.116_408 = vect_var_.91_362 * vect_cst_.117_407;

pa2-p3.c:80: note: ------>vectorizing statement: _58 = _53 + _57;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _53
pa2-p3.c:80: note: def_stmt: _53 = c[pretmp_138][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _57
pa2-p3.c:80: note: def_stmt: _57 = _39 * pretmp_145;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: transform binary/unary operation.
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _53
pa2-p3.c:80: note: vect_is_simple_use: operand _53
pa2-p3.c:80: note: def_stmt: _53 = c[pretmp_138][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _53  def_stmt =  _53 = c[pretmp_138][i_92];

pa2-p3.c:80: note: vect_get_vec_def_for_operand: _57
pa2-p3.c:80: note: vect_is_simple_use: operand _57
pa2-p3.c:80: note: def_stmt: _57 = _39 * pretmp_145;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _57  def_stmt =  _57 = _39 * pretmp_145;

pa2-p3.c:80: note: add new stmt: vect_var_.118_409 = vect_var_.115_406 + vect_var_.116_408;

pa2-p3.c:80: note: ------>vectorizing statement: c[pretmp_138][i_92] = _58;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _58
pa2-p3.c:80: note: def_stmt: _58 = _53 + _57;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: transform store. ncopies = 1
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _58
pa2-p3.c:80: note: vect_is_simple_use: operand _58
pa2-p3.c:80: note: def_stmt: _58 = _53 + _57;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _58  def_stmt =  _58 = _53 + _57;

pa2-p3.c:80: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:80: note: created vect_pc.122_416
pa2-p3.c:80: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.119_417] = vect_var_.118_409;

pa2-p3.c:80: note: ------>vectorizing statement: _61 = c[pretmp_139][i_92];

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: transform load. ncopies = 1
pa2-p3.c:80: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:80: note: created vect_pc.126_425
pa2-p3.c:80: note: add new stmt: vect_var_.127_428 = MEM[(float[2000][2000] *)vect_pc.123_426];

pa2-p3.c:80: note: ------>vectorizing statement: _64 = _39 * pretmp_147;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_147
pa2-p3.c:80: note: def_stmt: pretmp_147 = b[i_47][pretmp_139];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: transform binary/unary operation.
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _39
pa2-p3.c:80: note: vect_is_simple_use: operand _39
pa2-p3.c:80: note: def_stmt: _39 = a[i_47][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _39  def_stmt =  _39 = a[i_47][i_92];

pa2-p3.c:80: note: vect_get_vec_def_for_operand: pretmp_147
pa2-p3.c:80: note: vect_is_simple_use: operand pretmp_147
pa2-p3.c:80: note: def_stmt: pretmp_147 = b[i_47][pretmp_139];

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: def =  pretmp_147  def_stmt =  pretmp_147 = b[i_47][pretmp_139];

pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: Create vector_inv.
pa2-p3.c:80: note: created new init_stmt: vect_cst_.129_429 = {pretmp_147, pretmp_147, pretmp_147, pretmp_147};

pa2-p3.c:80: note: add new stmt: vect_var_.128_430 = vect_var_.91_362 * vect_cst_.129_429;

pa2-p3.c:80: note: ------>vectorizing statement: _65 = _61 + _64;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _61
pa2-p3.c:80: note: def_stmt: _61 = c[pretmp_139][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _64
pa2-p3.c:80: note: def_stmt: _64 = _39 * pretmp_147;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: transform binary/unary operation.
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _61
pa2-p3.c:80: note: vect_is_simple_use: operand _61
pa2-p3.c:80: note: def_stmt: _61 = c[pretmp_139][i_92];

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _61  def_stmt =  _61 = c[pretmp_139][i_92];

pa2-p3.c:80: note: vect_get_vec_def_for_operand: _64
pa2-p3.c:80: note: vect_is_simple_use: operand _64
pa2-p3.c:80: note: def_stmt: _64 = _39 * pretmp_147;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _64  def_stmt =  _64 = _39 * pretmp_147;

pa2-p3.c:80: note: add new stmt: vect_var_.130_431 = vect_var_.127_428 + vect_var_.128_430;

pa2-p3.c:80: note: ------>vectorizing statement: c[pretmp_139][i_92] = _65;

pa2-p3.c:80: note: transform statement.
pa2-p3.c:80: note: vect_is_simple_use: operand _65
pa2-p3.c:80: note: def_stmt: _65 = _61 + _64;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: transform store. ncopies = 1
pa2-p3.c:80: note: vect_get_vec_def_for_operand: _65
pa2-p3.c:80: note: vect_is_simple_use: operand _65
pa2-p3.c:80: note: def_stmt: _65 = _61 + _64;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: def =  _65  def_stmt =  _65 = _61 + _64;

pa2-p3.c:80: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:80: note: created vect_pc.134_438
pa2-p3.c:80: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.131_439] = vect_var_.130_431;

pa2-p3.c:80: note: ------>vectorizing statement: i_67 = i_92 + 1;

pa2-p3.c:80: note: ------>vectorizing statement: # DEBUG i => i_67

pa2-p3.c:80: note: ------>vectorizing statement: # DEBUG i => i_67

pa2-p3.c:80: note: ------>vectorizing statement: vect_pc.82_354 = vect_pc.82_353 + 16;

pa2-p3.c:80: note: ------>vectorizing statement: vect_pa.87_361 = vect_pa.87_360 + 16;

pa2-p3.c:80: note: ------>vectorizing statement: vect_pc.95_374 = vect_pc.95_373 + 16;

pa2-p3.c:80: note: ------>vectorizing statement: vect_pc.99_383 = vect_pc.99_382 + 16;

pa2-p3.c:80: note: ------>vectorizing statement: vect_pc.107_396 = vect_pc.107_395 + 16;

pa2-p3.c:80: note: ------>vectorizing statement: vect_pc.111_405 = vect_pc.111_404 + 16;

pa2-p3.c:80: note: ------>vectorizing statement: vect_pc.119_418 = vect_pc.119_417 + 16;

pa2-p3.c:80: note: ------>vectorizing statement: vect_pc.123_427 = vect_pc.123_426 + 16;

pa2-p3.c:80: note: ------>vectorizing statement: vect_pc.131_440 = vect_pc.131_439 + 16;

pa2-p3.c:80: note: ------>vectorizing statement: if (i_67 != 2000)

loop at pa2-p3.c:81: if (ivtmp_442 < bnd.79_315)

pa2-p3.c:80: note: LOOP VECTORIZED.
pa2-p3.c:65: note: vectorized 2 loops in function.

pa2-p3.c:74: note: Completely unroll loop 2 times

pa2-p3.c:65: note: Completely unroll loop 3 times

pa2-p3.c:80: note: Completely unroll loop 2 times

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: get vectype with 2 units of type long int
pa2-p3.c:65: note: vectype: vector(2) long int
pa2-p3.c:65: note: get vectype with 2 units of type long int
pa2-p3.c:65: note: vectype: vector(2) long int
pa2-p3.c:65: note: === vect_pattern_recog ===
pa2-p3.c:65: note: === vect_analyze_dependences ===
pa2-p3.c:65: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:65: note: vect_compute_data_ref_alignment:
pa2-p3.c:65: note: force alignment of .istart0.6
pa2-p3.c:65: note: misalign = 0 bytes of ref .istart0.6
pa2-p3.c:65: note: vect_compute_data_ref_alignment:
pa2-p3.c:65: note: force alignment of .iend0.7
pa2-p3.c:65: note: misalign = 0 bytes of ref .iend0.7
pa2-p3.c:65: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:65: note: not consecutive access .istart0.8_25 = .istart0.6;

pa2-p3.c:65: note: not consecutive access .iend0.9_27 = .iend0.7;

pa2-p3.c:65: note: === vect_analyze_slp ===
pa2-p3.c:65: note: Failed to SLP the basic block.
pa2-p3.c:65: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:67: note: ===vect_slp_analyze_bb===

pa2-p3.c:67: note: === vect_analyze_data_refs ===

pa2-p3.c:67: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:67: note: ===vect_slp_analyze_bb===

pa2-p3.c:67: note: === vect_analyze_data_refs ===

pa2-p3.c:67: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:68: note: ===vect_slp_analyze_bb===

pa2-p3.c:68: note: === vect_analyze_data_refs ===

pa2-p3.c:68: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:72: note: ===vect_slp_analyze_bb===

pa2-p3.c:72: note: === vect_analyze_data_refs ===

pa2-p3.c:72: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:78: note: ===vect_slp_analyze_bb===

pa2-p3.c:78: note: === vect_analyze_data_refs ===

pa2-p3.c:78: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:79: note: ===vect_slp_analyze_bb===

pa2-p3.c:79: note: === vect_analyze_data_refs ===

pa2-p3.c:79: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:78: note: ===vect_slp_analyze_bb===

pa2-p3.c:78: note: === vect_analyze_data_refs ===

pa2-p3.c:78: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:80: note: ===vect_slp_analyze_bb===

pa2-p3.c:80: note: === vect_analyze_data_refs ===

pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: get vectype with 4 units of type float
pa2-p3.c:80: note: vectype: vector(4) float
pa2-p3.c:80: note: === vect_pattern_recog ===
pa2-p3.c:80: note: vect_is_simple_use: operand _174
pa2-p3.c:80: note: def_stmt: _174 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _177
pa2-p3.c:80: note: def_stmt: _177 = _176 + 1;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _181
pa2-p3.c:80: note: def_stmt: _181 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _184
pa2-p3.c:80: note: def_stmt: _184 = _183 + 2001;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _188
pa2-p3.c:80: note: def_stmt: _188 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _191
pa2-p3.c:80: note: def_stmt: _191 = _190 + 1;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _195
pa2-p3.c:80: note: def_stmt: _195 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _198
pa2-p3.c:80: note: def_stmt: _198 = _197 + 4001;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _202
pa2-p3.c:80: note: def_stmt: _202 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _205
pa2-p3.c:80: note: def_stmt: _205 = _204 + 1;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _209
pa2-p3.c:80: note: def_stmt: _209 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _212
pa2-p3.c:80: note: def_stmt: _212 = _211 + 6001;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _216
pa2-p3.c:80: note: def_stmt: _216 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _219
pa2-p3.c:80: note: def_stmt: _219 = _218 + 2001;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _223
pa2-p3.c:80: note: def_stmt: _223 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _226
pa2-p3.c:80: note: def_stmt: _226 = _225 + 4001;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _230
pa2-p3.c:80: note: def_stmt: _230 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _233
pa2-p3.c:80: note: def_stmt: _233 = _232 + 2001;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _237
pa2-p3.c:80: note: def_stmt: _237 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _240
pa2-p3.c:80: note: def_stmt: _240 = _239 + 6001;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _244
pa2-p3.c:80: note: def_stmt: _244 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _247
pa2-p3.c:80: note: def_stmt: _247 = _246 + 4001;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand _251
pa2-p3.c:80: note: def_stmt: _251 = (sizetype) j_68;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: vect_is_simple_use: operand j_68
pa2-p3.c:80: note: def_stmt: j_68 = PHI <j_36(20), j_1(15)>

pa2-p3.c:80: note: type of def: 2.
pa2-p3.c:80: note: vect_is_simple_use: operand 2000
pa2-p3.c:80: note: vect_is_simple_use: operand _254
pa2-p3.c:80: note: def_stmt: _254 = _253 + 6001;

pa2-p3.c:80: note: type of def: 3.
pa2-p3.c:80: note: === vect_analyze_dependences ===
pa2-p3.c:80: note: Detected interleaving b[i_47][j_68] and b[i_47][pretmp_137]
pa2-p3.c:80: note: Detected interleaving b[i_47][j_68] and b[i_47][pretmp_138]
pa2-p3.c:80: note: Detected interleaving b[i_47][j_68] and b[i_47][pretmp_139]
pa2-p3.c:80: note: Detected interleaving b[i_47][pretmp_137] and b[i_47][pretmp_138]
pa2-p3.c:80: note: Detected interleaving b[i_47][pretmp_137] and b[i_47][pretmp_139]
pa2-p3.c:80: note: Detected interleaving b[i_47][pretmp_138] and b[i_47][pretmp_139]
pa2-p3.c:80: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: b
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: b
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: b
pa2-p3.c:80: note: vect_compute_data_ref_alignment:
pa2-p3.c:80: note: Unknown alignment for access: b
pa2-p3.c:80: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:80: note: Detected interleaving of size 2000
pa2-p3.c:80: note: === vect_analyze_slp ===
pa2-p3.c:80: note: Failed to SLP the basic block.
pa2-p3.c:80: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:81: note: ===vect_slp_analyze_bb===

pa2-p3.c:81: note: === vect_analyze_data_refs ===

pa2-p3.c:81: note: not vectorized: no vectype for stmt: vect_var_.86_355 = MEM[(float[2000][2000] *)vect_pc.82_353];
 scalar_type: vector(4) float
pa2-p3.c:81: note: === vect_pattern_recog ===
pa2-p3.c:81: note: vect_is_simple_use: operand vect_var_.91_362
pa2-p3.c:81: note: def_stmt: vect_var_.91_362 = MEM[(float[2000][2000] *)vect_pa.87_360];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand vect_var_.91_362
pa2-p3.c:81: note: def_stmt: vect_var_.91_362 = MEM[(float[2000][2000] *)vect_pa.87_360];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand vect_var_.91_362
pa2-p3.c:81: note: def_stmt: vect_var_.91_362 = MEM[(float[2000][2000] *)vect_pa.87_360];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand vect_var_.91_362
pa2-p3.c:81: note: def_stmt: vect_var_.91_362 = MEM[(float[2000][2000] *)vect_pa.87_360];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: === vect_analyze_dependences ===
pa2-p3.c:81: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:81: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:81: note: === vect_analyze_slp ===
pa2-p3.c:81: note: Failed to SLP the basic block.
pa2-p3.c:81: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:81: note: ===vect_slp_analyze_bb===

pa2-p3.c:81: note: === vect_analyze_data_refs ===

pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: === vect_pattern_recog ===
pa2-p3.c:81: note: vect_is_simple_use: operand _321
pa2-p3.c:81: note: def_stmt: _321 = a[i_47][i_318];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _321
pa2-p3.c:81: note: def_stmt: _321 = a[i_47][i_318];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _321
pa2-p3.c:81: note: def_stmt: _321 = a[i_47][i_318];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _321
pa2-p3.c:81: note: def_stmt: _321 = a[i_47][i_318];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: === vect_analyze_dependences ===
pa2-p3.c:81: note: determined dependence between c[j_68][i_318] and c[j_68][i_318]
pa2-p3.c:81: note: Detected interleaving c[j_68][i_318] and c[pretmp_137][i_318]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_318] and c[pretmp_137][i_318]
pa2-p3.c:81: note: Detected interleaving c[j_68][i_318] and c[pretmp_138][i_318]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_318] and c[pretmp_138][i_318]
pa2-p3.c:81: note: Detected interleaving c[j_68][i_318] and c[pretmp_139][i_318]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_318] and c[pretmp_139][i_318]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_318] and c[pretmp_137][i_318]
pa2-p3.c:81: note: not vectorized: unhandled data dependence in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:81: note: ===vect_slp_analyze_bb===

pa2-p3.c:81: note: === vect_analyze_data_refs ===

pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: === vect_pattern_recog ===
pa2-p3.c:81: note: vect_is_simple_use: operand _461
pa2-p3.c:81: note: def_stmt: _461 = a[i_47][i_338];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _461
pa2-p3.c:81: note: def_stmt: _461 = a[i_47][i_338];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _461
pa2-p3.c:81: note: def_stmt: _461 = a[i_47][i_338];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _461
pa2-p3.c:81: note: def_stmt: _461 = a[i_47][i_338];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: === vect_analyze_dependences ===
pa2-p3.c:81: note: determined dependence between c[j_68][i_338] and c[j_68][i_338]
pa2-p3.c:81: note: Detected interleaving c[j_68][i_338] and c[pretmp_137][i_338]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_338] and c[pretmp_137][i_338]
pa2-p3.c:81: note: Detected interleaving c[j_68][i_338] and c[pretmp_138][i_338]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_338] and c[pretmp_138][i_338]
pa2-p3.c:81: note: Detected interleaving c[j_68][i_338] and c[pretmp_139][i_338]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_338] and c[pretmp_139][i_338]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_338] and c[pretmp_137][i_338]
pa2-p3.c:81: note: not vectorized: unhandled data dependence in basic block.

pa2-p3.c:81: note: ===vect_slp_analyze_bb===

pa2-p3.c:81: note: === vect_analyze_data_refs ===

pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: === vect_pattern_recog ===
pa2-p3.c:81: note: vect_is_simple_use: operand _481
pa2-p3.c:81: note: def_stmt: _481 = a[i_47][i_478];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _481
pa2-p3.c:81: note: def_stmt: _481 = a[i_47][i_478];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _481
pa2-p3.c:81: note: def_stmt: _481 = a[i_47][i_478];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _481
pa2-p3.c:81: note: def_stmt: _481 = a[i_47][i_478];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: === vect_analyze_dependences ===
pa2-p3.c:81: note: determined dependence between c[j_68][i_478] and c[j_68][i_478]
pa2-p3.c:81: note: Detected interleaving c[j_68][i_478] and c[pretmp_137][i_478]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_478] and c[pretmp_137][i_478]
pa2-p3.c:81: note: Detected interleaving c[j_68][i_478] and c[pretmp_138][i_478]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_478] and c[pretmp_138][i_478]
pa2-p3.c:81: note: Detected interleaving c[j_68][i_478] and c[pretmp_139][i_478]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_478] and c[pretmp_139][i_478]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_478] and c[pretmp_137][i_478]
pa2-p3.c:81: note: not vectorized: unhandled data dependence in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:81: note: ===vect_slp_analyze_bb===

pa2-p3.c:81: note: === vect_analyze_data_refs ===

pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: get vectype with 4 units of type float
pa2-p3.c:81: note: vectype: vector(4) float
pa2-p3.c:81: note: === vect_pattern_recog ===
pa2-p3.c:81: note: vect_is_simple_use: operand _296
pa2-p3.c:81: note: def_stmt: _296 = a[i_47][i_293];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _296
pa2-p3.c:81: note: def_stmt: _296 = a[i_47][i_293];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _296
pa2-p3.c:81: note: def_stmt: _296 = a[i_47][i_293];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: vect_is_simple_use: operand _296
pa2-p3.c:81: note: def_stmt: _296 = a[i_47][i_293];

pa2-p3.c:81: note: type of def: 3.
pa2-p3.c:81: note: === vect_analyze_dependences ===
pa2-p3.c:81: note: determined dependence between c[j_68][i_293] and c[j_68][i_293]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_293] and c[pretmp_137][i_293]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_293] and c[pretmp_138][i_293]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_293] and c[pretmp_139][i_293]
pa2-p3.c:81: note: can't determine dependence between c[j_68][i_293] and c[pretmp_137][i_293]
pa2-p3.c:81: note: not vectorized: unhandled data dependence in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:74: note: ===vect_slp_analyze_bb===

pa2-p3.c:74: note: === vect_analyze_data_refs ===

pa2-p3.c:74: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: get vectype with 4 units of type float
pa2-p3.c:65: note: vectype: vector(4) float
pa2-p3.c:65: note: === vect_pattern_recog ===
pa2-p3.c:65: note: vect_is_simple_use: operand _56
pa2-p3.c:65: note: def_stmt: _56 = (sizetype) j_18;

pa2-p3.c:65: note: type of def: 3.
pa2-p3.c:65: note: vect_is_simple_use: operand j_18
pa2-p3.c:65: note: def_stmt: j_18 = PHI <j_70(58), j_1(55)>

pa2-p3.c:65: note: type of def: 2.
pa2-p3.c:65: note: vect_is_simple_use: operand 2000
pa2-p3.c:65: note: vect_is_simple_use: operand _75
pa2-p3.c:65: note: def_stmt: _75 = _63 + 1;

pa2-p3.c:65: note: type of def: 3.
pa2-p3.c:65: note: vect_is_simple_use: operand _154
pa2-p3.c:65: note: def_stmt: _154 = (unsigned long) vect_pc.17_72;

pa2-p3.c:65: note: type of def: 3.
pa2-p3.c:65: note: vect_is_simple_use: operand _153
pa2-p3.c:65: note: def_stmt: _153 = _154 & 15;

pa2-p3.c:65: note: type of def: 3.
pa2-p3.c:65: note: vect_is_simple_use: operand _150
pa2-p3.c:65: note: def_stmt: _150 = (unsigned int) _151;

pa2-p3.c:65: note: type of def: 3.
pa2-p3.c:65: note: vect_is_simple_use: operand _151
pa2-p3.c:65: note: def_stmt: _151 = -_152;

pa2-p3.c:65: note: type of def: 3.
pa2-p3.c:65: note: === vect_analyze_dependences ===
pa2-p3.c:65: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:65: note: vect_compute_data_ref_alignment:
pa2-p3.c:65: note: Unknown alignment for access: b
pa2-p3.c:65: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:65: note: not consecutive access pretmp_155 = b[i_82][j_18];

pa2-p3.c:65: note: === vect_analyze_slp ===
pa2-p3.c:65: note: Failed to SLP the basic block.
pa2-p3.c:65: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:75: note: ===vect_slp_analyze_bb===

pa2-p3.c:75: note: === vect_analyze_data_refs ===

pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: === vect_pattern_recog ===
pa2-p3.c:75: note: vect_is_simple_use: operand _53
pa2-p3.c:75: note: def_stmt: _53 = a[i_82][i_317];

pa2-p3.c:75: note: type of def: 3.
pa2-p3.c:75: note: === vect_analyze_dependences ===
pa2-p3.c:75: note: determined dependence between c[j_18][i_317] and c[j_18][i_317]
pa2-p3.c:75: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: a
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:75: note: not consecutive access _53 = a[i_82][i_317];

pa2-p3.c:75: note: === vect_analyze_slp ===
pa2-p3.c:75: note: Failed to SLP the basic block.
pa2-p3.c:75: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:75: note: ===vect_slp_analyze_bb===

pa2-p3.c:75: note: === vect_analyze_data_refs ===

pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: === vect_pattern_recog ===
pa2-p3.c:75: note: vect_is_simple_use: operand _77
pa2-p3.c:75: note: def_stmt: _77 = a[i_82][i_67];

pa2-p3.c:75: note: type of def: 3.
pa2-p3.c:75: note: === vect_analyze_dependences ===
pa2-p3.c:75: note: determined dependence between c[j_18][i_67] and c[j_18][i_67]
pa2-p3.c:75: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: a
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:75: note: not consecutive access _77 = a[i_82][i_67];

pa2-p3.c:75: note: === vect_analyze_slp ===
pa2-p3.c:75: note: Failed to SLP the basic block.
pa2-p3.c:75: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:75: note: ===vect_slp_analyze_bb===

pa2-p3.c:75: note: === vect_analyze_data_refs ===

pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: === vect_pattern_recog ===
pa2-p3.c:75: note: vect_is_simple_use: operand _452
pa2-p3.c:75: note: def_stmt: _452 = a[i_82][i_448];

pa2-p3.c:75: note: type of def: 3.
pa2-p3.c:75: note: === vect_analyze_dependences ===
pa2-p3.c:75: note: determined dependence between c[j_18][i_448] and c[j_18][i_448]
pa2-p3.c:75: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: a
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:75: note: not consecutive access _452 = a[i_82][i_448];

pa2-p3.c:75: note: === vect_analyze_slp ===
pa2-p3.c:75: note: Failed to SLP the basic block.
pa2-p3.c:75: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:75: note: ===vect_slp_analyze_bb===

pa2-p3.c:75: note: === vect_analyze_data_refs ===

pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: === vect_pattern_recog ===
pa2-p3.c:75: note: vect_is_simple_use: operand _133
pa2-p3.c:75: note: def_stmt: _133 = a[i_82][i_136];

pa2-p3.c:75: note: type of def: 3.
pa2-p3.c:75: note: === vect_analyze_dependences ===
pa2-p3.c:75: note: determined dependence between c[j_18][i_136] and c[j_18][i_136]
pa2-p3.c:75: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: a
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:75: note: not consecutive access _133 = a[i_82][i_136];

pa2-p3.c:75: note: === vect_analyze_slp ===
pa2-p3.c:75: note: Failed to SLP the basic block.
pa2-p3.c:75: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:75: note: ===vect_slp_analyze_bb===

pa2-p3.c:75: note: === vect_analyze_data_refs ===

pa2-p3.c:75: note: not vectorized: no vectype for stmt: vect_var_.29_14 = MEM[(float[2000][2000] *)vect_pc.25_16];
 scalar_type: vector(4) float
pa2-p3.c:75: note: === vect_pattern_recog ===
pa2-p3.c:75: note: vect_is_simple_use: operand vect_var_.34_3
pa2-p3.c:75: note: def_stmt: vect_var_.34_3 = MEM[(float[2000][2000] *)vect_pa.30_5];

pa2-p3.c:75: note: type of def: 3.
pa2-p3.c:75: note: === vect_analyze_dependences ===
pa2-p3.c:75: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:75: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:75: note: === vect_analyze_slp ===
pa2-p3.c:75: note: Failed to SLP the basic block.
pa2-p3.c:75: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:75: note: ===vect_slp_analyze_bb===

pa2-p3.c:75: note: === vect_analyze_data_refs ===

pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: === vect_pattern_recog ===
pa2-p3.c:75: note: vect_is_simple_use: operand _103
pa2-p3.c:75: note: def_stmt: _103 = a[i_82][i_106];

pa2-p3.c:75: note: type of def: 3.
pa2-p3.c:75: note: === vect_analyze_dependences ===
pa2-p3.c:75: note: determined dependence between c[j_18][i_106] and c[j_18][i_106]
pa2-p3.c:75: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: Unknown alignment for access: a
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:75: note: not consecutive access _104 = c[j_18][i_106];

pa2-p3.c:75: note: not consecutive access _103 = a[i_82][i_106];

pa2-p3.c:75: note: not consecutive access c[j_18][i_106] = _101;

pa2-p3.c:75: note: === vect_analyze_slp ===
pa2-p3.c:75: note: Failed to SLP the basic block.
pa2-p3.c:75: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:75: note: ===vect_slp_analyze_bb===

pa2-p3.c:75: note: === vect_analyze_data_refs ===

pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: === vect_pattern_recog ===
pa2-p3.c:75: note: vect_is_simple_use: operand _116
pa2-p3.c:75: note: def_stmt: _116 = a[i_82][i_98];

pa2-p3.c:75: note: type of def: 3.
pa2-p3.c:75: note: === vect_analyze_dependences ===
pa2-p3.c:75: note: determined dependence between c[j_18][i_98] and c[j_18][i_98]
pa2-p3.c:75: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: Unknown alignment for access: a
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:75: note: not consecutive access _69 = c[j_18][i_98];

pa2-p3.c:75: note: not consecutive access _116 = a[i_82][i_98];

pa2-p3.c:75: note: not consecutive access c[j_18][i_98] = _148;

pa2-p3.c:75: note: === vect_analyze_slp ===
pa2-p3.c:75: note: Failed to SLP the basic block.
pa2-p3.c:75: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:75: note: ===vect_slp_analyze_bb===

pa2-p3.c:75: note: === vect_analyze_data_refs ===

pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: get vectype with 4 units of type float
pa2-p3.c:75: note: vectype: vector(4) float
pa2-p3.c:75: note: === vect_pattern_recog ===
pa2-p3.c:75: note: vect_is_simple_use: operand _342
pa2-p3.c:75: note: def_stmt: _342 = a[i_82][i_339];

pa2-p3.c:75: note: type of def: 3.
pa2-p3.c:75: note: === vect_analyze_dependences ===
pa2-p3.c:75: note: determined dependence between c[j_18][i_339] and c[j_18][i_339]
pa2-p3.c:75: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: Unknown alignment for access: a
pa2-p3.c:75: note: vect_compute_data_ref_alignment:
pa2-p3.c:75: note: Unknown alignment for access: c
pa2-p3.c:75: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:75: note: not consecutive access _10 = c[j_18][i_339];

pa2-p3.c:75: note: not consecutive access _342 = a[i_82][i_339];

pa2-p3.c:75: note: not consecutive access c[j_18][i_339] = _38;

pa2-p3.c:75: note: === vect_analyze_slp ===
pa2-p3.c:75: note: Failed to SLP the basic block.
pa2-p3.c:75: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:72: note: ===vect_slp_analyze_bb===

pa2-p3.c:72: note: === vect_analyze_data_refs ===

pa2-p3.c:72: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:65: note: ===vect_slp_analyze_bb===

pa2-p3.c:65: note: === vect_analyze_data_refs ===

pa2-p3.c:65: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:98: note: ===vect_slp_analyze_bb===

pa2-p3.c:98: note: === vect_analyze_data_refs ===

pa2-p3.c:98: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:99: note: ===vect_slp_analyze_bb===

pa2-p3.c:99: note: === vect_analyze_data_refs ===

pa2-p3.c:99: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:100: note: ===vect_slp_analyze_bb===

pa2-p3.c:100: note: === vect_analyze_data_refs ===

pa2-p3.c:100: note: get vectype with 2 units of type __time_t
pa2-p3.c:100: note: vectype: vector(2) long int
pa2-p3.c:100: note: get vectype with 2 units of type __suseconds_t
pa2-p3.c:100: note: vectype: vector(2) long int
pa2-p3.c:100: note: get vectype with 2 units of type long unsigned int
pa2-p3.c:100: note: vectype: vector(2) long unsigned int
pa2-p3.c:100: note: not vectorized: no vectype for stmt: Tp ={v} {CLOBBER};
 scalar_type: struct timeval
pa2-p3.c:100: note: === vect_pattern_recog ===
pa2-p3.c:100: note: vect_is_simple_use: operand _9
pa2-p3.c:100: note: def_stmt: _9 = (double) _8;

pa2-p3.c:100: note: type of def: 3.
pa2-p3.c:100: note: === vect_analyze_dependences ===
pa2-p3.c:100: note: Detected interleaving Tp.tv_sec and Tp.tv_usec
pa2-p3.c:100: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:100: note: vect_compute_data_ref_alignment:
pa2-p3.c:100: note: misalign = 0 bytes of ref Tp.tv_sec
pa2-p3.c:100: note: vect_compute_data_ref_alignment:
pa2-p3.c:100: note: misalign = 8 bytes of ref Tp.tv_usec
pa2-p3.c:100: note: vect_compute_data_ref_alignment:
pa2-p3.c:100: note: misalign = 0 bytes of ref Tzp
pa2-p3.c:100: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:100: note: Detected interleaving of size 2
pa2-p3.c:100: note: not consecutive access Tzp ={v} {CLOBBER};

pa2-p3.c:100: note: === vect_analyze_slp ===
pa2-p3.c:100: note: Failed to SLP the basic block.
pa2-p3.c:100: note: not vectorized: failed to find SLP opportunities in basic block.

Analyzing loop at pa2-p3.c:110

pa2-p3.c:110: note: ===== analyze_loop_nest =====
pa2-p3.c:110: note: === vect_analyze_loop_form ===
pa2-p3.c:110: note: ===== analyze_loop_nest_1 =====
pa2-p3.c:110: note: === vect_analyze_loop_form ===
pa2-p3.c:110: note: not vectorized: control flow in loop.
pa2-p3.c:110: note: bad inner-loop form.
pa2-p3.c:110: note: not vectorized: Bad inner loop.
pa2-p3.c:110: note: bad loop form.
Analyzing loop at pa2-p3.c:111

pa2-p3.c:111: note: ===== analyze_loop_nest =====
pa2-p3.c:111: note: === vect_analyze_loop_form ===
pa2-p3.c:111: note: not vectorized: control flow in loop.
pa2-p3.c:111: note: bad loop form.
pa2-p3.c:103: note: vectorized 0 loops in function.

pa2-p3.c:103: note: ===vect_slp_analyze_bb===

pa2-p3.c:103: note: === vect_analyze_data_refs ===

pa2-p3.c:103: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:103: note: ===vect_slp_analyze_bb===

pa2-p3.c:103: note: === vect_analyze_data_refs ===

pa2-p3.c:103: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:103: note: ===vect_slp_analyze_bb===

pa2-p3.c:103: note: === vect_analyze_data_refs ===

pa2-p3.c:103: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:113: note: ===vect_slp_analyze_bb===

pa2-p3.c:113: note: === vect_analyze_data_refs ===

pa2-p3.c:113: note: get vectype with 4 units of type float
pa2-p3.c:113: note: vectype: vector(4) float
pa2-p3.c:113: note: get vectype with 4 units of type float
pa2-p3.c:113: note: vectype: vector(4) float
pa2-p3.c:113: note: === vect_pattern_recog ===
pa2-p3.c:113: note: === vect_analyze_dependences ===
pa2-p3.c:113: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:113: note: vect_compute_data_ref_alignment:
pa2-p3.c:113: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:113: note: Unknown alignment for access: *(wref_16(D) + pretmp_54)
pa2-p3.c:113: note: vect_compute_data_ref_alignment:
pa2-p3.c:113: note: SLP: step doesn't divide the vector-size.
pa2-p3.c:113: note: Unknown alignment for access: *(w_23(D) + pretmp_54)
pa2-p3.c:113: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:113: note: === vect_analyze_slp ===
pa2-p3.c:113: note: Failed to SLP the basic block.
pa2-p3.c:113: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:114: note: ===vect_slp_analyze_bb===

pa2-p3.c:114: note: === vect_analyze_data_refs ===

pa2-p3.c:114: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:115: note: ===vect_slp_analyze_bb===

pa2-p3.c:115: note: === vect_analyze_data_refs ===

pa2-p3.c:115: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:116: note: ===vect_slp_analyze_bb===

pa2-p3.c:116: note: === vect_analyze_data_refs ===

pa2-p3.c:116: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:103: note: ===vect_slp_analyze_bb===

pa2-p3.c:103: note: === vect_analyze_data_refs ===

pa2-p3.c:103: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:111: note: ===vect_slp_analyze_bb===

pa2-p3.c:111: note: === vect_analyze_data_refs ===

pa2-p3.c:111: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:110: note: ===vect_slp_analyze_bb===

pa2-p3.c:110: note: === vect_analyze_data_refs ===

pa2-p3.c:110: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:103: note: ===vect_slp_analyze_bb===

pa2-p3.c:103: note: === vect_analyze_data_refs ===

pa2-p3.c:103: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:103: note: ===vect_slp_analyze_bb===

pa2-p3.c:103: note: === vect_analyze_data_refs ===

pa2-p3.c:103: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:120: note: ===vect_slp_analyze_bb===

pa2-p3.c:120: note: === vect_analyze_data_refs ===

pa2-p3.c:120: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:121: note: ===vect_slp_analyze_bb===

pa2-p3.c:121: note: === vect_analyze_data_refs ===

pa2-p3.c:121: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:124: note: ===vect_slp_analyze_bb===

pa2-p3.c:124: note: === vect_analyze_data_refs ===

pa2-p3.c:124: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:125: note: ===vect_slp_analyze_bb===

pa2-p3.c:125: note: === vect_analyze_data_refs ===

pa2-p3.c:125: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at pa2-p3.c:59

pa2-p3.c:59: note: ===== analyze_loop_nest =====
pa2-p3.c:59: note: === vect_analyze_loop_form ===
pa2-p3.c:59: note: ===== analyze_loop_nest_1 =====
pa2-p3.c:59: note: === vect_analyze_loop_form ===
pa2-p3.c:59: note: === get_loop_niters ===
pa2-p3.c:59: note: ==> get_loop_niters:2000
pa2-p3.c:59: note: Considering outer-loop vectorization.
pa2-p3.c:59: note: === get_loop_niters ===
pa2-p3.c:59: note: ==> get_loop_niters:2000
pa2-p3.c:59: note: === vect_analyze_data_refs ===

pa2-p3.c:59: note: analyze in outer-loop: c
pa2-p3.c:59: note: 	outer base_address: &c
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer aligned to: 128
pa2-p3.c:59: note: get vectype with 4 units of type float
pa2-p3.c:59: note: vectype: vector(4) float
pa2-p3.c:59: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:59: note: Analyze phi: .MEM_56 = PHI <.MEM_73(33), .MEM_77(39)>

pa2-p3.c:59: note: Analyze phi: i_128 = PHI <0(33), i_79(39)>

pa2-p3.c:59: note: Access function of PHI: {0, +, 1}_10
pa2-p3.c:59: note: step: 1,  init: 0
pa2-p3.c:59: note: Detected induction.
pa2-p3.c:59: note: Analyze phi: ivtmp_57 = PHI <2000(33), ivtmp_148(39)>

pa2-p3.c:59: note: Access function of PHI: {2000, +, 4294967295}_10
pa2-p3.c:59: note: step: 4294967295,  init: 2000
pa2-p3.c:59: note: Detected induction.
pa2-p3.c:59: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:59: note: Analyze phi: j_133 = PHI <j_78(36), 0(40)>

pa2-p3.c:59: note: Access function of PHI: {0, +, 1}_11
pa2-p3.c:59: note: step: 1,  init: 0
pa2-p3.c:59: note: Detected induction.
pa2-p3.c:59: note: Analyze phi: .MEM_137 = PHI <.MEM_77(36), .MEM_56(40)>

pa2-p3.c:59: note: Analyze phi: ivtmp_35 = PHI <ivtmp_62(36), 2000(40)>

pa2-p3.c:59: note: Access function of PHI: {2000, +, 4294967295}_11
pa2-p3.c:59: note: step: 4294967295,  init: 2000
pa2-p3.c:59: note: Detected induction.
pa2-p3.c:59: note: === vect_pattern_recog ===
pa2-p3.c:59: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p3.c:59: note: init: phi relevant? .MEM_56 = PHI <.MEM_73(33), .MEM_77(39)>

pa2-p3.c:59: note: init: phi relevant? i_128 = PHI <0(33), i_79(39)>

pa2-p3.c:59: note: init: phi relevant? ivtmp_57 = PHI <2000(33), ivtmp_148(39)>

pa2-p3.c:59: note: init: stmt relevant? # DEBUG i => i_128

pa2-p3.c:59: note: init: stmt relevant? # DEBUG j => 0

pa2-p3.c:59: note: init: phi relevant? j_133 = PHI <j_78(36), 0(40)>

pa2-p3.c:59: note: init: phi relevant? .MEM_137 = PHI <.MEM_77(36), .MEM_56(40)>

pa2-p3.c:59: note: init: phi relevant? ivtmp_35 = PHI <ivtmp_62(36), 2000(40)>

pa2-p3.c:59: note: init: stmt relevant? # DEBUG j => j_133

pa2-p3.c:59: note: init: stmt relevant? c[j_133][i_128] = 0.0;

pa2-p3.c:59: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:59: note: mark relevant 4, live 0.
pa2-p3.c:59: note: init: stmt relevant? j_78 = j_133 + 1;

pa2-p3.c:59: note: init: stmt relevant? # DEBUG j => j_78

pa2-p3.c:59: note: init: stmt relevant? # DEBUG j => j_78

pa2-p3.c:59: note: init: stmt relevant? ivtmp_62 = ivtmp_35 - 1;

pa2-p3.c:59: note: init: stmt relevant? if (ivtmp_62 != 0)

pa2-p3.c:59: note: init: stmt relevant? i_79 = i_128 + 1;

pa2-p3.c:59: note: init: stmt relevant? # DEBUG i => i_79

pa2-p3.c:59: note: init: stmt relevant? # DEBUG i => i_79

pa2-p3.c:59: note: init: stmt relevant? ivtmp_148 = ivtmp_57 - 1;

pa2-p3.c:59: note: init: stmt relevant? if (ivtmp_148 != 0)

pa2-p3.c:59: note: worklist: examine stmt: c[j_133][i_128] = 0.0;

pa2-p3.c:59: note: === vect_analyze_dependences ===
pa2-p3.c:59: note: === vect_determine_vectorization_factor ===
pa2-p3.c:59: note: ==> examining phi: .MEM_56 = PHI <.MEM_73(33), .MEM_77(39)>

pa2-p3.c:59: note: ==> examining phi: i_128 = PHI <0(33), i_79(39)>

pa2-p3.c:59: note: ==> examining phi: ivtmp_57 = PHI <2000(33), ivtmp_148(39)>

pa2-p3.c:59: note: ==> examining statement: # DEBUG i => i_128

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining statement: # DEBUG j => 0

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining phi: j_133 = PHI <j_78(36), 0(40)>

pa2-p3.c:59: note: ==> examining phi: .MEM_137 = PHI <.MEM_77(36), .MEM_56(40)>

pa2-p3.c:59: note: ==> examining phi: ivtmp_35 = PHI <ivtmp_62(36), 2000(40)>

pa2-p3.c:59: note: ==> examining statement: # DEBUG j => j_133

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining statement: c[j_133][i_128] = 0.0;

pa2-p3.c:59: note: get vectype for scalar type:  float
pa2-p3.c:59: note: get vectype with 4 units of type float
pa2-p3.c:59: note: vectype: vector(4) float
pa2-p3.c:59: note: vectype: vector(4) float
pa2-p3.c:59: note: nunits = 4
pa2-p3.c:59: note: ==> examining statement: j_78 = j_133 + 1;

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining statement: # DEBUG j => j_78

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining statement: # DEBUG j => j_78

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining statement: ivtmp_62 = ivtmp_35 - 1;

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining statement: if (ivtmp_62 != 0)

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining statement: i_79 = i_128 + 1;

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining statement: # DEBUG i => i_79

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining statement: # DEBUG i => i_79

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining statement: ivtmp_148 = ivtmp_57 - 1;

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: ==> examining statement: if (ivtmp_148 != 0)

pa2-p3.c:59: note: skip.
pa2-p3.c:59: note: vectorization factor = 4
pa2-p3.c:59: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:59: note: vect_compute_data_ref_alignment:
pa2-p3.c:59: note: inner step divides the vector-size.
pa2-p3.c:59: note: misalign = 0 bytes of ref c[j_133][i_128]
pa2-p3.c:59: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:59: note: === vect_prune_runtime_alias_test_list ===
pa2-p3.c:59: note: === vect_enhance_data_refs_alignment ===
pa2-p3.c:59: note: vect_can_advance_ivs_p:
pa2-p3.c:59: note: Analyze phi: .MEM_56 = PHI <.MEM_73(33), .MEM_77(39)>

pa2-p3.c:59: note: virtual phi. skip.
pa2-p3.c:59: note: Analyze phi: i_128 = PHI <0(33), i_79(39)>

pa2-p3.c:59: note: Access function of PHI: {0, +, 1}_10
pa2-p3.c:59: note: Analyze phi: ivtmp_57 = PHI <2000(33), ivtmp_148(39)>

pa2-p3.c:59: note: Access function of PHI: {2000, +, 4294967295}_10
pa2-p3.c:59: note: === vect_analyze_slp ===
pa2-p3.c:59: note: === vect_make_slp_decision ===
pa2-p3.c:59: note: === vect_detect_hybrid_slp ===
pa2-p3.c:59: note: === vect_analyze_loop_operations ===
pa2-p3.c:59: note: examining phi: .MEM_56 = PHI <.MEM_73(33), .MEM_77(39)>

pa2-p3.c:59: note: examining phi: i_128 = PHI <0(33), i_79(39)>

pa2-p3.c:59: note: examining phi: ivtmp_57 = PHI <2000(33), ivtmp_148(39)>

pa2-p3.c:59: note: ==> examining statement: # DEBUG i => i_128

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: ==> examining statement: # DEBUG j => 0

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: examining phi: j_133 = PHI <j_78(36), 0(40)>

pa2-p3.c:59: note: examining phi: .MEM_137 = PHI <.MEM_77(36), .MEM_56(40)>

pa2-p3.c:59: note: examining phi: ivtmp_35 = PHI <ivtmp_62(36), 2000(40)>

pa2-p3.c:59: note: ==> examining statement: # DEBUG j => j_133

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: ==> examining statement: c[j_133][i_128] = 0.0;

pa2-p3.c:59: note: vect_is_simple_use: operand 0.0
pa2-p3.c:59: note: vect_model_store_cost: aligned.
pa2-p3.c:59: note: vect_model_store_cost: inside_cost = 50, prologue_cost = 1 .
pa2-p3.c:59: note: ==> examining statement: j_78 = j_133 + 1;

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: ==> examining statement: # DEBUG j => j_78

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: ==> examining statement: # DEBUG j => j_78

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: ==> examining statement: ivtmp_62 = ivtmp_35 - 1;

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: ==> examining statement: if (ivtmp_62 != 0)

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: ==> examining statement: i_79 = i_128 + 1;

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: ==> examining statement: # DEBUG i => i_79

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: ==> examining statement: # DEBUG i => i_79

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: ==> examining statement: ivtmp_148 = ivtmp_57 - 1;

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: ==> examining statement: if (ivtmp_148 != 0)

pa2-p3.c:59: note: irrelevant.
pa2-p3.c:59: note: vectorization_factor = 4, niters = 2000
pa2-p3.c:59: note: === vect_update_slp_costs_according_to_vf ===
pa2-p3.c:59: note: Cost model analysis: 
  Vector inside of loop cost: 50
  Vector prologue cost: 1
  Vector epilogue cost: 0
  Scalar iteration cost: 50
  Scalar outside cost: 0
  Vector outside cost: 1
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

pa2-p3.c:59: note:   Runtime profitability threshold = 3

pa2-p3.c:59: note:   Static estimate profitability threshold = 3


Vectorizing loop at pa2-p3.c:59

pa2-p3.c:59: note: === vec_transform_loop ===
pa2-p3.c:59: note: ------>vectorizing phi: .MEM_56 = PHI <.MEM_73(42), .MEM_77(39)>

pa2-p3.c:59: note: ------>vectorizing phi: i_128 = PHI <0(42), i_79(39)>

pa2-p3.c:59: note: ------>vectorizing phi: ivtmp_57 = PHI <2000(42), ivtmp_148(39)>

pa2-p3.c:59: note: ------>vectorizing statement: # DEBUG i => i_128

pa2-p3.c:59: note: ------>vectorizing statement: # DEBUG j => 0

pa2-p3.c:59: note: ------>vectorizing phi: j_133 = PHI <j_78(36), 0(40)>

pa2-p3.c:59: note: ------>vectorizing phi: .MEM_137 = PHI <.MEM_77(36), .MEM_56(40)>

pa2-p3.c:59: note: ------>vectorizing phi: ivtmp_35 = PHI <ivtmp_62(36), 2000(40)>

pa2-p3.c:59: note: ------>vectorizing statement: # DEBUG j => j_133

pa2-p3.c:59: note: ------>vectorizing statement: c[j_133][i_128] = 0.0;

pa2-p3.c:59: note: transform statement.
pa2-p3.c:59: note: vect_is_simple_use: operand 0.0
pa2-p3.c:59: note: transform store. ncopies = 1
pa2-p3.c:59: note: vect_get_vec_def_for_operand: 0.0
pa2-p3.c:59: note: vect_is_simple_use: operand 0.0
pa2-p3.c:59: note: get vectype with 4 units of type float
pa2-p3.c:59: note: vectype: vector(4) float
pa2-p3.c:59: note: Create vector_cst. nunits = 4
pa2-p3.c:59: note: created new init_stmt: vect_cst_.285_109 = { 0.0, 0.0, 0.0, 0.0 };

pa2-p3.c:59: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:59: note: created vect_pc.289_108
pa2-p3.c:59: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.286_104] = vect_cst_.285_109;

pa2-p3.c:59: note: ------>vectorizing statement: j_78 = j_133 + 1;

pa2-p3.c:59: note: ------>vectorizing statement: # DEBUG j => j_78

pa2-p3.c:59: note: ------>vectorizing statement: # DEBUG j => j_78

pa2-p3.c:59: note: ------>vectorizing statement: ivtmp_62 = ivtmp_35 - 1;

pa2-p3.c:59: note: ------>vectorizing statement: vect_pc.286_102 = vect_pc.286_104 + 8000;

pa2-p3.c:59: note: ------>vectorizing statement: if (ivtmp_62 != 0)

pa2-p3.c:59: note: ------>vectorizing statement: i_79 = i_128 + 1;

pa2-p3.c:59: note: ------>vectorizing statement: # DEBUG i => i_79

pa2-p3.c:59: note: ------>vectorizing statement: # DEBUG i => i_79

pa2-p3.c:59: note: ------>vectorizing statement: ivtmp_148 = ivtmp_57 - 1;

pa2-p3.c:59: note: ------>vectorizing statement: vect_pc.286_105 = vect_pc.286_106 + 16;

pa2-p3.c:59: note: ------>vectorizing statement: if (ivtmp_148 != 0)
if (ivtmp_98 < 500)

pa2-p3.c:59: note: LOOP VECTORIZED.
pa2-p3.c:59: note: OUTER LOOP VECTORIZED.
Analyzing loop at pa2-p3.c:59

pa2-p3.c:59: note: ===== analyze_loop_nest =====
pa2-p3.c:59: note: outer-loop already vectorized.
Analyzing loop at pa2-p3.c:52

pa2-p3.c:52: note: ===== analyze_loop_nest =====
pa2-p3.c:52: note: === vect_analyze_loop_form ===
pa2-p3.c:52: note: ===== analyze_loop_nest_1 =====
pa2-p3.c:52: note: === vect_analyze_loop_form ===
pa2-p3.c:52: note: === get_loop_niters ===
pa2-p3.c:52: note: ==> get_loop_niters:2000
pa2-p3.c:52: note: Considering outer-loop vectorization.
pa2-p3.c:52: note: === get_loop_niters ===
pa2-p3.c:52: note: ==> get_loop_niters:2000
pa2-p3.c:52: note: === vect_analyze_data_refs ===

pa2-p3.c:52: note: analyze in outer-loop: c
pa2-p3.c:52: note: 	outer base_address: &c
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer aligned to: 128
pa2-p3.c:52: note: get vectype with 4 units of type float
pa2-p3.c:52: note: vectype: vector(4) float
pa2-p3.c:52: note: analyze in outer-loop: cc
pa2-p3.c:52: note: 	outer base_address: &cc
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer aligned to: 128
pa2-p3.c:52: note: get vectype with 4 units of type float
pa2-p3.c:52: note: vectype: vector(4) float
pa2-p3.c:52: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:52: note: Analyze phi: .MEM_49 = PHI <.MEM_70(29), .MEM_73(34)>

pa2-p3.c:52: note: Analyze phi: i_127 = PHI <0(29), i_75(34)>

pa2-p3.c:52: note: Access function of PHI: {0, +, 1}_8
pa2-p3.c:52: note: step: 1,  init: 0
pa2-p3.c:52: note: Detected induction.
pa2-p3.c:52: note: Analyze phi: ivtmp_141 = PHI <2000(29), ivtmp_140(34)>

pa2-p3.c:52: note: Access function of PHI: {2000, +, 4294967295}_8
pa2-p3.c:52: note: step: 4294967295,  init: 2000
pa2-p3.c:52: note: Detected induction.
pa2-p3.c:52: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:52: note: Analyze phi: j_132 = PHI <j_74(30), 0(35)>

pa2-p3.c:52: note: Access function of PHI: {0, +, 1}_9
pa2-p3.c:52: note: step: 1,  init: 0
pa2-p3.c:52: note: Detected induction.
pa2-p3.c:52: note: Analyze phi: .MEM_136 = PHI <.MEM_73(30), .MEM_49(35)>

pa2-p3.c:52: note: Analyze phi: ivtmp_4 = PHI <ivtmp_142(30), 2000(35)>

pa2-p3.c:52: note: Access function of PHI: {2000, +, 4294967295}_9
pa2-p3.c:52: note: step: 4294967295,  init: 2000
pa2-p3.c:52: note: Detected induction.
pa2-p3.c:52: note: === vect_pattern_recog ===
pa2-p3.c:52: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p3.c:52: note: init: phi relevant? .MEM_49 = PHI <.MEM_70(29), .MEM_73(34)>

pa2-p3.c:52: note: init: phi relevant? i_127 = PHI <0(29), i_75(34)>

pa2-p3.c:52: note: init: phi relevant? ivtmp_141 = PHI <2000(29), ivtmp_140(34)>

pa2-p3.c:52: note: init: stmt relevant? # DEBUG i => i_127

pa2-p3.c:52: note: init: stmt relevant? # DEBUG j => 0

pa2-p3.c:52: note: init: phi relevant? j_132 = PHI <j_74(30), 0(35)>

pa2-p3.c:52: note: init: phi relevant? .MEM_136 = PHI <.MEM_73(30), .MEM_49(35)>

pa2-p3.c:52: note: init: phi relevant? ivtmp_4 = PHI <ivtmp_142(30), 2000(35)>

pa2-p3.c:52: note: init: stmt relevant? # DEBUG j => j_132

pa2-p3.c:52: note: init: stmt relevant? _72 = c[j_132][i_127];

pa2-p3.c:52: note: init: stmt relevant? cc[j_132][i_127] = _72;

pa2-p3.c:52: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:52: note: mark relevant 4, live 0.
pa2-p3.c:52: note: init: stmt relevant? j_74 = j_132 + 1;

pa2-p3.c:52: note: init: stmt relevant? # DEBUG j => j_74

pa2-p3.c:52: note: init: stmt relevant? # DEBUG j => j_74

pa2-p3.c:52: note: init: stmt relevant? ivtmp_142 = ivtmp_4 - 1;

pa2-p3.c:52: note: init: stmt relevant? if (ivtmp_142 != 0)

pa2-p3.c:52: note: init: stmt relevant? i_75 = i_127 + 1;

pa2-p3.c:52: note: init: stmt relevant? # DEBUG i => i_75

pa2-p3.c:52: note: init: stmt relevant? # DEBUG i => i_75

pa2-p3.c:52: note: init: stmt relevant? ivtmp_140 = ivtmp_141 - 1;

pa2-p3.c:52: note: init: stmt relevant? if (ivtmp_140 != 0)

pa2-p3.c:52: note: worklist: examine stmt: cc[j_132][i_127] = _72;

pa2-p3.c:52: note: vect_is_simple_use: operand _72
pa2-p3.c:52: note: def_stmt: _72 = c[j_132][i_127];

pa2-p3.c:52: note: type of def: 3.
pa2-p3.c:52: note: mark relevant 4, live 0.
pa2-p3.c:52: note: worklist: examine stmt: _72 = c[j_132][i_127];

pa2-p3.c:52: note: === vect_analyze_dependences ===
pa2-p3.c:52: note: === vect_determine_vectorization_factor ===
pa2-p3.c:52: note: ==> examining phi: .MEM_49 = PHI <.MEM_70(29), .MEM_73(34)>

pa2-p3.c:52: note: ==> examining phi: i_127 = PHI <0(29), i_75(34)>

pa2-p3.c:52: note: ==> examining phi: ivtmp_141 = PHI <2000(29), ivtmp_140(34)>

pa2-p3.c:52: note: ==> examining statement: # DEBUG i => i_127

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining statement: # DEBUG j => 0

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining phi: j_132 = PHI <j_74(30), 0(35)>

pa2-p3.c:52: note: ==> examining phi: .MEM_136 = PHI <.MEM_73(30), .MEM_49(35)>

pa2-p3.c:52: note: ==> examining phi: ivtmp_4 = PHI <ivtmp_142(30), 2000(35)>

pa2-p3.c:52: note: ==> examining statement: # DEBUG j => j_132

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining statement: _72 = c[j_132][i_127];

pa2-p3.c:52: note: get vectype for scalar type:  float
pa2-p3.c:52: note: get vectype with 4 units of type float
pa2-p3.c:52: note: vectype: vector(4) float
pa2-p3.c:52: note: vectype: vector(4) float
pa2-p3.c:52: note: nunits = 4
pa2-p3.c:52: note: ==> examining statement: cc[j_132][i_127] = _72;

pa2-p3.c:52: note: get vectype for scalar type:  float
pa2-p3.c:52: note: get vectype with 4 units of type float
pa2-p3.c:52: note: vectype: vector(4) float
pa2-p3.c:52: note: vectype: vector(4) float
pa2-p3.c:52: note: nunits = 4
pa2-p3.c:52: note: ==> examining statement: j_74 = j_132 + 1;

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining statement: # DEBUG j => j_74

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining statement: # DEBUG j => j_74

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining statement: ivtmp_142 = ivtmp_4 - 1;

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining statement: if (ivtmp_142 != 0)

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining statement: i_75 = i_127 + 1;

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining statement: # DEBUG i => i_75

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining statement: # DEBUG i => i_75

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining statement: ivtmp_140 = ivtmp_141 - 1;

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: ==> examining statement: if (ivtmp_140 != 0)

pa2-p3.c:52: note: skip.
pa2-p3.c:52: note: vectorization factor = 4
pa2-p3.c:52: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:52: note: vect_compute_data_ref_alignment:
pa2-p3.c:52: note: inner step divides the vector-size.
pa2-p3.c:52: note: misalign = 0 bytes of ref c[j_132][i_127]
pa2-p3.c:52: note: vect_compute_data_ref_alignment:
pa2-p3.c:52: note: inner step divides the vector-size.
pa2-p3.c:52: note: misalign = 0 bytes of ref cc[j_132][i_127]
pa2-p3.c:52: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:52: note: === vect_prune_runtime_alias_test_list ===
pa2-p3.c:52: note: === vect_enhance_data_refs_alignment ===
pa2-p3.c:52: note: vect_can_advance_ivs_p:
pa2-p3.c:52: note: Analyze phi: .MEM_49 = PHI <.MEM_70(29), .MEM_73(34)>

pa2-p3.c:52: note: virtual phi. skip.
pa2-p3.c:52: note: Analyze phi: i_127 = PHI <0(29), i_75(34)>

pa2-p3.c:52: note: Access function of PHI: {0, +, 1}_8
pa2-p3.c:52: note: Analyze phi: ivtmp_141 = PHI <2000(29), ivtmp_140(34)>

pa2-p3.c:52: note: Access function of PHI: {2000, +, 4294967295}_8
pa2-p3.c:52: note: === vect_analyze_slp ===
pa2-p3.c:52: note: === vect_make_slp_decision ===
pa2-p3.c:52: note: === vect_detect_hybrid_slp ===
pa2-p3.c:52: note: === vect_analyze_loop_operations ===
pa2-p3.c:52: note: examining phi: .MEM_49 = PHI <.MEM_70(29), .MEM_73(34)>

pa2-p3.c:52: note: examining phi: i_127 = PHI <0(29), i_75(34)>

pa2-p3.c:52: note: examining phi: ivtmp_141 = PHI <2000(29), ivtmp_140(34)>

pa2-p3.c:52: note: ==> examining statement: # DEBUG i => i_127

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: ==> examining statement: # DEBUG j => 0

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: examining phi: j_132 = PHI <j_74(30), 0(35)>

pa2-p3.c:52: note: examining phi: .MEM_136 = PHI <.MEM_73(30), .MEM_49(35)>

pa2-p3.c:52: note: examining phi: ivtmp_4 = PHI <ivtmp_142(30), 2000(35)>

pa2-p3.c:52: note: ==> examining statement: # DEBUG j => j_132

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: ==> examining statement: _72 = c[j_132][i_127];

pa2-p3.c:52: note: num. args = 4 (not unary/binary/ternary op).
pa2-p3.c:52: note: vect_is_simple_use: operand c[j_132][i_127]
pa2-p3.c:52: note: not ssa-name.
pa2-p3.c:52: note: use not simple.
pa2-p3.c:52: note: vect_model_load_cost: aligned.
pa2-p3.c:52: note: vect_model_load_cost: inside_cost = 50, prologue_cost = 0 .
pa2-p3.c:52: note: ==> examining statement: cc[j_132][i_127] = _72;

pa2-p3.c:52: note: vect_is_simple_use: operand _72
pa2-p3.c:52: note: def_stmt: _72 = c[j_132][i_127];

pa2-p3.c:52: note: type of def: 3.
pa2-p3.c:52: note: vect_model_store_cost: aligned.
pa2-p3.c:52: note: vect_model_store_cost: inside_cost = 50, prologue_cost = 0 .
pa2-p3.c:52: note: ==> examining statement: j_74 = j_132 + 1;

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: ==> examining statement: # DEBUG j => j_74

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: ==> examining statement: # DEBUG j => j_74

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: ==> examining statement: ivtmp_142 = ivtmp_4 - 1;

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: ==> examining statement: if (ivtmp_142 != 0)

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: ==> examining statement: i_75 = i_127 + 1;

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: ==> examining statement: # DEBUG i => i_75

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: ==> examining statement: # DEBUG i => i_75

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: ==> examining statement: ivtmp_140 = ivtmp_141 - 1;

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: ==> examining statement: if (ivtmp_140 != 0)

pa2-p3.c:52: note: irrelevant.
pa2-p3.c:52: note: vectorization_factor = 4, niters = 2000
pa2-p3.c:52: note: === vect_update_slp_costs_according_to_vf ===
pa2-p3.c:52: note: Cost model analysis: 
  Vector inside of loop cost: 100
  Vector prologue cost: 0
  Vector epilogue cost: 0
  Scalar iteration cost: 100
  Scalar outside cost: 0
  Vector outside cost: 0
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

pa2-p3.c:52: note:   Runtime profitability threshold = 3

pa2-p3.c:52: note:   Static estimate profitability threshold = 3


Vectorizing loop at pa2-p3.c:52

pa2-p3.c:52: note: === vec_transform_loop ===
pa2-p3.c:52: note: ------>vectorizing phi: .MEM_49 = PHI <.MEM_70(43), .MEM_73(34)>

pa2-p3.c:52: note: ------>vectorizing phi: i_127 = PHI <0(43), i_75(34)>

pa2-p3.c:52: note: ------>vectorizing phi: ivtmp_141 = PHI <2000(43), ivtmp_140(34)>

pa2-p3.c:52: note: ------>vectorizing statement: # DEBUG i => i_127

pa2-p3.c:52: note: ------>vectorizing statement: # DEBUG j => 0

pa2-p3.c:52: note: ------>vectorizing phi: j_132 = PHI <j_74(30), 0(35)>

pa2-p3.c:52: note: ------>vectorizing phi: .MEM_136 = PHI <.MEM_73(30), .MEM_49(35)>

pa2-p3.c:52: note: ------>vectorizing phi: ivtmp_4 = PHI <ivtmp_142(30), 2000(35)>

pa2-p3.c:52: note: ------>vectorizing statement: # DEBUG j => j_132

pa2-p3.c:52: note: ------>vectorizing statement: _72 = c[j_132][i_127];

pa2-p3.c:52: note: transform statement.
pa2-p3.c:52: note: transform load. ncopies = 1
pa2-p3.c:52: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:52: note: created vect_pc.293_96
pa2-p3.c:52: note: add new stmt: vect_var_.294_11 = MEM[(float[2000][2000] *)vect_pc.290_16];

pa2-p3.c:52: note: ------>vectorizing statement: cc[j_132][i_127] = _72;

pa2-p3.c:52: note: transform statement.
pa2-p3.c:52: note: vect_is_simple_use: operand _72
pa2-p3.c:52: note: def_stmt: _72 = c[j_132][i_127];

pa2-p3.c:52: note: type of def: 3.
pa2-p3.c:52: note: transform store. ncopies = 1
pa2-p3.c:52: note: vect_get_vec_def_for_operand: _72
pa2-p3.c:52: note: vect_is_simple_use: operand _72
pa2-p3.c:52: note: def_stmt: _72 = c[j_132][i_127];

pa2-p3.c:52: note: type of def: 3.
pa2-p3.c:52: note: def =  _72  def_stmt =  _72 = c[j_132][i_127];

pa2-p3.c:52: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: cc
pa2-p3.c:52: note: created vect_pcc.298_9
pa2-p3.c:52: note: add new stmt: MEM[(float[2000][2000] *)vect_pcc.295_6] = vect_var_.294_11;

pa2-p3.c:52: note: ------>vectorizing statement: j_74 = j_132 + 1;

pa2-p3.c:52: note: ------>vectorizing statement: # DEBUG j => j_74

pa2-p3.c:52: note: ------>vectorizing statement: # DEBUG j => j_74

pa2-p3.c:52: note: ------>vectorizing statement: ivtmp_142 = ivtmp_4 - 1;

pa2-p3.c:52: note: ------>vectorizing statement: vect_pc.290_12 = vect_pc.290_16 + 8000;

pa2-p3.c:52: note: ------>vectorizing statement: vect_pcc.295_5 = vect_pcc.295_6 + 8000;

pa2-p3.c:52: note: ------>vectorizing statement: if (ivtmp_142 != 0)

pa2-p3.c:52: note: ------>vectorizing statement: i_75 = i_127 + 1;

pa2-p3.c:52: note: ------>vectorizing statement: # DEBUG i => i_75

pa2-p3.c:52: note: ------>vectorizing statement: # DEBUG i => i_75

pa2-p3.c:52: note: ------>vectorizing statement: ivtmp_140 = ivtmp_141 - 1;

pa2-p3.c:52: note: ------>vectorizing statement: vect_pc.290_28 = vect_pc.290_55 + 16;

pa2-p3.c:52: note: ------>vectorizing statement: vect_pcc.295_7 = vect_pcc.295_8 + 16;

pa2-p3.c:52: note: ------>vectorizing statement: if (ivtmp_140 != 0)
if (ivtmp_2 < 500)

pa2-p3.c:52: note: LOOP VECTORIZED.
pa2-p3.c:52: note: OUTER LOOP VECTORIZED.
Analyzing loop at pa2-p3.c:53

pa2-p3.c:53: note: ===== analyze_loop_nest =====
pa2-p3.c:53: note: outer-loop already vectorized.
Analyzing loop at pa2-p3.c:45

pa2-p3.c:45: note: ===== analyze_loop_nest =====
pa2-p3.c:45: note: === vect_analyze_loop_form ===
pa2-p3.c:45: note: not vectorized: multiple nested loops.
pa2-p3.c:45: note: bad loop form.
Analyzing loop at pa2-p3.c:46

pa2-p3.c:46: note: ===== analyze_loop_nest =====
pa2-p3.c:46: note: === vect_analyze_loop_form ===
pa2-p3.c:46: note: ===== analyze_loop_nest_1 =====
pa2-p3.c:46: note: === vect_analyze_loop_form ===
pa2-p3.c:46: note: === get_loop_niters ===
pa2-p3.c:46: note: ==> get_loop_niters:(unsigned int) i_126
pa2-p3.c:46: note: Symbolic number of iterations is (unsigned int) i_126
pa2-p3.c:46: note: not vectorized: control flow in loop.
pa2-p3.c:46: note: bad loop form.
Analyzing loop at pa2-p3.c:47

pa2-p3.c:47: note: ===== analyze_loop_nest =====
pa2-p3.c:47: note: === vect_analyze_loop_form ===
pa2-p3.c:47: note: === get_loop_niters ===
pa2-p3.c:47: note: ==> get_loop_niters:(unsigned int) i_126
pa2-p3.c:47: note: Symbolic number of iterations is (unsigned int) i_126
pa2-p3.c:47: note: === vect_analyze_data_refs ===

pa2-p3.c:47: note: get vectype with 4 units of type float
pa2-p3.c:47: note: vectype: vector(4) float
pa2-p3.c:47: note: get vectype with 4 units of type float
pa2-p3.c:47: note: vectype: vector(4) float
pa2-p3.c:47: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:47: note: Analyze phi: k_10 = PHI <k_63(19), 0(25)>

pa2-p3.c:47: note: Access function of PHI: {0, +, 1}_7
pa2-p3.c:47: note: step: 1,  init: 0
pa2-p3.c:47: note: Detected induction.
pa2-p3.c:47: note: Analyze phi: .MEM_107 = PHI <.MEM_107(19), .MEM_97(25)>

pa2-p3.c:47: note: Analyze phi: prephitmp_144 = PHI <_61(19), pretmp_143(25)>

pa2-p3.c:47: note: Access function of PHI: {pretmp_143, +, _60}_7
pa2-p3.c:47: note: step: _60,  init: pretmp_143
pa2-p3.c:47: note: step unknown.
pa2-p3.c:47: note: Analyze phi: prephitmp_144 = PHI <_61(19), pretmp_143(25)>

pa2-p3.c:47: note: reduction: unsafe fp math optimization: _61 = _60 + prephitmp_144;

pa2-p3.c:47: note: Unknown def-use cycle pattern.
pa2-p3.c:47: note: === vect_pattern_recog ===
pa2-p3.c:47: note: vect_is_simple_use: operand _58
pa2-p3.c:47: note: def_stmt: _58 = a[k_10][i_126];

pa2-p3.c:47: note: type of def: 3.
pa2-p3.c:47: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p3.c:47: note: init: phi relevant? k_10 = PHI <k_63(19), 0(25)>

pa2-p3.c:47: note: init: phi relevant? .MEM_107 = PHI <.MEM_107(19), .MEM_97(25)>

pa2-p3.c:47: note: init: phi relevant? prephitmp_144 = PHI <_61(19), pretmp_143(25)>

pa2-p3.c:47: note: init: stmt relevant? # DEBUG k => k_10

pa2-p3.c:47: note: init: stmt relevant? _58 = a[k_10][i_126];

pa2-p3.c:47: note: init: stmt relevant? _59 = b[k_10][j_131];

pa2-p3.c:47: note: init: stmt relevant? _60 = _58 * _59;

pa2-p3.c:47: note: init: stmt relevant? _61 = _60 + prephitmp_144;

pa2-p3.c:47: note: vec_stmt_relevant_p: used out of loop.
pa2-p3.c:47: note: mark relevant 0, live 1.
pa2-p3.c:47: note: init: stmt relevant? k_63 = k_10 + 1;

pa2-p3.c:47: note: init: stmt relevant? # DEBUG k => k_63

pa2-p3.c:47: note: init: stmt relevant? # DEBUG k => k_63

pa2-p3.c:47: note: init: stmt relevant? if (k_63 < i_126)

pa2-p3.c:47: note: worklist: examine stmt: _61 = _60 + prephitmp_144;

pa2-p3.c:47: note: vect_is_simple_use: operand _60
pa2-p3.c:47: note: def_stmt: _60 = _58 * _59;

pa2-p3.c:47: note: type of def: 3.
pa2-p3.c:47: note: mark relevant 0, live 1.
pa2-p3.c:47: note: vect_is_simple_use: operand prephitmp_144
pa2-p3.c:47: note: def_stmt: prephitmp_144 = PHI <_61(19), pretmp_143(25)>

pa2-p3.c:47: note: Unsupported pattern.
pa2-p3.c:47: note: not vectorized: unsupported use in stmt.
pa2-p3.c:47: note: unexpected pattern.
Analyzing loop at pa2-p3.c:43

pa2-p3.c:43: note: ===== analyze_loop_nest =====
pa2-p3.c:43: note: === vect_analyze_loop_form ===
pa2-p3.c:43: note: ===== analyze_loop_nest_1 =====
pa2-p3.c:43: note: === vect_analyze_loop_form ===
pa2-p3.c:43: note: === get_loop_niters ===
pa2-p3.c:43: note: ==> get_loop_niters:2000
pa2-p3.c:43: note: Considering outer-loop vectorization.
pa2-p3.c:43: note: === get_loop_niters ===
pa2-p3.c:43: note: ==> get_loop_niters:2000
pa2-p3.c:43: note: === vect_analyze_data_refs ===

pa2-p3.c:43: note: analyze in outer-loop: c
pa2-p3.c:43: note: 	outer base_address: &c
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 4
	outer aligned to: 128
pa2-p3.c:43: note: get vectype with 4 units of type float
pa2-p3.c:43: note: vectype: vector(4) float
pa2-p3.c:43: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:43: note: Analyze phi: .MEM_101 = PHI <.MEM_46(10), .MEM_50(16)>

pa2-p3.c:43: note: Analyze phi: i_125 = PHI <0(10), i_52(16)>

pa2-p3.c:43: note: Access function of PHI: {0, +, 1}_3
pa2-p3.c:43: note: step: 1,  init: 0
pa2-p3.c:43: note: Detected induction.
pa2-p3.c:43: note: Analyze phi: ivtmp_117 = PHI <2000(10), ivtmp_116(16)>

pa2-p3.c:43: note: Access function of PHI: {2000, +, 4294967295}_3
pa2-p3.c:43: note: step: 4294967295,  init: 2000
pa2-p3.c:43: note: Detected induction.
pa2-p3.c:43: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:43: note: Analyze phi: j_130 = PHI <j_51(13), 0(17)>

pa2-p3.c:43: note: Access function of PHI: {0, +, 1}_4
pa2-p3.c:43: note: step: 1,  init: 0
pa2-p3.c:43: note: Detected induction.
pa2-p3.c:43: note: Analyze phi: .MEM_135 = PHI <.MEM_50(13), .MEM_101(17)>

pa2-p3.c:43: note: Analyze phi: ivtmp_119 = PHI <ivtmp_118(13), 2000(17)>

pa2-p3.c:43: note: Access function of PHI: {2000, +, 4294967295}_4
pa2-p3.c:43: note: step: 4294967295,  init: 2000
pa2-p3.c:43: note: Detected induction.
pa2-p3.c:43: note: === vect_pattern_recog ===
pa2-p3.c:43: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p3.c:43: note: init: phi relevant? .MEM_101 = PHI <.MEM_46(10), .MEM_50(16)>

pa2-p3.c:43: note: init: phi relevant? i_125 = PHI <0(10), i_52(16)>

pa2-p3.c:43: note: init: phi relevant? ivtmp_117 = PHI <2000(10), ivtmp_116(16)>

pa2-p3.c:43: note: init: stmt relevant? # DEBUG i => i_125

pa2-p3.c:43: note: init: stmt relevant? # DEBUG j => 0

pa2-p3.c:43: note: init: phi relevant? j_130 = PHI <j_51(13), 0(17)>

pa2-p3.c:43: note: init: phi relevant? .MEM_135 = PHI <.MEM_50(13), .MEM_101(17)>

pa2-p3.c:43: note: init: phi relevant? ivtmp_119 = PHI <ivtmp_118(13), 2000(17)>

pa2-p3.c:43: note: init: stmt relevant? # DEBUG j => j_130

pa2-p3.c:43: note: init: stmt relevant? c[j_130][i_125] = 0.0;

pa2-p3.c:43: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:43: note: mark relevant 4, live 0.
pa2-p3.c:43: note: init: stmt relevant? j_51 = j_130 + 1;

pa2-p3.c:43: note: init: stmt relevant? # DEBUG j => j_51

pa2-p3.c:43: note: init: stmt relevant? # DEBUG j => j_51

pa2-p3.c:43: note: init: stmt relevant? ivtmp_118 = ivtmp_119 - 1;

pa2-p3.c:43: note: init: stmt relevant? if (ivtmp_118 != 0)

pa2-p3.c:43: note: init: stmt relevant? i_52 = i_125 + 1;

pa2-p3.c:43: note: init: stmt relevant? # DEBUG i => i_52

pa2-p3.c:43: note: init: stmt relevant? # DEBUG i => i_52

pa2-p3.c:43: note: init: stmt relevant? ivtmp_116 = ivtmp_117 - 1;

pa2-p3.c:43: note: init: stmt relevant? if (ivtmp_116 != 0)

pa2-p3.c:43: note: worklist: examine stmt: c[j_130][i_125] = 0.0;

pa2-p3.c:43: note: === vect_analyze_dependences ===
pa2-p3.c:43: note: === vect_determine_vectorization_factor ===
pa2-p3.c:43: note: ==> examining phi: .MEM_101 = PHI <.MEM_46(10), .MEM_50(16)>

pa2-p3.c:43: note: ==> examining phi: i_125 = PHI <0(10), i_52(16)>

pa2-p3.c:43: note: ==> examining phi: ivtmp_117 = PHI <2000(10), ivtmp_116(16)>

pa2-p3.c:43: note: ==> examining statement: # DEBUG i => i_125

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining statement: # DEBUG j => 0

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining phi: j_130 = PHI <j_51(13), 0(17)>

pa2-p3.c:43: note: ==> examining phi: .MEM_135 = PHI <.MEM_50(13), .MEM_101(17)>

pa2-p3.c:43: note: ==> examining phi: ivtmp_119 = PHI <ivtmp_118(13), 2000(17)>

pa2-p3.c:43: note: ==> examining statement: # DEBUG j => j_130

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining statement: c[j_130][i_125] = 0.0;

pa2-p3.c:43: note: get vectype for scalar type:  float
pa2-p3.c:43: note: get vectype with 4 units of type float
pa2-p3.c:43: note: vectype: vector(4) float
pa2-p3.c:43: note: vectype: vector(4) float
pa2-p3.c:43: note: nunits = 4
pa2-p3.c:43: note: ==> examining statement: j_51 = j_130 + 1;

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining statement: # DEBUG j => j_51

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining statement: # DEBUG j => j_51

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining statement: ivtmp_118 = ivtmp_119 - 1;

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining statement: if (ivtmp_118 != 0)

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining statement: i_52 = i_125 + 1;

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining statement: # DEBUG i => i_52

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining statement: # DEBUG i => i_52

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining statement: ivtmp_116 = ivtmp_117 - 1;

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: ==> examining statement: if (ivtmp_116 != 0)

pa2-p3.c:43: note: skip.
pa2-p3.c:43: note: vectorization factor = 4
pa2-p3.c:43: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:43: note: vect_compute_data_ref_alignment:
pa2-p3.c:43: note: inner step divides the vector-size.
pa2-p3.c:43: note: misalign = 0 bytes of ref c[j_130][i_125]
pa2-p3.c:43: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:43: note: === vect_prune_runtime_alias_test_list ===
pa2-p3.c:43: note: === vect_enhance_data_refs_alignment ===
pa2-p3.c:43: note: vect_can_advance_ivs_p:
pa2-p3.c:43: note: Analyze phi: .MEM_101 = PHI <.MEM_46(10), .MEM_50(16)>

pa2-p3.c:43: note: virtual phi. skip.
pa2-p3.c:43: note: Analyze phi: i_125 = PHI <0(10), i_52(16)>

pa2-p3.c:43: note: Access function of PHI: {0, +, 1}_3
pa2-p3.c:43: note: Analyze phi: ivtmp_117 = PHI <2000(10), ivtmp_116(16)>

pa2-p3.c:43: note: Access function of PHI: {2000, +, 4294967295}_3
pa2-p3.c:43: note: === vect_analyze_slp ===
pa2-p3.c:43: note: === vect_make_slp_decision ===
pa2-p3.c:43: note: === vect_detect_hybrid_slp ===
pa2-p3.c:43: note: === vect_analyze_loop_operations ===
pa2-p3.c:43: note: examining phi: .MEM_101 = PHI <.MEM_46(10), .MEM_50(16)>

pa2-p3.c:43: note: examining phi: i_125 = PHI <0(10), i_52(16)>

pa2-p3.c:43: note: examining phi: ivtmp_117 = PHI <2000(10), ivtmp_116(16)>

pa2-p3.c:43: note: ==> examining statement: # DEBUG i => i_125

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: ==> examining statement: # DEBUG j => 0

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: examining phi: j_130 = PHI <j_51(13), 0(17)>

pa2-p3.c:43: note: examining phi: .MEM_135 = PHI <.MEM_50(13), .MEM_101(17)>

pa2-p3.c:43: note: examining phi: ivtmp_119 = PHI <ivtmp_118(13), 2000(17)>

pa2-p3.c:43: note: ==> examining statement: # DEBUG j => j_130

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: ==> examining statement: c[j_130][i_125] = 0.0;

pa2-p3.c:43: note: vect_is_simple_use: operand 0.0
pa2-p3.c:43: note: vect_model_store_cost: aligned.
pa2-p3.c:43: note: vect_model_store_cost: inside_cost = 50, prologue_cost = 1 .
pa2-p3.c:43: note: ==> examining statement: j_51 = j_130 + 1;

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: ==> examining statement: # DEBUG j => j_51

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: ==> examining statement: # DEBUG j => j_51

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: ==> examining statement: ivtmp_118 = ivtmp_119 - 1;

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: ==> examining statement: if (ivtmp_118 != 0)

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: ==> examining statement: i_52 = i_125 + 1;

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: ==> examining statement: # DEBUG i => i_52

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: ==> examining statement: # DEBUG i => i_52

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: ==> examining statement: ivtmp_116 = ivtmp_117 - 1;

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: ==> examining statement: if (ivtmp_116 != 0)

pa2-p3.c:43: note: irrelevant.
pa2-p3.c:43: note: vectorization_factor = 4, niters = 2000
pa2-p3.c:43: note: === vect_update_slp_costs_according_to_vf ===
pa2-p3.c:43: note: Cost model analysis: 
  Vector inside of loop cost: 50
  Vector prologue cost: 1
  Vector epilogue cost: 0
  Scalar iteration cost: 50
  Scalar outside cost: 0
  Vector outside cost: 1
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

pa2-p3.c:43: note:   Runtime profitability threshold = 3

pa2-p3.c:43: note:   Static estimate profitability threshold = 3


Vectorizing loop at pa2-p3.c:43

pa2-p3.c:43: note: === vec_transform_loop ===
pa2-p3.c:43: note: ------>vectorizing phi: .MEM_101 = PHI <.MEM_46(44), .MEM_50(16)>

pa2-p3.c:43: note: ------>vectorizing phi: i_125 = PHI <0(44), i_52(16)>

pa2-p3.c:43: note: ------>vectorizing phi: ivtmp_117 = PHI <2000(44), ivtmp_116(16)>

pa2-p3.c:43: note: ------>vectorizing statement: # DEBUG i => i_125

pa2-p3.c:43: note: ------>vectorizing statement: # DEBUG j => 0

pa2-p3.c:43: note: ------>vectorizing phi: j_130 = PHI <j_51(13), 0(17)>

pa2-p3.c:43: note: ------>vectorizing phi: .MEM_135 = PHI <.MEM_50(13), .MEM_101(17)>

pa2-p3.c:43: note: ------>vectorizing phi: ivtmp_119 = PHI <ivtmp_118(13), 2000(17)>

pa2-p3.c:43: note: ------>vectorizing statement: # DEBUG j => j_130

pa2-p3.c:43: note: ------>vectorizing statement: c[j_130][i_125] = 0.0;

pa2-p3.c:43: note: transform statement.
pa2-p3.c:43: note: vect_is_simple_use: operand 0.0
pa2-p3.c:43: note: transform store. ncopies = 1
pa2-p3.c:43: note: vect_get_vec_def_for_operand: 0.0
pa2-p3.c:43: note: vect_is_simple_use: operand 0.0
pa2-p3.c:43: note: get vectype with 4 units of type float
pa2-p3.c:43: note: vectype: vector(4) float
pa2-p3.c:43: note: Create vector_cst. nunits = 4
pa2-p3.c:43: note: created new init_stmt: vect_cst_.299_1 = { 0.0, 0.0, 0.0, 0.0 };

pa2-p3.c:43: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: c
pa2-p3.c:43: note: created vect_pc.303_153
pa2-p3.c:43: note: add new stmt: MEM[(float[2000][2000] *)vect_pc.300_150] = vect_cst_.299_1;

pa2-p3.c:43: note: ------>vectorizing statement: j_51 = j_130 + 1;

pa2-p3.c:43: note: ------>vectorizing statement: # DEBUG j => j_51

pa2-p3.c:43: note: ------>vectorizing statement: # DEBUG j => j_51

pa2-p3.c:43: note: ------>vectorizing statement: ivtmp_118 = ivtmp_119 - 1;

pa2-p3.c:43: note: ------>vectorizing statement: vect_pc.300_145 = vect_pc.300_150 + 8000;

pa2-p3.c:43: note: ------>vectorizing statement: if (ivtmp_118 != 0)

pa2-p3.c:43: note: ------>vectorizing statement: i_52 = i_125 + 1;

pa2-p3.c:43: note: ------>vectorizing statement: # DEBUG i => i_52

pa2-p3.c:43: note: ------>vectorizing statement: # DEBUG i => i_52

pa2-p3.c:43: note: ------>vectorizing statement: ivtmp_116 = ivtmp_117 - 1;

pa2-p3.c:43: note: ------>vectorizing statement: vect_pc.300_151 = vect_pc.300_152 + 16;

pa2-p3.c:43: note: ------>vectorizing statement: if (ivtmp_116 != 0)
if (ivtmp_138 < 500)

pa2-p3.c:43: note: LOOP VECTORIZED.
pa2-p3.c:43: note: OUTER LOOP VECTORIZED.
Analyzing loop at pa2-p3.c:43

pa2-p3.c:43: note: ===== analyze_loop_nest =====
pa2-p3.c:43: note: outer-loop already vectorized.
Analyzing loop at pa2-p3.c:37

pa2-p3.c:37: note: ===== analyze_loop_nest =====
pa2-p3.c:37: note: === vect_analyze_loop_form ===
pa2-p3.c:37: note: ===== analyze_loop_nest_1 =====
pa2-p3.c:37: note: === vect_analyze_loop_form ===
pa2-p3.c:37: note: === get_loop_niters ===
pa2-p3.c:37: note: ==> get_loop_niters:2000
pa2-p3.c:37: note: Considering outer-loop vectorization.
pa2-p3.c:37: note: === get_loop_niters ===
pa2-p3.c:37: note: ==> get_loop_niters:2000
pa2-p3.c:37: note: === vect_analyze_data_refs ===

pa2-p3.c:37: note: analyze in outer-loop: a
pa2-p3.c:37: note: 	outer base_address: &a
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 8000
	outer aligned to: 128
pa2-p3.c:37: note: get vectype with 4 units of type float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: analyze in outer-loop: b
pa2-p3.c:37: note: 	outer base_address: &b
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 8000
	outer aligned to: 128
pa2-p3.c:37: note: get vectype with 4 units of type float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:37: note: Analyze phi: .MEM_103 = PHI <.MEM_33(6), .MEM_46(11)>

pa2-p3.c:37: note: Analyze phi: i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:37: note: Access function of PHI: {0, +, 1}_1
pa2-p3.c:37: note: step: 1,  init: 0
pa2-p3.c:37: note: Detected induction.
pa2-p3.c:37: note: Analyze phi: ivtmp_111 = PHI <2000(6), ivtmp_110(11)>

pa2-p3.c:37: note: Access function of PHI: {2000, +, 4294967295}_1
pa2-p3.c:37: note: step: 4294967295,  init: 2000
pa2-p3.c:37: note: Detected induction.
pa2-p3.c:37: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:37: note: Analyze phi: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:37: note: Access function of PHI: {0, +, 1}_2
pa2-p3.c:37: note: step: 1,  init: 0
pa2-p3.c:37: note: Detected induction.
pa2-p3.c:37: note: Analyze phi: .MEM_134 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p3.c:37: note: Analyze phi: ivtmp_115 = PHI <ivtmp_112(7), 2000(12)>

pa2-p3.c:37: note: Access function of PHI: {2000, +, 4294967295}_2
pa2-p3.c:37: note: step: 4294967295,  init: 2000
pa2-p3.c:37: note: Detected induction.
pa2-p3.c:37: note: === vect_pattern_recog ===
pa2-p3.c:37: note: vect_is_simple_use: operand i_124
pa2-p3.c:37: note: def_stmt: i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:37: note: type of def: 4.
pa2-p3.c:37: note: vect_is_simple_use: operand _37
pa2-p3.c:37: note: def_stmt: _37 = (double) _36;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: vect_is_simple_use: operand j_129
pa2-p3.c:37: note: def_stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:37: note: type of def: 4.
pa2-p3.c:37: note: vect_is_simple_use: operand _43
pa2-p3.c:37: note: def_stmt: _43 = (double) _42;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p3.c:37: note: init: phi relevant? .MEM_103 = PHI <.MEM_33(6), .MEM_46(11)>

pa2-p3.c:37: note: init: phi relevant? i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:37: note: init: phi relevant? ivtmp_111 = PHI <2000(6), ivtmp_110(11)>

pa2-p3.c:37: note: init: stmt relevant? # DEBUG i => i_124

pa2-p3.c:37: note: init: stmt relevant? # DEBUG j => 0

pa2-p3.c:37: note: init: stmt relevant? pretmp_14 = i_124 * 2;

pa2-p3.c:37: note: init: phi relevant? j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:37: note: init: phi relevant? .MEM_134 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p3.c:37: note: init: phi relevant? ivtmp_115 = PHI <ivtmp_112(7), 2000(12)>

pa2-p3.c:37: note: init: stmt relevant? # DEBUG j => j_129

pa2-p3.c:37: note: init: stmt relevant? _36 = pretmp_14 + j_129;

pa2-p3.c:37: note: init: stmt relevant? _37 = (double) _36;

pa2-p3.c:37: note: init: stmt relevant? _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:37: note: init: stmt relevant? _39 = (float) _38;

pa2-p3.c:37: note: init: stmt relevant? a[i_124][j_129] = _39;

pa2-p3.c:37: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: init: stmt relevant? _41 = j_129 * 2;

pa2-p3.c:37: note: init: stmt relevant? _42 = _41 + i_124;

pa2-p3.c:37: note: init: stmt relevant? _43 = (double) _42;

pa2-p3.c:37: note: init: stmt relevant? _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:37: note: init: stmt relevant? _45 = (float) _44;

pa2-p3.c:37: note: init: stmt relevant? b[i_124][j_129] = _45;

pa2-p3.c:37: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: init: stmt relevant? j_47 = j_129 + 1;

pa2-p3.c:37: note: init: stmt relevant? # DEBUG j => j_47

pa2-p3.c:37: note: init: stmt relevant? # DEBUG j => j_47

pa2-p3.c:37: note: init: stmt relevant? ivtmp_112 = ivtmp_115 - 1;

pa2-p3.c:37: note: init: stmt relevant? if (ivtmp_112 != 0)

pa2-p3.c:37: note: init: stmt relevant? i_48 = i_124 + 1;

pa2-p3.c:37: note: init: stmt relevant? # DEBUG i => i_48

pa2-p3.c:37: note: init: stmt relevant? # DEBUG i => i_48

pa2-p3.c:37: note: init: stmt relevant? ivtmp_110 = ivtmp_111 - 1;

pa2-p3.c:37: note: init: stmt relevant? if (ivtmp_110 != 0)

pa2-p3.c:37: note: worklist: examine stmt: b[i_124][j_129] = _45;

pa2-p3.c:37: note: vect_is_simple_use: operand _45
pa2-p3.c:37: note: def_stmt: _45 = (float) _44;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: worklist: examine stmt: _45 = (float) _44;

pa2-p3.c:37: note: vect_is_simple_use: operand _44
pa2-p3.c:37: note: def_stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: worklist: examine stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:37: note: vect_is_simple_use: operand _43
pa2-p3.c:37: note: def_stmt: _43 = (double) _42;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: worklist: examine stmt: _43 = (double) _42;

pa2-p3.c:37: note: vect_is_simple_use: operand _42
pa2-p3.c:37: note: def_stmt: _42 = _41 + i_124;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: worklist: examine stmt: _42 = _41 + i_124;

pa2-p3.c:37: note: vect_is_simple_use: operand _41
pa2-p3.c:37: note: def_stmt: _41 = j_129 * 2;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: vect_is_simple_use: operand i_124
pa2-p3.c:37: note: def_stmt: i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:37: note: type of def: 4.
pa2-p3.c:37: note: outer-loop def-stmt defining inner-loop stmt.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: worklist: examine stmt: i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:37: note: vect_is_simple_use: operand 0
pa2-p3.c:37: note: vect_is_simple_use: operand i_48
pa2-p3.c:37: note: def_stmt: i_48 = i_124 + 1;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: worklist: examine stmt: i_48 = i_124 + 1;

pa2-p3.c:37: note: vect_is_simple_use: operand i_124
pa2-p3.c:37: note: def_stmt: i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:37: note: type of def: 4.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: already marked relevant/live.
pa2-p3.c:37: note: worklist: examine stmt: _41 = j_129 * 2;

pa2-p3.c:37: note: vect_is_simple_use: operand j_129
pa2-p3.c:37: note: def_stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:37: note: type of def: 4.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: worklist: examine stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:37: note: vect_is_simple_use: operand j_47
pa2-p3.c:37: note: def_stmt: j_47 = j_129 + 1;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: vect_is_simple_use: operand 0
pa2-p3.c:37: note: worklist: examine stmt: j_47 = j_129 + 1;

pa2-p3.c:37: note: vect_is_simple_use: operand j_129
pa2-p3.c:37: note: def_stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:37: note: type of def: 4.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: already marked relevant/live.
pa2-p3.c:37: note: worklist: examine stmt: a[i_124][j_129] = _39;

pa2-p3.c:37: note: vect_is_simple_use: operand _39
pa2-p3.c:37: note: def_stmt: _39 = (float) _38;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: worklist: examine stmt: _39 = (float) _38;

pa2-p3.c:37: note: vect_is_simple_use: operand _38
pa2-p3.c:37: note: def_stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: worklist: examine stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:37: note: vect_is_simple_use: operand _37
pa2-p3.c:37: note: def_stmt: _37 = (double) _36;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: worklist: examine stmt: _37 = (double) _36;

pa2-p3.c:37: note: vect_is_simple_use: operand _36
pa2-p3.c:37: note: def_stmt: _36 = pretmp_14 + j_129;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: worklist: examine stmt: _36 = pretmp_14 + j_129;

pa2-p3.c:37: note: vect_is_simple_use: operand pretmp_14
pa2-p3.c:37: note: def_stmt: pretmp_14 = i_124 * 2;

pa2-p3.c:37: note: type of def: 3.
pa2-p3.c:37: note: outer-loop def-stmt defining inner-loop stmt.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: vect_is_simple_use: operand j_129
pa2-p3.c:37: note: def_stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:37: note: type of def: 4.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: already marked relevant/live.
pa2-p3.c:37: note: worklist: examine stmt: pretmp_14 = i_124 * 2;

pa2-p3.c:37: note: vect_is_simple_use: operand i_124
pa2-p3.c:37: note: def_stmt: i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:37: note: type of def: 4.
pa2-p3.c:37: note: mark relevant 4, live 0.
pa2-p3.c:37: note: already marked relevant/live.
pa2-p3.c:37: note: === vect_analyze_dependences ===
pa2-p3.c:37: note: === vect_determine_vectorization_factor ===
pa2-p3.c:37: note: ==> examining phi: .MEM_103 = PHI <.MEM_33(6), .MEM_46(11)>

pa2-p3.c:37: note: ==> examining phi: i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining phi: ivtmp_111 = PHI <2000(6), ivtmp_110(11)>

pa2-p3.c:37: note: ==> examining statement: # DEBUG i => i_124

pa2-p3.c:37: note: skip.
pa2-p3.c:37: note: ==> examining statement: # DEBUG j => 0

pa2-p3.c:37: note: skip.
pa2-p3.c:37: note: ==> examining statement: pretmp_14 = i_124 * 2;

pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining phi: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining phi: .MEM_134 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p3.c:37: note: ==> examining phi: ivtmp_115 = PHI <ivtmp_112(7), 2000(12)>

pa2-p3.c:37: note: ==> examining statement: # DEBUG j => j_129

pa2-p3.c:37: note: skip.
pa2-p3.c:37: note: ==> examining statement: _36 = pretmp_14 + j_129;

pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining statement: _37 = (double) _36;

pa2-p3.c:37: note: get vectype for scalar type:  double
pa2-p3.c:37: note: get vectype with 2 units of type double
pa2-p3.c:37: note: vectype: vector(2) double
pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining statement: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:37: note: get vectype for scalar type:  double
pa2-p3.c:37: note: get vectype with 2 units of type double
pa2-p3.c:37: note: vectype: vector(2) double
pa2-p3.c:37: note: get vectype for scalar type:  double
pa2-p3.c:37: note: get vectype with 2 units of type double
pa2-p3.c:37: note: vectype: vector(2) double
pa2-p3.c:37: note: vectype: vector(2) double
pa2-p3.c:37: note: nunits = 2
pa2-p3.c:37: note: ==> examining statement: _39 = (float) _38;

pa2-p3.c:37: note: get vectype for scalar type:  float
pa2-p3.c:37: note: get vectype with 4 units of type float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: get vectype for scalar type:  float
pa2-p3.c:37: note: get vectype with 4 units of type float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining statement: a[i_124][j_129] = _39;

pa2-p3.c:37: note: get vectype for scalar type:  float
pa2-p3.c:37: note: get vectype with 4 units of type float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining statement: _41 = j_129 * 2;

pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining statement: _42 = _41 + i_124;

pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining statement: _43 = (double) _42;

pa2-p3.c:37: note: get vectype for scalar type:  double
pa2-p3.c:37: note: get vectype with 2 units of type double
pa2-p3.c:37: note: vectype: vector(2) double
pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining statement: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:37: note: get vectype for scalar type:  double
pa2-p3.c:37: note: get vectype with 2 units of type double
pa2-p3.c:37: note: vectype: vector(2) double
pa2-p3.c:37: note: get vectype for scalar type:  double
pa2-p3.c:37: note: get vectype with 2 units of type double
pa2-p3.c:37: note: vectype: vector(2) double
pa2-p3.c:37: note: vectype: vector(2) double
pa2-p3.c:37: note: nunits = 2
pa2-p3.c:37: note: ==> examining statement: _45 = (float) _44;

pa2-p3.c:37: note: get vectype for scalar type:  float
pa2-p3.c:37: note: get vectype with 4 units of type float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: get vectype for scalar type:  float
pa2-p3.c:37: note: get vectype with 4 units of type float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining statement: b[i_124][j_129] = _45;

pa2-p3.c:37: note: get vectype for scalar type:  float
pa2-p3.c:37: note: get vectype with 4 units of type float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: vectype: vector(4) float
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining statement: j_47 = j_129 + 1;

pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining statement: # DEBUG j => j_47

pa2-p3.c:37: note: skip.
pa2-p3.c:37: note: ==> examining statement: # DEBUG j => j_47

pa2-p3.c:37: note: skip.
pa2-p3.c:37: note: ==> examining statement: ivtmp_112 = ivtmp_115 - 1;

pa2-p3.c:37: note: skip.
pa2-p3.c:37: note: ==> examining statement: if (ivtmp_112 != 0)

pa2-p3.c:37: note: skip.
pa2-p3.c:37: note: ==> examining statement: i_48 = i_124 + 1;

pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: get vectype for scalar type:  int
pa2-p3.c:37: note: get vectype with 4 units of type int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: vectype: vector(4) int
pa2-p3.c:37: note: nunits = 4
pa2-p3.c:37: note: ==> examining statement: # DEBUG i => i_48

pa2-p3.c:37: note: skip.
pa2-p3.c:37: note: ==> examining statement: # DEBUG i => i_48

pa2-p3.c:37: note: skip.
pa2-p3.c:37: note: ==> examining statement: ivtmp_110 = ivtmp_111 - 1;

pa2-p3.c:37: note: skip.
pa2-p3.c:37: note: ==> examining statement: if (ivtmp_110 != 0)

pa2-p3.c:37: note: skip.
pa2-p3.c:37: note: vectorization factor = 4
pa2-p3.c:37: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:37: note: vect_compute_data_ref_alignment:
pa2-p3.c:37: note: inner step doesn't divide the vector-size.
pa2-p3.c:37: note: Unknown alignment for access: a
pa2-p3.c:37: note: vect_compute_data_ref_alignment:
pa2-p3.c:37: note: inner step doesn't divide the vector-size.
pa2-p3.c:37: note: Unknown alignment for access: b
pa2-p3.c:37: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:37: note: grouped access in outer loop.
pa2-p3.c:37: note: not vectorized: complicated access pattern.
pa2-p3.c:37: note: bad data access.
Analyzing loop at pa2-p3.c:38

pa2-p3.c:38: note: ===== analyze_loop_nest =====
pa2-p3.c:38: note: === vect_analyze_loop_form ===
pa2-p3.c:38: note: === get_loop_niters ===
pa2-p3.c:38: note: ==> get_loop_niters:2000
pa2-p3.c:38: note: === vect_analyze_data_refs ===

pa2-p3.c:38: note: get vectype with 4 units of type float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: get vectype with 4 units of type float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: === vect_analyze_scalar_cycles ===
pa2-p3.c:38: note: Analyze phi: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: Access function of PHI: {0, +, 1}_2
pa2-p3.c:38: note: step: 1,  init: 0
pa2-p3.c:38: note: Detected induction.
pa2-p3.c:38: note: Analyze phi: .MEM_134 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p3.c:38: note: Analyze phi: ivtmp_115 = PHI <ivtmp_112(7), 2000(12)>

pa2-p3.c:38: note: Access function of PHI: {2000, +, 4294967295}_2
pa2-p3.c:38: note: step: 4294967295,  init: 2000
pa2-p3.c:38: note: Detected induction.
pa2-p3.c:38: note: === vect_pattern_recog ===
pa2-p3.c:38: note: vect_is_simple_use: operand _37
pa2-p3.c:38: note: def_stmt: _37 = (double) _36;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: vect_is_simple_use: operand _43
pa2-p3.c:38: note: def_stmt: _43 = (double) _42;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: === vect_mark_stmts_to_be_vectorized ===
pa2-p3.c:38: note: init: phi relevant? j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: init: phi relevant? .MEM_134 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p3.c:38: note: init: phi relevant? ivtmp_115 = PHI <ivtmp_112(7), 2000(12)>

pa2-p3.c:38: note: init: stmt relevant? # DEBUG j => j_129

pa2-p3.c:38: note: init: stmt relevant? _36 = pretmp_14 + j_129;

pa2-p3.c:38: note: init: stmt relevant? _37 = (double) _36;

pa2-p3.c:38: note: init: stmt relevant? _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:38: note: init: stmt relevant? _39 = (float) _38;

pa2-p3.c:38: note: init: stmt relevant? a[i_124][j_129] = _39;

pa2-p3.c:38: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: init: stmt relevant? _41 = j_129 * 2;

pa2-p3.c:38: note: init: stmt relevant? _42 = _41 + i_124;

pa2-p3.c:38: note: init: stmt relevant? _43 = (double) _42;

pa2-p3.c:38: note: init: stmt relevant? _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:38: note: init: stmt relevant? _45 = (float) _44;

pa2-p3.c:38: note: init: stmt relevant? b[i_124][j_129] = _45;

pa2-p3.c:38: note: vec_stmt_relevant_p: stmt has vdefs.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: init: stmt relevant? j_47 = j_129 + 1;

pa2-p3.c:38: note: init: stmt relevant? # DEBUG j => j_47

pa2-p3.c:38: note: init: stmt relevant? # DEBUG j => j_47

pa2-p3.c:38: note: init: stmt relevant? ivtmp_112 = ivtmp_115 - 1;

pa2-p3.c:38: note: init: stmt relevant? if (ivtmp_112 != 0)

pa2-p3.c:38: note: worklist: examine stmt: b[i_124][j_129] = _45;

pa2-p3.c:38: note: vect_is_simple_use: operand _45
pa2-p3.c:38: note: def_stmt: _45 = (float) _44;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: worklist: examine stmt: _45 = (float) _44;

pa2-p3.c:38: note: vect_is_simple_use: operand _44
pa2-p3.c:38: note: def_stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: worklist: examine stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:38: note: vect_is_simple_use: operand _43
pa2-p3.c:38: note: def_stmt: _43 = (double) _42;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: worklist: examine stmt: _43 = (double) _42;

pa2-p3.c:38: note: vect_is_simple_use: operand _42
pa2-p3.c:38: note: def_stmt: _42 = _41 + i_124;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: worklist: examine stmt: _42 = _41 + i_124;

pa2-p3.c:38: note: vect_is_simple_use: operand _41
pa2-p3.c:38: note: def_stmt: _41 = j_129 * 2;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: vect_is_simple_use: operand i_124
pa2-p3.c:38: note: def_stmt: i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:38: note: type of def: 2.
pa2-p3.c:38: note: def_stmt is out of loop.
pa2-p3.c:38: note: worklist: examine stmt: _41 = j_129 * 2;

pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: worklist: examine stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: vect_is_simple_use: operand j_47
pa2-p3.c:38: note: def_stmt: j_47 = j_129 + 1;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: vect_is_simple_use: operand 0
pa2-p3.c:38: note: worklist: examine stmt: j_47 = j_129 + 1;

pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: already marked relevant/live.
pa2-p3.c:38: note: worklist: examine stmt: a[i_124][j_129] = _39;

pa2-p3.c:38: note: vect_is_simple_use: operand _39
pa2-p3.c:38: note: def_stmt: _39 = (float) _38;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: worklist: examine stmt: _39 = (float) _38;

pa2-p3.c:38: note: vect_is_simple_use: operand _38
pa2-p3.c:38: note: def_stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: worklist: examine stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:38: note: vect_is_simple_use: operand _37
pa2-p3.c:38: note: def_stmt: _37 = (double) _36;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: worklist: examine stmt: _37 = (double) _36;

pa2-p3.c:38: note: vect_is_simple_use: operand _36
pa2-p3.c:38: note: def_stmt: _36 = pretmp_14 + j_129;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: worklist: examine stmt: _36 = pretmp_14 + j_129;

pa2-p3.c:38: note: vect_is_simple_use: operand pretmp_14
pa2-p3.c:38: note: def_stmt: pretmp_14 = i_124 * 2;

pa2-p3.c:38: note: type of def: 2.
pa2-p3.c:38: note: def_stmt is out of loop.
pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: mark relevant 4, live 0.
pa2-p3.c:38: note: already marked relevant/live.
pa2-p3.c:38: note: === vect_analyze_dependences ===
pa2-p3.c:38: note: === vect_determine_vectorization_factor ===
pa2-p3.c:38: note: ==> examining phi: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: get vectype for scalar type:  int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: nunits = 4
pa2-p3.c:38: note: ==> examining phi: .MEM_134 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p3.c:38: note: ==> examining phi: ivtmp_115 = PHI <ivtmp_112(7), 2000(12)>

pa2-p3.c:38: note: ==> examining statement: # DEBUG j => j_129

pa2-p3.c:38: note: skip.
pa2-p3.c:38: note: ==> examining statement: _36 = pretmp_14 + j_129;

pa2-p3.c:38: note: get vectype for scalar type:  int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: get vectype for scalar type:  int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: nunits = 4
pa2-p3.c:38: note: ==> examining statement: _37 = (double) _36;

pa2-p3.c:38: note: get vectype for scalar type:  double
pa2-p3.c:38: note: get vectype with 2 units of type double
pa2-p3.c:38: note: vectype: vector(2) double
pa2-p3.c:38: note: get vectype for scalar type:  int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: nunits = 4
pa2-p3.c:38: note: ==> examining statement: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:38: note: get vectype for scalar type:  double
pa2-p3.c:38: note: get vectype with 2 units of type double
pa2-p3.c:38: note: vectype: vector(2) double
pa2-p3.c:38: note: get vectype for scalar type:  double
pa2-p3.c:38: note: get vectype with 2 units of type double
pa2-p3.c:38: note: vectype: vector(2) double
pa2-p3.c:38: note: vectype: vector(2) double
pa2-p3.c:38: note: nunits = 2
pa2-p3.c:38: note: ==> examining statement: _39 = (float) _38;

pa2-p3.c:38: note: get vectype for scalar type:  float
pa2-p3.c:38: note: get vectype with 4 units of type float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: get vectype for scalar type:  float
pa2-p3.c:38: note: get vectype with 4 units of type float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: nunits = 4
pa2-p3.c:38: note: ==> examining statement: a[i_124][j_129] = _39;

pa2-p3.c:38: note: get vectype for scalar type:  float
pa2-p3.c:38: note: get vectype with 4 units of type float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: nunits = 4
pa2-p3.c:38: note: ==> examining statement: _41 = j_129 * 2;

pa2-p3.c:38: note: get vectype for scalar type:  int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: get vectype for scalar type:  int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: nunits = 4
pa2-p3.c:38: note: ==> examining statement: _42 = _41 + i_124;

pa2-p3.c:38: note: get vectype for scalar type:  int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: get vectype for scalar type:  int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: nunits = 4
pa2-p3.c:38: note: ==> examining statement: _43 = (double) _42;

pa2-p3.c:38: note: get vectype for scalar type:  double
pa2-p3.c:38: note: get vectype with 2 units of type double
pa2-p3.c:38: note: vectype: vector(2) double
pa2-p3.c:38: note: get vectype for scalar type:  int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: nunits = 4
pa2-p3.c:38: note: ==> examining statement: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:38: note: get vectype for scalar type:  double
pa2-p3.c:38: note: get vectype with 2 units of type double
pa2-p3.c:38: note: vectype: vector(2) double
pa2-p3.c:38: note: get vectype for scalar type:  double
pa2-p3.c:38: note: get vectype with 2 units of type double
pa2-p3.c:38: note: vectype: vector(2) double
pa2-p3.c:38: note: vectype: vector(2) double
pa2-p3.c:38: note: nunits = 2
pa2-p3.c:38: note: ==> examining statement: _45 = (float) _44;

pa2-p3.c:38: note: get vectype for scalar type:  float
pa2-p3.c:38: note: get vectype with 4 units of type float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: get vectype for scalar type:  float
pa2-p3.c:38: note: get vectype with 4 units of type float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: nunits = 4
pa2-p3.c:38: note: ==> examining statement: b[i_124][j_129] = _45;

pa2-p3.c:38: note: get vectype for scalar type:  float
pa2-p3.c:38: note: get vectype with 4 units of type float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: vectype: vector(4) float
pa2-p3.c:38: note: nunits = 4
pa2-p3.c:38: note: ==> examining statement: j_47 = j_129 + 1;

pa2-p3.c:38: note: get vectype for scalar type:  int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: get vectype for scalar type:  int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: nunits = 4
pa2-p3.c:38: note: ==> examining statement: # DEBUG j => j_47

pa2-p3.c:38: note: skip.
pa2-p3.c:38: note: ==> examining statement: # DEBUG j => j_47

pa2-p3.c:38: note: skip.
pa2-p3.c:38: note: ==> examining statement: ivtmp_112 = ivtmp_115 - 1;

pa2-p3.c:38: note: skip.
pa2-p3.c:38: note: ==> examining statement: if (ivtmp_112 != 0)

pa2-p3.c:38: note: skip.
pa2-p3.c:38: note: vectorization factor = 4
pa2-p3.c:38: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:38: note: vect_compute_data_ref_alignment:
pa2-p3.c:38: note: misalign = 0 bytes of ref a[i_124][j_129]
pa2-p3.c:38: note: vect_compute_data_ref_alignment:
pa2-p3.c:38: note: misalign = 0 bytes of ref b[i_124][j_129]
pa2-p3.c:38: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:38: note: === vect_prune_runtime_alias_test_list ===
pa2-p3.c:38: note: === vect_enhance_data_refs_alignment ===
pa2-p3.c:38: note: vect_can_advance_ivs_p:
pa2-p3.c:38: note: Analyze phi: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: Access function of PHI: {0, +, 1}_2
pa2-p3.c:38: note: Analyze phi: .MEM_134 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p3.c:38: note: virtual phi. skip.
pa2-p3.c:38: note: Analyze phi: ivtmp_115 = PHI <ivtmp_112(7), 2000(12)>

pa2-p3.c:38: note: Access function of PHI: {2000, +, 4294967295}_2
pa2-p3.c:38: note: vect_model_store_cost: aligned.
pa2-p3.c:38: note: vect_get_data_access_cost: inside_cost = 1, outside_cost = 0.
pa2-p3.c:38: note: vect_model_store_cost: aligned.
pa2-p3.c:38: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
pa2-p3.c:38: note: === vect_analyze_slp ===
pa2-p3.c:38: note: === vect_make_slp_decision ===
pa2-p3.c:38: note: === vect_detect_hybrid_slp ===
pa2-p3.c:38: note: === vect_analyze_loop_operations ===
pa2-p3.c:38: note: examining phi: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: === vectorizable_induction ===
pa2-p3.c:38: note: vect_model_induction_cost: inside_cost = 1, prologue_cost = 2 .
pa2-p3.c:38: note: examining phi: .MEM_134 = PHI <.MEM_46(7), .MEM_103(12)>

pa2-p3.c:38: note: examining phi: ivtmp_115 = PHI <ivtmp_112(7), 2000(12)>

pa2-p3.c:38: note: ==> examining statement: # DEBUG j => j_129

pa2-p3.c:38: note: irrelevant.
pa2-p3.c:38: note: ==> examining statement: _36 = pretmp_14 + j_129;

pa2-p3.c:38: note: vect_is_simple_use: operand pretmp_14
pa2-p3.c:38: note: def_stmt: pretmp_14 = i_124 * 2;

pa2-p3.c:38: note: type of def: 2.
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: === vectorizable_operation ===
pa2-p3.c:38: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p3.c:38: note: ==> examining statement: _37 = (double) _36;

pa2-p3.c:38: note: vect_is_simple_use: operand _36
pa2-p3.c:38: note: def_stmt: _36 = pretmp_14 + j_129;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: === vectorizable_conversion ===
pa2-p3.c:38: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:38: note: ==> examining statement: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:38: note: vect_is_simple_use: operand _37
pa2-p3.c:38: note: def_stmt: _37 = (double) _36;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: vect_is_simple_use: operand 1.100000000000000088817841970012523233890533447265625e+0
pa2-p3.c:38: note: === vectorizable_operation ===
pa2-p3.c:38: note: vect_model_simple_cost: inside_cost = 2, prologue_cost = 1 .
pa2-p3.c:38: note: ==> examining statement: _39 = (float) _38;

pa2-p3.c:38: note: vect_is_simple_use: operand _38
pa2-p3.c:38: note: def_stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: === vectorizable_conversion ===
pa2-p3.c:38: note: vect_model_promotion_demotion_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:38: note: ==> examining statement: a[i_124][j_129] = _39;

pa2-p3.c:38: note: vect_is_simple_use: operand _39
pa2-p3.c:38: note: def_stmt: _39 = (float) _38;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: vect_model_store_cost: aligned.
pa2-p3.c:38: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:38: note: ==> examining statement: _41 = j_129 * 2;

pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: vect_is_simple_use: operand 2
pa2-p3.c:38: note: === vectorizable_operation ===
pa2-p3.c:38: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p3.c:38: note: ==> examining statement: _42 = _41 + i_124;

pa2-p3.c:38: note: vect_is_simple_use: operand _41
pa2-p3.c:38: note: def_stmt: _41 = j_129 * 2;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: vect_is_simple_use: operand i_124
pa2-p3.c:38: note: def_stmt: i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:38: note: type of def: 2.
pa2-p3.c:38: note: === vectorizable_operation ===
pa2-p3.c:38: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p3.c:38: note: ==> examining statement: _43 = (double) _42;

pa2-p3.c:38: note: vect_is_simple_use: operand _42
pa2-p3.c:38: note: def_stmt: _42 = _41 + i_124;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: === vectorizable_conversion ===
pa2-p3.c:38: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:38: note: ==> examining statement: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:38: note: vect_is_simple_use: operand _43
pa2-p3.c:38: note: def_stmt: _43 = (double) _42;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: vect_is_simple_use: operand 1.1999999999999999555910790149937383830547332763671875e+0
pa2-p3.c:38: note: === vectorizable_operation ===
pa2-p3.c:38: note: vect_model_simple_cost: inside_cost = 2, prologue_cost = 1 .
pa2-p3.c:38: note: ==> examining statement: _45 = (float) _44;

pa2-p3.c:38: note: vect_is_simple_use: operand _44
pa2-p3.c:38: note: def_stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: === vectorizable_conversion ===
pa2-p3.c:38: note: vect_model_promotion_demotion_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:38: note: ==> examining statement: b[i_124][j_129] = _45;

pa2-p3.c:38: note: vect_is_simple_use: operand _45
pa2-p3.c:38: note: def_stmt: _45 = (float) _44;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: vect_model_store_cost: aligned.
pa2-p3.c:38: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa2-p3.c:38: note: ==> examining statement: j_47 = j_129 + 1;

pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(12)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: vect_is_simple_use: operand 1
pa2-p3.c:38: note: === vectorizable_operation ===
pa2-p3.c:38: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa2-p3.c:38: note: ==> examining statement: # DEBUG j => j_47

pa2-p3.c:38: note: irrelevant.
pa2-p3.c:38: note: ==> examining statement: # DEBUG j => j_47

pa2-p3.c:38: note: irrelevant.
pa2-p3.c:38: note: ==> examining statement: ivtmp_112 = ivtmp_115 - 1;

pa2-p3.c:38: note: irrelevant.
pa2-p3.c:38: note: ==> examining statement: if (ivtmp_112 != 0)

pa2-p3.c:38: note: irrelevant.
pa2-p3.c:38: note: vectorization_factor = 4, niters = 2000
pa2-p3.c:38: note: === vect_update_slp_costs_according_to_vf ===
pa2-p3.c:38: note: Cost model analysis: 
  Vector inside of loop cost: 15
  Vector prologue cost: 8
  Vector epilogue cost: 0
  Scalar iteration cost: 12
  Scalar outside cost: 0
  Vector outside cost: 8
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

pa2-p3.c:38: note:   Runtime profitability threshold = 3

pa2-p3.c:38: note:   Static estimate profitability threshold = 3


Vectorizing loop at pa2-p3.c:38

pa2-p3.c:38: note: === vec_transform_loop ===
pa2-p3.c:38: note: ------>vectorizing phi: j_129 = PHI <j_47(7), 0(45)>

pa2-p3.c:38: note: transform phi.
pa2-p3.c:38: note: transform induction phi.
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: created new init_stmt: stmp_var_.304_114 = 0 + 1;

pa2-p3.c:38: note: created new init_stmt: stmp_var_.304_113 = stmp_var_.304_114 + 1;

pa2-p3.c:38: note: created new init_stmt: stmp_var_.304_99 = stmp_var_.304_113 + 1;

pa2-p3.c:38: note: created new init_stmt: vect_cst_.305_76 = {0, stmp_var_.304_114, stmp_var_.304_113, stmp_var_.304_99};

pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: created new init_stmt: vect_cst_.306_71 = { 4, 4, 4, 4 };

pa2-p3.c:38: note: transform induction: created def-use cycle: vect_vec_iv_.307_34 = PHI <vect_vec_iv_.307_22(7), vect_cst_.305_76(45)>

vect_vec_iv_.307_22 = vect_vec_iv_.307_34 + vect_cst_.306_71;

pa2-p3.c:38: note: ------>vectorizing phi: .MEM_134 = PHI <.MEM_46(7), .MEM_103(45)>

pa2-p3.c:38: note: ------>vectorizing phi: ivtmp_115 = PHI <ivtmp_112(7), 2000(45)>

pa2-p3.c:38: note: ------>vectorizing phi: vect_vec_iv_.307_34 = PHI <vect_vec_iv_.307_22(7), vect_cst_.305_76(45)>

pa2-p3.c:38: note: ------>vectorizing statement: vect_vec_iv_.307_22 = vect_vec_iv_.307_34 + vect_cst_.306_71;

pa2-p3.c:38: note: ------>vectorizing statement: # DEBUG j => j_129

pa2-p3.c:38: note: ------>vectorizing statement: _36 = pretmp_14 + j_129;

pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand pretmp_14
pa2-p3.c:38: note: def_stmt: pretmp_14 = i_124 * 2;

pa2-p3.c:38: note: type of def: 2.
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(45)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: transform binary/unary operation.
pa2-p3.c:38: note: vect_get_vec_def_for_operand: pretmp_14
pa2-p3.c:38: note: vect_is_simple_use: operand pretmp_14
pa2-p3.c:38: note: def_stmt: pretmp_14 = i_124 * 2;

pa2-p3.c:38: note: type of def: 2.
pa2-p3.c:38: note: def =  pretmp_14  def_stmt =  pretmp_14 = i_124 * 2;

pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: Create vector_inv.
pa2-p3.c:38: note: created new init_stmt: vect_cst_.309_21 = {pretmp_14, pretmp_14, pretmp_14, pretmp_14};

pa2-p3.c:38: note: vect_get_vec_def_for_operand: j_129
pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(45)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: def =  j_129  def_stmt =  j_129 = PHI <j_47(7), 0(45)>

pa2-p3.c:38: note: add new stmt: vect_var_.308_20 = vect_cst_.309_21 + vect_vec_iv_.307_34;

pa2-p3.c:38: note: ------>vectorizing statement: _37 = (double) _36;

pa2-p3.c:38: note: multiple-types.
pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand _36
pa2-p3.c:38: note: def_stmt: _36 = pretmp_14 + j_129;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: transform conversion. ncopies = 1.
pa2-p3.c:38: note: vect_get_vec_def_for_operand: _36
pa2-p3.c:38: note: vect_is_simple_use: operand _36
pa2-p3.c:38: note: def_stmt: _36 = pretmp_14 + j_129;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: def =  _36  def_stmt =  _36 = pretmp_14 + j_129;

pa2-p3.c:38: note: add new stmt: vect_var_.310_19 = [vec_unpack_float_lo_expr] vect_var_.308_20;

pa2-p3.c:38: note: add new stmt: vect_var_.310_18 = [vec_unpack_float_hi_expr] vect_var_.308_20;

pa2-p3.c:38: note: ------>vectorizing statement: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:38: note: multiple-types.
pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand _37
pa2-p3.c:38: note: def_stmt: _37 = (double) _36;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: vect_is_simple_use: operand 1.100000000000000088817841970012523233890533447265625e+0
pa2-p3.c:38: note: transform binary/unary operation.
pa2-p3.c:38: note: vect_get_vec_def_for_operand: _37
pa2-p3.c:38: note: vect_is_simple_use: operand _37
pa2-p3.c:38: note: def_stmt: _37 = (double) _36;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: def =  _37  def_stmt =  _37 = (double) _36;

pa2-p3.c:38: note: vect_get_vec_def_for_operand: 1.100000000000000088817841970012523233890533447265625e+0
pa2-p3.c:38: note: vect_is_simple_use: operand 1.100000000000000088817841970012523233890533447265625e+0
pa2-p3.c:38: note: get vectype with 2 units of type double
pa2-p3.c:38: note: vectype: vector(2) double
pa2-p3.c:38: note: Create vector_cst. nunits = 2
pa2-p3.c:38: note: created new init_stmt: vect_cst_.312_17 = { 1.100000000000000088817841970012523233890533447265625e+0, 1.100000000000000088817841970012523233890533447265625e+0 };

pa2-p3.c:38: note: add new stmt: vect_var_.311_15 = vect_var_.310_19 * vect_cst_.312_17;

pa2-p3.c:38: note: add new stmt: vect_var_.311_13 = vect_var_.310_18 * vect_cst_.312_17;

pa2-p3.c:38: note: ------>vectorizing statement: _39 = (float) _38;

pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand _38
pa2-p3.c:38: note: def_stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: transform conversion. ncopies = 1.
pa2-p3.c:38: note: vect_get_vec_def_for_operand: _38
pa2-p3.c:38: note: vect_is_simple_use: operand _38
pa2-p3.c:38: note: def_stmt: _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: def =  _38  def_stmt =  _38 = _37 * 1.100000000000000088817841970012523233890533447265625e+0;

pa2-p3.c:38: note: add new stmt: vect_var_.313_154 = VEC_PACK_TRUNC_EXPR <vect_var_.311_15, vect_var_.311_13>;

pa2-p3.c:38: note: ------>vectorizing statement: a[i_124][j_129] = _39;

pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand _39
pa2-p3.c:38: note: def_stmt: _39 = (float) _38;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: transform store. ncopies = 1
pa2-p3.c:38: note: vect_get_vec_def_for_operand: _39
pa2-p3.c:38: note: vect_is_simple_use: operand _39
pa2-p3.c:38: note: def_stmt: _39 = (float) _38;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: def =  _39  def_stmt =  _39 = (float) _38;

pa2-p3.c:38: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: a
pa2-p3.c:38: note: created vect_pa.317_157
pa2-p3.c:38: note: add new stmt: MEM[(float[2000][2000] *)vect_pa.314_158] = vect_var_.313_154;

pa2-p3.c:38: note: ------>vectorizing statement: _41 = j_129 * 2;

pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(45)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: vect_is_simple_use: operand 2
pa2-p3.c:38: note: transform binary/unary operation.
pa2-p3.c:38: note: vect_get_vec_def_for_operand: j_129
pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(45)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: def =  j_129  def_stmt =  j_129 = PHI <j_47(7), 0(45)>

pa2-p3.c:38: note: vect_get_vec_def_for_operand: 2
pa2-p3.c:38: note: vect_is_simple_use: operand 2
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: Create vector_cst. nunits = 4
pa2-p3.c:38: note: created new init_stmt: vect_cst_.319_40 = { 2, 2, 2, 2 };

pa2-p3.c:38: note: add new stmt: vect_var_.318_161 = vect_vec_iv_.307_34 * vect_cst_.319_40;

pa2-p3.c:38: note: ------>vectorizing statement: _42 = _41 + i_124;

pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand _41
pa2-p3.c:38: note: def_stmt: _41 = j_129 * 2;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: vect_is_simple_use: operand i_124
pa2-p3.c:38: note: def_stmt: i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:38: note: type of def: 2.
pa2-p3.c:38: note: transform binary/unary operation.
pa2-p3.c:38: note: vect_get_vec_def_for_operand: _41
pa2-p3.c:38: note: vect_is_simple_use: operand _41
pa2-p3.c:38: note: def_stmt: _41 = j_129 * 2;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: def =  _41  def_stmt =  _41 = j_129 * 2;

pa2-p3.c:38: note: vect_get_vec_def_for_operand: i_124
pa2-p3.c:38: note: vect_is_simple_use: operand i_124
pa2-p3.c:38: note: def_stmt: i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:38: note: type of def: 2.
pa2-p3.c:38: note: def =  i_124  def_stmt =  i_124 = PHI <0(6), i_48(11)>

pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: Create vector_inv.
pa2-p3.c:38: note: created new init_stmt: vect_cst_.321_162 = {i_124, i_124, i_124, i_124};

pa2-p3.c:38: note: add new stmt: vect_var_.320_163 = vect_var_.318_161 + vect_cst_.321_162;

pa2-p3.c:38: note: ------>vectorizing statement: _43 = (double) _42;

pa2-p3.c:38: note: multiple-types.
pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand _42
pa2-p3.c:38: note: def_stmt: _42 = _41 + i_124;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: transform conversion. ncopies = 1.
pa2-p3.c:38: note: vect_get_vec_def_for_operand: _42
pa2-p3.c:38: note: vect_is_simple_use: operand _42
pa2-p3.c:38: note: def_stmt: _42 = _41 + i_124;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: def =  _42  def_stmt =  _42 = _41 + i_124;

pa2-p3.c:38: note: add new stmt: vect_var_.322_164 = [vec_unpack_float_lo_expr] vect_var_.320_163;

pa2-p3.c:38: note: add new stmt: vect_var_.322_165 = [vec_unpack_float_hi_expr] vect_var_.320_163;

pa2-p3.c:38: note: ------>vectorizing statement: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:38: note: multiple-types.
pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand _43
pa2-p3.c:38: note: def_stmt: _43 = (double) _42;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: vect_is_simple_use: operand 1.1999999999999999555910790149937383830547332763671875e+0
pa2-p3.c:38: note: transform binary/unary operation.
pa2-p3.c:38: note: vect_get_vec_def_for_operand: _43
pa2-p3.c:38: note: vect_is_simple_use: operand _43
pa2-p3.c:38: note: def_stmt: _43 = (double) _42;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: def =  _43  def_stmt =  _43 = (double) _42;

pa2-p3.c:38: note: vect_get_vec_def_for_operand: 1.1999999999999999555910790149937383830547332763671875e+0
pa2-p3.c:38: note: vect_is_simple_use: operand 1.1999999999999999555910790149937383830547332763671875e+0
pa2-p3.c:38: note: get vectype with 2 units of type double
pa2-p3.c:38: note: vectype: vector(2) double
pa2-p3.c:38: note: Create vector_cst. nunits = 2
pa2-p3.c:38: note: created new init_stmt: vect_cst_.324_166 = { 1.1999999999999999555910790149937383830547332763671875e+0, 1.1999999999999999555910790149937383830547332763671875e+0 };

pa2-p3.c:38: note: add new stmt: vect_var_.323_167 = vect_var_.322_164 * vect_cst_.324_166;

pa2-p3.c:38: note: add new stmt: vect_var_.323_168 = vect_var_.322_165 * vect_cst_.324_166;

pa2-p3.c:38: note: ------>vectorizing statement: _45 = (float) _44;

pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand _44
pa2-p3.c:38: note: def_stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: transform conversion. ncopies = 1.
pa2-p3.c:38: note: vect_get_vec_def_for_operand: _44
pa2-p3.c:38: note: vect_is_simple_use: operand _44
pa2-p3.c:38: note: def_stmt: _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: def =  _44  def_stmt =  _44 = _43 * 1.1999999999999999555910790149937383830547332763671875e+0;

pa2-p3.c:38: note: add new stmt: vect_var_.325_169 = VEC_PACK_TRUNC_EXPR <vect_var_.323_167, vect_var_.323_168>;

pa2-p3.c:38: note: ------>vectorizing statement: b[i_124][j_129] = _45;

pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand _45
pa2-p3.c:38: note: def_stmt: _45 = (float) _44;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: transform store. ncopies = 1
pa2-p3.c:38: note: vect_get_vec_def_for_operand: _45
pa2-p3.c:38: note: vect_is_simple_use: operand _45
pa2-p3.c:38: note: def_stmt: _45 = (float) _44;

pa2-p3.c:38: note: type of def: 3.
pa2-p3.c:38: note: def =  _45  def_stmt =  _45 = (float) _44;

pa2-p3.c:38: note: create vector_type-pointer variable to type: vector(4) float  vectorizing an array ref: b
pa2-p3.c:38: note: created vect_pb.329_172
pa2-p3.c:38: note: add new stmt: MEM[(float[2000][2000] *)vect_pb.326_173] = vect_var_.325_169;

pa2-p3.c:38: note: ------>vectorizing statement: j_47 = j_129 + 1;

pa2-p3.c:38: note: transform statement.
pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(45)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: vect_is_simple_use: operand 1
pa2-p3.c:38: note: transform binary/unary operation.
pa2-p3.c:38: note: vect_get_vec_def_for_operand: j_129
pa2-p3.c:38: note: vect_is_simple_use: operand j_129
pa2-p3.c:38: note: def_stmt: j_129 = PHI <j_47(7), 0(45)>

pa2-p3.c:38: note: type of def: 4.
pa2-p3.c:38: note: def =  j_129  def_stmt =  j_129 = PHI <j_47(7), 0(45)>

pa2-p3.c:38: note: vect_get_vec_def_for_operand: 1
pa2-p3.c:38: note: vect_is_simple_use: operand 1
pa2-p3.c:38: note: get vectype with 4 units of type int
pa2-p3.c:38: note: vectype: vector(4) int
pa2-p3.c:38: note: Create vector_cst. nunits = 4
pa2-p3.c:38: note: created new init_stmt: vect_cst_.331_46 = { 1, 1, 1, 1 };

pa2-p3.c:38: note: add new stmt: vect_j.330_176 = vect_vec_iv_.307_34 + vect_cst_.331_46;

pa2-p3.c:38: note: ------>vectorizing statement: # DEBUG j => j_47

pa2-p3.c:38: note: ------>vectorizing statement: # DEBUG j => j_47

pa2-p3.c:38: note: ------>vectorizing statement: ivtmp_112 = ivtmp_115 - 1;

pa2-p3.c:38: note: ------>vectorizing statement: vect_pa.314_159 = vect_pa.314_158 + 16;

pa2-p3.c:38: note: ------>vectorizing statement: vect_pb.326_174 = vect_pb.326_173 + 16;

pa2-p3.c:38: note: ------>vectorizing statement: if (ivtmp_112 != 0)

loop at pa2-p3.c:39: if (ivtmp_178 < 500)

pa2-p3.c:38: note: LOOP VECTORIZED.
pa2-p3.c:17: note: vectorized 4 loops in function.

pa2-p3.c:25: note: ===vect_slp_analyze_bb===

pa2-p3.c:25: note: === vect_analyze_data_refs ===

pa2-p3.c:25: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:26: note: ===vect_slp_analyze_bb===

pa2-p3.c:26: note: === vect_analyze_data_refs ===

pa2-p3.c:26: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:29: note: ===vect_slp_analyze_bb===

pa2-p3.c:29: note: === vect_analyze_data_refs ===

pa2-p3.c:29: note: get vectype with 2 units of type long unsigned int
pa2-p3.c:29: note: vectype: vector(2) long unsigned int
pa2-p3.c:29: note: === vect_pattern_recog ===
pa2-p3.c:29: note: === vect_analyze_dependences ===
pa2-p3.c:29: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:29: note: vect_compute_data_ref_alignment:
pa2-p3.c:29: note: can't force alignment of ref: MEM[(char * *)argv_27(D) + 8B]
pa2-p3.c:29: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:29: note: not consecutive access _29 = MEM[(char * *)argv_27(D) + 8B];

pa2-p3.c:29: note: === vect_analyze_slp ===
pa2-p3.c:29: note: Failed to SLP the basic block.
pa2-p3.c:29: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:31: note: ===vect_slp_analyze_bb===

pa2-p3.c:31: note: === vect_analyze_data_refs ===

pa2-p3.c:31: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:34: note: ===vect_slp_analyze_bb===

pa2-p3.c:34: note: === vect_analyze_data_refs ===

pa2-p3.c:34: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:39: note: ===vect_slp_analyze_bb===

pa2-p3.c:39: note: === vect_analyze_data_refs ===

pa2-p3.c:39: note: not vectorized: no vectype for stmt: MEM[(float[2000][2000] *)vect_pa.314_158] = vect_var_.313_154;
 scalar_type: vector(4) float
pa2-p3.c:39: note: === vect_pattern_recog ===
pa2-p3.c:39: note: vect_is_simple_use: operand vect_var_.310_19
pa2-p3.c:39: note: def_stmt: vect_var_.310_19 = [vec_unpack_float_lo_expr] vect_var_.308_20;

pa2-p3.c:39: note: type of def: 3.
pa2-p3.c:39: note: vect_is_simple_use: operand vect_var_.310_18
pa2-p3.c:39: note: def_stmt: vect_var_.310_18 = [vec_unpack_float_hi_expr] vect_var_.308_20;

pa2-p3.c:39: note: type of def: 3.
pa2-p3.c:39: note: vect_is_simple_use: operand vect_vec_iv_.307_34
pa2-p3.c:39: note: def_stmt: vect_vec_iv_.307_34 = PHI <vect_vec_iv_.307_22(7), vect_cst_.305_76(12)>

pa2-p3.c:39: note: type of def: 2.
pa2-p3.c:39: note: vect_is_simple_use: operand vect_var_.322_164
pa2-p3.c:39: note: def_stmt: vect_var_.322_164 = [vec_unpack_float_lo_expr] vect_var_.320_163;

pa2-p3.c:39: note: type of def: 3.
pa2-p3.c:39: note: vect_is_simple_use: operand vect_var_.322_165
pa2-p3.c:39: note: def_stmt: vect_var_.322_165 = [vec_unpack_float_hi_expr] vect_var_.320_163;

pa2-p3.c:39: note: type of def: 3.
pa2-p3.c:39: note: === vect_analyze_dependences ===
pa2-p3.c:39: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:39: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:39: note: === vect_analyze_slp ===
pa2-p3.c:39: note: Failed to SLP the basic block.
pa2-p3.c:39: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:37: note: ===vect_slp_analyze_bb===

pa2-p3.c:37: note: === vect_analyze_data_refs ===

pa2-p3.c:37: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:43: note: ===vect_slp_analyze_bb===

pa2-p3.c:43: note: === vect_analyze_data_refs ===

pa2-p3.c:43: note: not vectorized: no vectype for stmt: MEM[(float[2000][2000] *)vect_pc.300_150] = vect_cst_.299_1;
 scalar_type: vector(4) float
pa2-p3.c:43: note: === vect_pattern_recog ===
pa2-p3.c:43: note: === vect_analyze_dependences ===
pa2-p3.c:43: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:43: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:43: note: === vect_analyze_slp ===
pa2-p3.c:43: note: Failed to SLP the basic block.
pa2-p3.c:43: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:43: note: ===vect_slp_analyze_bb===

pa2-p3.c:43: note: === vect_analyze_data_refs ===

pa2-p3.c:43: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:44: note: ===vect_slp_analyze_bb===

pa2-p3.c:44: note: === vect_analyze_data_refs ===

pa2-p3.c:44: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:48: note: ===vect_slp_analyze_bb===

pa2-p3.c:48: note: === vect_analyze_data_refs ===

pa2-p3.c:48: note: get vectype with 4 units of type float
pa2-p3.c:48: note: vectype: vector(4) float
pa2-p3.c:48: note: get vectype with 4 units of type float
pa2-p3.c:48: note: vectype: vector(4) float
pa2-p3.c:48: note: === vect_pattern_recog ===
pa2-p3.c:48: note: vect_is_simple_use: operand _58
pa2-p3.c:48: note: def_stmt: _58 = a[k_10][i_126];

pa2-p3.c:48: note: type of def: 3.
pa2-p3.c:48: note: === vect_analyze_dependences ===
pa2-p3.c:48: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:48: note: vect_compute_data_ref_alignment:
pa2-p3.c:48: note: Unknown alignment for access: a
pa2-p3.c:48: note: vect_compute_data_ref_alignment:
pa2-p3.c:48: note: Unknown alignment for access: b
pa2-p3.c:48: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:48: note: not consecutive access _58 = a[k_10][i_126];

pa2-p3.c:48: note: not consecutive access _59 = b[k_10][j_131];

pa2-p3.c:48: note: === vect_analyze_slp ===
pa2-p3.c:48: note: Failed to SLP the basic block.
pa2-p3.c:48: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: get vectype with 4 units of type float
pa2-p3.c:17: note: vectype: vector(4) float
pa2-p3.c:17: note: === vect_pattern_recog ===
pa2-p3.c:17: note: === vect_analyze_dependences ===
pa2-p3.c:17: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:17: note: vect_compute_data_ref_alignment:
pa2-p3.c:17: note: Unknown alignment for access: c
pa2-p3.c:17: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:17: note: not consecutive access c[j_131][i_126] = c_I_I_lsm.284_146;

pa2-p3.c:17: note: === vect_analyze_slp ===
pa2-p3.c:17: note: Failed to SLP the basic block.
pa2-p3.c:17: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:46: note: ===vect_slp_analyze_bb===

pa2-p3.c:46: note: === vect_analyze_data_refs ===

pa2-p3.c:46: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:47: note: ===vect_slp_analyze_bb===

pa2-p3.c:47: note: === vect_analyze_data_refs ===

pa2-p3.c:47: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: get vectype with 4 units of type float
pa2-p3.c:17: note: vectype: vector(4) float
pa2-p3.c:17: note: === vect_pattern_recog ===
pa2-p3.c:17: note: === vect_analyze_dependences ===
pa2-p3.c:17: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:17: note: vect_compute_data_ref_alignment:
pa2-p3.c:17: note: Unknown alignment for access: c
pa2-p3.c:17: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:17: note: not consecutive access pretmp_143 = c[j_131][i_126];

pa2-p3.c:17: note: === vect_analyze_slp ===
pa2-p3.c:17: note: Failed to SLP the basic block.
pa2-p3.c:17: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:45: note: ===vect_slp_analyze_bb===

pa2-p3.c:45: note: === vect_analyze_data_refs ===

pa2-p3.c:45: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:49: note: ===vect_slp_analyze_bb===

pa2-p3.c:49: note: === vect_analyze_data_refs ===

pa2-p3.c:49: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:54: note: ===vect_slp_analyze_bb===

pa2-p3.c:54: note: === vect_analyze_data_refs ===

pa2-p3.c:54: note: not vectorized: no vectype for stmt: vect_var_.294_11 = MEM[(float[2000][2000] *)vect_pc.290_16];
 scalar_type: vector(4) float
pa2-p3.c:54: note: === vect_pattern_recog ===
pa2-p3.c:54: note: === vect_analyze_dependences ===
pa2-p3.c:54: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:54: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:54: note: === vect_analyze_slp ===
pa2-p3.c:54: note: Failed to SLP the basic block.
pa2-p3.c:54: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:52: note: ===vect_slp_analyze_bb===

pa2-p3.c:52: note: === vect_analyze_data_refs ===

pa2-p3.c:52: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:59: note: ===vect_slp_analyze_bb===

pa2-p3.c:59: note: === vect_analyze_data_refs ===

pa2-p3.c:59: note: not vectorized: no vectype for stmt: MEM[(float[2000][2000] *)vect_pc.286_104] = vect_cst_.285_109;
 scalar_type: vector(4) float
pa2-p3.c:59: note: === vect_pattern_recog ===
pa2-p3.c:59: note: === vect_analyze_dependences ===
pa2-p3.c:59: note: === vect_analyze_data_refs_alignment ===
pa2-p3.c:59: note: === vect_analyze_data_ref_accesses ===
pa2-p3.c:59: note: === vect_analyze_slp ===
pa2-p3.c:59: note: Failed to SLP the basic block.
pa2-p3.c:59: note: not vectorized: failed to find SLP opportunities in basic block.

pa2-p3.c:59: note: ===vect_slp_analyze_bb===

pa2-p3.c:59: note: === vect_analyze_data_refs ===

pa2-p3.c:59: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:17: note: ===vect_slp_analyze_bb===

pa2-p3.c:17: note: === vect_analyze_data_refs ===

pa2-p3.c:17: note: not vectorized: not enough data-refs in basic block.

pa2-p3.c:60: note: ===vect_slp_analyze_bb===

pa2-p3.c:60: note: === vect_analyze_data_refs ===

pa2-p3.c:60: note: not vectorized: not enough data-refs in basic block.
