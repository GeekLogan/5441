
Analyzing loop at pa1-p1.c:98

pa1-p1.c:98: note: ===== analyze_loop_nest =====
pa1-p1.c:98: note: === vect_analyze_loop_form ===
pa1-p1.c:98: note: ===== analyze_loop_nest_1 =====
pa1-p1.c:98: note: === vect_analyze_loop_form ===
pa1-p1.c:98: note: === get_loop_niters ===
pa1-p1.c:98: note: ==> get_loop_niters:(unsigned int) n_5(D)
pa1-p1.c:98: note: Symbolic number of iterations is (unsigned int) n_5(D)
pa1-p1.c:98: note: Considering outer-loop vectorization.
pa1-p1.c:98: note: === get_loop_niters ===
pa1-p1.c:98: note: ==> get_loop_niters:(unsigned int) n_5(D)
pa1-p1.c:98: note: Symbolic number of iterations is (unsigned int) n_5(D)
pa1-p1.c:98: note: === vect_analyze_data_refs ===

pa1-p1.c:98: note: analyze in outer-loop: *y_7(D)
pa1-p1.c:98: note: 	outer base_address: y_7(D)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 128
pa1-p1.c:98: note: get vectype with 2 units of type double
pa1-p1.c:98: note: vectype: vector(2) double
pa1-p1.c:98: note: analyze in outer-loop: *(m_16(D) + pretmp_79)
pa1-p1.c:98: note: failed: evolution of base is not affine.

pa1-p1.c:98: note: bad data references.
Analyzing loop at pa1-p1.c:99

pa1-p1.c:99: note: ===== analyze_loop_nest =====
pa1-p1.c:99: note: === vect_analyze_loop_form ===
pa1-p1.c:99: note: === get_loop_niters ===
pa1-p1.c:99: note: ==> get_loop_niters:(unsigned int) n_5(D)
pa1-p1.c:99: note: Symbolic number of iterations is (unsigned int) n_5(D)
pa1-p1.c:99: note: === vect_analyze_data_refs ===

pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: not vectorized: not suitable for strided load _33 = *_32[i_45];

pa1-p1.c:99: note: bad data references.
pa1-p1.c:96: note: vectorized 0 loops in function.

pa1-p1.c:98: note: ===vect_slp_analyze_bb===

pa1-p1.c:98: note: === vect_analyze_data_refs ===

pa1-p1.c:98: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:96: note: ===vect_slp_analyze_bb===

pa1-p1.c:96: note: === vect_analyze_data_refs ===

pa1-p1.c:96: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:96: note: ===vect_slp_analyze_bb===

pa1-p1.c:96: note: === vect_analyze_data_refs ===

pa1-p1.c:96: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:101: note: ===vect_slp_analyze_bb===

pa1-p1.c:101: note: === vect_analyze_data_refs ===

pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: === vect_pattern_recog ===
pa1-p1.c:101: note: vect_is_simple_use: operand _8
pa1-p1.c:101: note: def_stmt: _8 = (long unsigned int) j_43;

pa1-p1.c:101: note: type of def: 3.
pa1-p1.c:101: note: vect_is_simple_use: operand j_43
pa1-p1.c:101: note: def_stmt: j_43 = PHI <j_38(4), 0(8)>

pa1-p1.c:101: note: type of def: 2.
pa1-p1.c:101: note: vect_is_simple_use: operand 8
pa1-p1.c:101: note: vect_is_simple_use: operand _18
pa1-p1.c:101: note: def_stmt: _18 = *pretmp_80[j_43];

pa1-p1.c:101: note: type of def: 3.
pa1-p1.c:101: note: vect_is_simple_use: operand _8
pa1-p1.c:101: note: def_stmt: _8 = (long unsigned int) j_43;

pa1-p1.c:101: note: type of def: 3.
pa1-p1.c:101: note: vect_is_simple_use: operand j_43
pa1-p1.c:101: note: def_stmt: j_43 = PHI <j_38(4), 0(8)>

pa1-p1.c:101: note: type of def: 2.
pa1-p1.c:101: note: vect_is_simple_use: operand pretmp_70
pa1-p1.c:101: note: def_stmt: pretmp_70 = pretmp_69 * 8;

pa1-p1.c:101: note: type of def: 2.
pa1-p1.c:101: note: vect_is_simple_use: operand _33
pa1-p1.c:101: note: def_stmt: _33 = *_32[i_45];

pa1-p1.c:101: note: type of def: 3.
pa1-p1.c:101: note: === vect_analyze_dependences ===
pa1-p1.c:101: note: determined dependence between *_10 and *_10
pa1-p1.c:101: note: can't determine dependence between *_10 and *_28
pa1-p1.c:101: note: can't determine dependence between *pretmp_80[j_43] and *_10
pa1-p1.c:101: note: can't determine dependence between *pretmp_80[j_43] and *_28
pa1-p1.c:101: note: can't determine dependence between *pretmp_82 and *_10
pa1-p1.c:101: note: determined dependence between *pretmp_82 and *pretmp_82
pa1-p1.c:101: note: can't determine dependence between *pretmp_82 and *_28
pa1-p1.c:101: note: can't determine dependence between *_10 and *_28
pa1-p1.c:101: note: not vectorized: unhandled data dependence in basic block.

pa1-p1.c:98: note: ===vect_slp_analyze_bb===

pa1-p1.c:98: note: === vect_analyze_data_refs ===

pa1-p1.c:98: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:96: note: ===vect_slp_analyze_bb===

pa1-p1.c:96: note: === vect_analyze_data_refs ===

pa1-p1.c:96: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:96: note: ===vect_slp_analyze_bb===

pa1-p1.c:96: note: === vect_analyze_data_refs ===

pa1-p1.c:96: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:104: note: ===vect_slp_analyze_bb===

pa1-p1.c:104: note: === vect_analyze_data_refs ===

pa1-p1.c:104: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at pa1-p1.c:121

pa1-p1.c:121: note: ===== analyze_loop_nest =====
pa1-p1.c:121: note: === vect_analyze_loop_form ===
pa1-p1.c:121: note: ===== analyze_loop_nest_1 =====
pa1-p1.c:121: note: === vect_analyze_loop_form ===
pa1-p1.c:121: note: === get_loop_niters ===
pa1-p1.c:121: note: ==> get_loop_niters:(unsigned int) n_9(D)
pa1-p1.c:121: note: Symbolic number of iterations is (unsigned int) n_9(D)
pa1-p1.c:121: note: Considering outer-loop vectorization.
pa1-p1.c:121: note: === get_loop_niters ===
pa1-p1.c:121: note: ==> get_loop_niters:(unsigned int) n_9(D)
pa1-p1.c:121: note: Symbolic number of iterations is (unsigned int) n_9(D)
pa1-p1.c:121: note: === vect_analyze_data_refs ===

pa1-p1.c:121: note: analyze in outer-loop: *(z_34(D) + (long unsigned int) j_68 * 8)
pa1-p1.c:121: note: 	outer base_address: z_34(D)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 8
	outer aligned to: 128
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: analyze in outer-loop: *x_19(D)
pa1-p1.c:121: note: 	outer base_address: x_19(D)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 128
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: analyze in outer-loop: *(m_25(D) + pretmp_131)
pa1-p1.c:121: note: failed: evolution of base is not affine.

pa1-p1.c:121: note: bad data references.
Analyzing loop at pa1-p1.c:121

pa1-p1.c:121: note: ===== analyze_loop_nest =====
pa1-p1.c:121: note: === vect_analyze_loop_form ===
pa1-p1.c:121: note: === get_loop_niters ===
pa1-p1.c:121: note: ==> get_loop_niters:(unsigned int) n_9(D)
pa1-p1.c:121: note: Symbolic number of iterations is (unsigned int) n_9(D)
pa1-p1.c:121: note: === vect_analyze_data_refs ===

pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:121: note: Analyze phi: i_61 = PHI <i_52(10), 0(14)>

pa1-p1.c:121: note: Access function of PHI: {0, +, 1}_4
pa1-p1.c:121: note: step: 1,  init: 0
pa1-p1.c:121: note: Detected induction.
pa1-p1.c:121: note: Analyze phi: .MEM_71 = PHI <.MEM_51(10), .MEM_43(14)>

pa1-p1.c:121: note: === vect_pattern_recog ===
pa1-p1.c:121: note: vect_is_simple_use: operand _39
pa1-p1.c:121: note: def_stmt: _39 = (long unsigned int) i_61;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: vect_is_simple_use: operand i_61
pa1-p1.c:121: note: def_stmt: i_61 = PHI <i_52(10), 0(14)>

pa1-p1.c:121: note: type of def: 4.
pa1-p1.c:121: note: vect_is_simple_use: operand 8
pa1-p1.c:121: note: vect_is_simple_use: operand _42
pa1-p1.c:121: note: def_stmt: _42 = *_41;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: === vect_mark_stmts_to_be_vectorized ===
pa1-p1.c:121: note: init: phi relevant? i_61 = PHI <i_52(10), 0(14)>

pa1-p1.c:121: note: init: phi relevant? .MEM_71 = PHI <.MEM_51(10), .MEM_43(14)>

pa1-p1.c:121: note: init: stmt relevant? _38 = *pretmp_127;

pa1-p1.c:121: note: init: stmt relevant? _39 = (long unsigned int) i_61;

pa1-p1.c:121: note: init: stmt relevant? _40 = _39 * 8;

pa1-p1.c:121: note: init: stmt relevant? _41 = x_19(D) + _40;

pa1-p1.c:121: note: init: stmt relevant? _42 = *_41;

pa1-p1.c:121: note: init: stmt relevant? _48 = *pretmp_132[i_61];

pa1-p1.c:121: note: init: stmt relevant? _49 = _42 * _48;

pa1-p1.c:121: note: init: stmt relevant? _50 = _38 + _49;

pa1-p1.c:121: note: init: stmt relevant? *pretmp_127 = _50;

pa1-p1.c:121: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:121: note: mark relevant 4, live 0.
pa1-p1.c:121: note: init: stmt relevant? i_52 = i_61 + 1;

pa1-p1.c:121: note: init: stmt relevant? if (n_9(D) > i_52)

pa1-p1.c:121: note: worklist: examine stmt: *pretmp_127 = _50;

pa1-p1.c:121: note: vect_is_simple_use: operand _50
pa1-p1.c:121: note: def_stmt: _50 = _38 + _49;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: mark relevant 4, live 0.
pa1-p1.c:121: note: worklist: examine stmt: _50 = _38 + _49;

pa1-p1.c:121: note: vect_is_simple_use: operand _38
pa1-p1.c:121: note: def_stmt: _38 = *pretmp_127;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: mark relevant 4, live 0.
pa1-p1.c:121: note: vect_is_simple_use: operand _49
pa1-p1.c:121: note: def_stmt: _49 = _42 * _48;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: mark relevant 4, live 0.
pa1-p1.c:121: note: worklist: examine stmt: _49 = _42 * _48;

pa1-p1.c:121: note: vect_is_simple_use: operand _42
pa1-p1.c:121: note: def_stmt: _42 = *_41;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: mark relevant 4, live 0.
pa1-p1.c:121: note: vect_is_simple_use: operand _48
pa1-p1.c:121: note: def_stmt: _48 = *pretmp_132[i_61];

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: mark relevant 4, live 0.
pa1-p1.c:121: note: worklist: examine stmt: _48 = *pretmp_132[i_61];

pa1-p1.c:121: note: worklist: examine stmt: _42 = *_41;

pa1-p1.c:121: note: worklist: examine stmt: _38 = *pretmp_127;

pa1-p1.c:121: note: === vect_analyze_dependences ===
pa1-p1.c:121: note: dependence distance  = 0.
pa1-p1.c:121: note: dependence distance == 0 between *pretmp_127 and *pretmp_127
pa1-p1.c:121: note: versioning for alias required: can't determine dependence between *_41 and *pretmp_127
pa1-p1.c:121: note: mark for run-time aliasing test between *_41 and *pretmp_127
pa1-p1.c:121: note: versioning for alias required: can't determine dependence between *pretmp_132[i_61] and *pretmp_127
pa1-p1.c:121: note: mark for run-time aliasing test between *pretmp_132[i_61] and *pretmp_127
pa1-p1.c:121: note: === vect_determine_vectorization_factor ===
pa1-p1.c:121: note: ==> examining phi: i_61 = PHI <i_52(10), 0(14)>

pa1-p1.c:121: note: ==> examining phi: .MEM_71 = PHI <.MEM_51(10), .MEM_43(14)>

pa1-p1.c:121: note: ==> examining statement: _38 = *pretmp_127;

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: _39 = (long unsigned int) i_61;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: _40 = _39 * 8;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: _41 = x_19(D) + _40;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: _42 = *_41;

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: _48 = *pretmp_132[i_61];

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: _49 = _42 * _48;

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: _50 = _38 + _49;

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: *pretmp_127 = _50;

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: i_52 = i_61 + 1;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: if (n_9(D) > i_52)

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: vectorization factor = 2
pa1-p1.c:121: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:121: note: dependence distance  = 0.
pa1-p1.c:121: note: accesses have the same alignment.dependence distance modulo vf == 0 between *pretmp_127 and *pretmp_127
pa1-p1.c:121: note: vect_compute_data_ref_alignment:
pa1-p1.c:121: note: can't force alignment of ref: *pretmp_127
pa1-p1.c:121: note: vect_compute_data_ref_alignment:
pa1-p1.c:121: note: can't force alignment of ref: *_41
pa1-p1.c:121: note: vect_compute_data_ref_alignment:
pa1-p1.c:121: note: can't force alignment of ref: *pretmp_132[i_61]
pa1-p1.c:121: note: vect_compute_data_ref_alignment:
pa1-p1.c:121: note: can't force alignment of ref: *pretmp_127
pa1-p1.c:121: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:121: note: not vectorized: complicated access pattern.
pa1-p1.c:121: note: bad data access.
Analyzing loop at pa1-p1.c:118

pa1-p1.c:118: note: ===== analyze_loop_nest =====
pa1-p1.c:118: note: === vect_analyze_loop_form ===
pa1-p1.c:118: note: ===== analyze_loop_nest_1 =====
pa1-p1.c:118: note: === vect_analyze_loop_form ===
pa1-p1.c:118: note: === get_loop_niters ===
pa1-p1.c:118: note: ==> get_loop_niters:(unsigned int) n_9(D)
pa1-p1.c:118: note: Symbolic number of iterations is (unsigned int) n_9(D)
pa1-p1.c:118: note: Considering outer-loop vectorization.
pa1-p1.c:118: note: === get_loop_niters ===
pa1-p1.c:118: note: ==> get_loop_niters:(unsigned int) n_9(D)
pa1-p1.c:118: note: Symbolic number of iterations is (unsigned int) n_9(D)
pa1-p1.c:118: note: === vect_analyze_data_refs ===

pa1-p1.c:118: note: analyze in outer-loop: *y_12(D)
pa1-p1.c:118: note: 	outer base_address: y_12(D)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 128
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: analyze in outer-loop: *(x_19(D) + (long unsigned int) i_66 * 8)
pa1-p1.c:118: note: 	outer base_address: x_19(D)
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 8
	outer aligned to: 128
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: analyze in outer-loop: *(m_25(D) + pretmp_116)
pa1-p1.c:118: note: failed: evolution of base is not affine.

pa1-p1.c:118: note: bad data references.
Analyzing loop at pa1-p1.c:118

pa1-p1.c:118: note: ===== analyze_loop_nest =====
pa1-p1.c:118: note: === vect_analyze_loop_form ===
pa1-p1.c:118: note: === get_loop_niters ===
pa1-p1.c:118: note: ==> get_loop_niters:(unsigned int) n_9(D)
pa1-p1.c:118: note: Symbolic number of iterations is (unsigned int) n_9(D)
pa1-p1.c:118: note: === vect_analyze_data_refs ===

pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:118: note: Analyze phi: j_59 = PHI <j_31(4), 0(9)>

pa1-p1.c:118: note: Access function of PHI: {0, +, 1}_2
pa1-p1.c:118: note: step: 1,  init: 0
pa1-p1.c:118: note: Detected induction.
pa1-p1.c:118: note: Analyze phi: .MEM_69 = PHI <.MEM_30(4), .MEM_11(9)>

pa1-p1.c:118: note: === vect_pattern_recog ===
pa1-p1.c:118: note: vect_is_simple_use: operand _13
pa1-p1.c:118: note: def_stmt: _13 = (long unsigned int) j_59;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand j_59
pa1-p1.c:118: note: def_stmt: j_59 = PHI <j_31(4), 0(9)>

pa1-p1.c:118: note: type of def: 4.
pa1-p1.c:118: note: vect_is_simple_use: operand 8
pa1-p1.c:118: note: vect_is_simple_use: operand _21
pa1-p1.c:118: note: def_stmt: _21 = *pretmp_113;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: === vect_mark_stmts_to_be_vectorized ===
pa1-p1.c:118: note: init: phi relevant? j_59 = PHI <j_31(4), 0(9)>

pa1-p1.c:118: note: init: phi relevant? .MEM_69 = PHI <.MEM_30(4), .MEM_11(9)>

pa1-p1.c:118: note: init: stmt relevant? _13 = (long unsigned int) j_59;

pa1-p1.c:118: note: init: stmt relevant? _14 = _13 * 8;

pa1-p1.c:118: note: init: stmt relevant? _15 = y_12(D) + _14;

pa1-p1.c:118: note: init: stmt relevant? _16 = *_15;

pa1-p1.c:118: note: init: stmt relevant? _21 = *pretmp_113;

pa1-p1.c:118: note: init: stmt relevant? _27 = *pretmp_117[j_59];

pa1-p1.c:118: note: init: stmt relevant? _28 = _21 * _27;

pa1-p1.c:118: note: init: stmt relevant? _29 = _16 + _28;

pa1-p1.c:118: note: init: stmt relevant? *_15 = _29;

pa1-p1.c:118: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: init: stmt relevant? j_31 = j_59 + 1;

pa1-p1.c:118: note: init: stmt relevant? if (n_9(D) > j_31)

pa1-p1.c:118: note: worklist: examine stmt: *_15 = _29;

pa1-p1.c:118: note: vect_is_simple_use: operand _29
pa1-p1.c:118: note: def_stmt: _29 = _16 + _28;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: worklist: examine stmt: _29 = _16 + _28;

pa1-p1.c:118: note: vect_is_simple_use: operand _16
pa1-p1.c:118: note: def_stmt: _16 = *_15;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: vect_is_simple_use: operand _28
pa1-p1.c:118: note: def_stmt: _28 = _21 * _27;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: worklist: examine stmt: _28 = _21 * _27;

pa1-p1.c:118: note: vect_is_simple_use: operand _21
pa1-p1.c:118: note: def_stmt: _21 = *pretmp_113;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: vect_is_simple_use: operand _27
pa1-p1.c:118: note: def_stmt: _27 = *pretmp_117[j_59];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: worklist: examine stmt: _27 = *pretmp_117[j_59];

pa1-p1.c:118: note: worklist: examine stmt: _21 = *pretmp_113;

pa1-p1.c:118: note: worklist: examine stmt: _16 = *_15;

pa1-p1.c:118: note: === vect_analyze_dependences ===
pa1-p1.c:118: note: dependence distance  = 0.
pa1-p1.c:118: note: dependence distance == 0 between *_15 and *_15
pa1-p1.c:118: note: versioning for alias required: can't determine dependence between *pretmp_113 and *_15
pa1-p1.c:118: note: mark for run-time aliasing test between *pretmp_113 and *_15
pa1-p1.c:118: note: versioning for alias required: can't determine dependence between *pretmp_117[j_59] and *_15
pa1-p1.c:118: note: mark for run-time aliasing test between *pretmp_117[j_59] and *_15
pa1-p1.c:118: note: === vect_determine_vectorization_factor ===
pa1-p1.c:118: note: ==> examining phi: j_59 = PHI <j_31(4), 0(9)>

pa1-p1.c:118: note: ==> examining phi: .MEM_69 = PHI <.MEM_30(4), .MEM_11(9)>

pa1-p1.c:118: note: ==> examining statement: _13 = (long unsigned int) j_59;

pa1-p1.c:118: note: skip.
pa1-p1.c:118: note: ==> examining statement: _14 = _13 * 8;

pa1-p1.c:118: note: skip.
pa1-p1.c:118: note: ==> examining statement: _15 = y_12(D) + _14;

pa1-p1.c:118: note: skip.
pa1-p1.c:118: note: ==> examining statement: _16 = *_15;

pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: nunits = 2
pa1-p1.c:118: note: ==> examining statement: _21 = *pretmp_113;

pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: nunits = 2
pa1-p1.c:118: note: ==> examining statement: _27 = *pretmp_117[j_59];

pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: nunits = 2
pa1-p1.c:118: note: ==> examining statement: _28 = _21 * _27;

pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: nunits = 2
pa1-p1.c:118: note: ==> examining statement: _29 = _16 + _28;

pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: nunits = 2
pa1-p1.c:118: note: ==> examining statement: *_15 = _29;

pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: nunits = 2
pa1-p1.c:118: note: ==> examining statement: j_31 = j_59 + 1;

pa1-p1.c:118: note: skip.
pa1-p1.c:118: note: ==> examining statement: if (n_9(D) > j_31)

pa1-p1.c:118: note: skip.
pa1-p1.c:118: note: vectorization factor = 2
pa1-p1.c:118: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:118: note: dependence distance  = 0.
pa1-p1.c:118: note: accesses have the same alignment.dependence distance modulo vf == 0 between *_15 and *_15
pa1-p1.c:118: note: vect_compute_data_ref_alignment:
pa1-p1.c:118: note: can't force alignment of ref: *_15
pa1-p1.c:118: note: vect_compute_data_ref_alignment:
pa1-p1.c:118: note: can't force alignment of ref: *pretmp_113
pa1-p1.c:118: note: vect_compute_data_ref_alignment:
pa1-p1.c:118: note: can't force alignment of ref: *pretmp_117[j_59]
pa1-p1.c:118: note: vect_compute_data_ref_alignment:
pa1-p1.c:118: note: can't force alignment of ref: *_15
pa1-p1.c:118: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:118: note: === vect_prune_runtime_alias_test_list ===
pa1-p1.c:118: note: === vect_enhance_data_refs_alignment ===
pa1-p1.c:118: note: Unknown misalignment, is_packed = 0
pa1-p1.c:118: note: Unknown misalignment, is_packed = 0
pa1-p1.c:118: note: Unknown misalignment, is_packed = 0
pa1-p1.c:118: note: Vectorizing an unaligned access.
pa1-p1.c:118: note: Vectorizing an unaligned access.
pa1-p1.c:118: note: Vectorizing an unaligned access.
pa1-p1.c:118: note: Vectorizing an unaligned access.
pa1-p1.c:118: note: === vect_analyze_slp ===
pa1-p1.c:118: note: === vect_make_slp_decision ===
pa1-p1.c:118: note: === vect_detect_hybrid_slp ===
pa1-p1.c:118: note: === vect_analyze_loop_operations ===
pa1-p1.c:118: note: examining phi: j_59 = PHI <j_31(4), 0(9)>

pa1-p1.c:118: note: examining phi: .MEM_69 = PHI <.MEM_30(4), .MEM_11(9)>

pa1-p1.c:118: note: ==> examining statement: _13 = (long unsigned int) j_59;

pa1-p1.c:118: note: irrelevant.
pa1-p1.c:118: note: ==> examining statement: _14 = _13 * 8;

pa1-p1.c:118: note: irrelevant.
pa1-p1.c:118: note: ==> examining statement: _15 = y_12(D) + _14;

pa1-p1.c:118: note: irrelevant.
pa1-p1.c:118: note: ==> examining statement: _16 = *_15;

pa1-p1.c:118: note: vect_is_simple_use: operand *_15
pa1-p1.c:118: note: not ssa-name.
pa1-p1.c:118: note: use not simple.
pa1-p1.c:118: note: vect_is_simple_use: operand *_15
pa1-p1.c:118: note: not ssa-name.
pa1-p1.c:118: note: use not simple.
pa1-p1.c:118: note: vect_model_load_cost: unaligned supported by hardware.
pa1-p1.c:118: note: vect_model_load_cost: inside_cost = 2, prologue_cost = 0 .
pa1-p1.c:118: note: ==> examining statement: _21 = *pretmp_113;

pa1-p1.c:118: note: vect_is_simple_use: operand *pretmp_113
pa1-p1.c:118: note: not ssa-name.
pa1-p1.c:118: note: use not simple.
pa1-p1.c:118: note: vect_is_simple_use: operand *pretmp_113
pa1-p1.c:118: note: not ssa-name.
pa1-p1.c:118: note: use not simple.
pa1-p1.c:118: note: vect_model_load_cost: unaligned supported by hardware.
pa1-p1.c:118: note: vect_model_load_cost: inside_cost = 2, prologue_cost = 0 .
pa1-p1.c:118: note: ==> examining statement: _27 = *pretmp_117[j_59];

pa1-p1.c:118: note: num. args = 4 (not unary/binary/ternary op).
pa1-p1.c:118: note: vect_is_simple_use: operand *pretmp_117[j_59]
pa1-p1.c:118: note: not ssa-name.
pa1-p1.c:118: note: use not simple.
pa1-p1.c:118: note: vect_model_load_cost: unaligned supported by hardware.
pa1-p1.c:118: note: vect_model_load_cost: inside_cost = 2, prologue_cost = 0 .
pa1-p1.c:118: note: ==> examining statement: _28 = _21 * _27;

pa1-p1.c:118: note: vect_is_simple_use: operand _21
pa1-p1.c:118: note: def_stmt: _21 = *pretmp_113;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand _27
pa1-p1.c:118: note: def_stmt: _27 = *pretmp_117[j_59];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: === vectorizable_operation ===
pa1-p1.c:118: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa1-p1.c:118: note: ==> examining statement: _29 = _16 + _28;

pa1-p1.c:118: note: vect_is_simple_use: operand _16
pa1-p1.c:118: note: def_stmt: _16 = *_15;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand _28
pa1-p1.c:118: note: def_stmt: _28 = _21 * _27;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: === vectorizable_operation ===
pa1-p1.c:118: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa1-p1.c:118: note: ==> examining statement: *_15 = _29;

pa1-p1.c:118: note: vect_is_simple_use: operand _29
pa1-p1.c:118: note: def_stmt: _29 = _16 + _28;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_model_store_cost: unaligned supported by hardware.
pa1-p1.c:118: note: vect_model_store_cost: inside_cost = 2, prologue_cost = 0 .
pa1-p1.c:118: note: ==> examining statement: j_31 = j_59 + 1;

pa1-p1.c:118: note: irrelevant.
pa1-p1.c:118: note: ==> examining statement: if (n_9(D) > j_31)

pa1-p1.c:118: note: irrelevant.
pa1-p1.c:118: note: === vect_update_slp_costs_according_to_vf ===cost model: Adding cost of checks for loop versioning aliasing.

pa1-p1.c:118: note: cost model: epilogue peel iters set to vf/2 because loop iterations are unknown .
pa1-p1.c:118: note: Cost model analysis: 
  Vector inside of loop cost: 10
  Vector prologue cost: 11
  Vector epilogue cost: 6
  Scalar iteration cost: 6
  Scalar outside cost: 1
  Vector outside cost: 17
  prologue iterations: 0
  epilogue iterations: 1
  Calculated minimum iters for profitability: 12

pa1-p1.c:118: note:   Runtime profitability threshold = 11

pa1-p1.c:118: note:   Static estimate profitability threshold = 11

pa1-p1.c:118: note: epilog loop required.
pa1-p1.c:118: note: vect_can_advance_ivs_p:
pa1-p1.c:118: note: Analyze phi: j_59 = PHI <j_31(4), 0(9)>

pa1-p1.c:118: note: Access function of PHI: {0, +, 1}_2
pa1-p1.c:118: note: Analyze phi: .MEM_69 = PHI <.MEM_30(4), .MEM_11(9)>

pa1-p1.c:118: note: virtual phi. skip.

Vectorizing loop at pa1-p1.c:118

pa1-p1.c:118: note: === vec_transform_loop ===
pa1-p1.c:118: note: Profitability threshold is 11 loop iterations.
pa1-p1.c:118: note: created vect_p.38_24
pa1-p1.c:118: note: created vect_py.41_26
pa1-p1.c:118: note: create runtime check for data references *pretmp_113 and *_15
pa1-p1.c:118: note: created vect_p.44_35
pa1-p1.c:118: note: created vect_py.47_36
pa1-p1.c:118: note: create runtime check for data references *pretmp_117[j_59] and *_15
pa1-p1.c:118: note: created 2 versioning for alias checks.

pa1-p1.c:118: note: === vect_do_peeling_for_loop_bound ===
pa1-p1.c:118: note: vect_update_ivs_after_vectorizer: phi: j_59 = PHI <j_31(4), 0(27)>

pa1-p1.c:118: note: vect_update_ivs_after_vectorizer: phi: .MEM_69 = PHI <.MEM_30(4), .MEM_11(27)>

pa1-p1.c:118: note: virtual phi. skip.Setting upper bound of nb iterations for epilogue loop to 0

pa1-p1.c:118: note: ------>vectorizing phi: j_59 = PHI <j_31(4), 0(31)>

pa1-p1.c:118: note: ------>vectorizing phi: .MEM_69 = PHI <.MEM_30(4), .MEM_11(31)>

pa1-p1.c:118: note: ------>vectorizing statement: _13 = (long unsigned int) j_59;

pa1-p1.c:118: note: ------>vectorizing statement: _14 = _13 * 8;

pa1-p1.c:118: note: ------>vectorizing statement: _15 = y_12(D) + _14;

pa1-p1.c:118: note: ------>vectorizing statement: _16 = *_15;

pa1-p1.c:118: note: transform statement.
pa1-p1.c:118: note: transform load. ncopies = 1
pa1-p1.c:118: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: *y_12(D)
pa1-p1.c:118: note: created vect_py.55_8
pa1-p1.c:118: note: add new stmt: vect_var_.56_5 = MEM[(double *)vect_py.52_7];

pa1-p1.c:118: note: ------>vectorizing statement: _21 = *pretmp_113;

pa1-p1.c:118: note: transform statement.
pa1-p1.c:118: note: transform load. ncopies = 1
pa1-p1.c:118: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: *pretmp_113
pa1-p1.c:118: note: created vect_p.60_1
pa1-p1.c:118: note: add new stmt: vect_var_.61_129 = MEM[(double *)vect_p.57_133];

pa1-p1.c:118: note: add new stmt: vect_cst_.62_128 = {_21, _21};

pa1-p1.c:118: note: created new init_stmt: vect_cst_.62_128 = {_21, _21};

pa1-p1.c:118: note: ------>vectorizing statement: vect_cst_.62_128 = {_21, _21};

pa1-p1.c:118: note: ------>vectorizing statement: _27 = *pretmp_117[j_59];

pa1-p1.c:118: note: transform statement.
pa1-p1.c:118: note: transform load. ncopies = 1
pa1-p1.c:118: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: *pretmp_117
pa1-p1.c:118: note: created vect_p.66_123
pa1-p1.c:118: note: add new stmt: vect_var_.67_118 = MEM[(double[0:D.4581] *)vect_p.63_122];

pa1-p1.c:118: note: ------>vectorizing statement: _28 = _21 * _27;

pa1-p1.c:118: note: transform statement.
pa1-p1.c:118: note: vect_is_simple_use: operand _21
pa1-p1.c:118: note: def_stmt: _21 = *pretmp_113;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand _27
pa1-p1.c:118: note: def_stmt: _27 = *pretmp_117[j_59];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: transform binary/unary operation.
pa1-p1.c:118: note: vect_get_vec_def_for_operand: _21
pa1-p1.c:118: note: vect_is_simple_use: operand _21
pa1-p1.c:118: note: def_stmt: _21 = *pretmp_113;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: def =  _21  def_stmt =  _21 = *pretmp_113;

pa1-p1.c:118: note: vect_get_vec_def_for_operand: _27
pa1-p1.c:118: note: vect_is_simple_use: operand _27
pa1-p1.c:118: note: def_stmt: _27 = *pretmp_117[j_59];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: def =  _27  def_stmt =  _27 = *pretmp_117[j_59];

pa1-p1.c:118: note: add new stmt: vect_var_.68_114 = vect_cst_.62_128 * vect_var_.67_118;

pa1-p1.c:118: note: ------>vectorizing statement: _29 = _16 + _28;

pa1-p1.c:118: note: transform statement.
pa1-p1.c:118: note: vect_is_simple_use: operand _16
pa1-p1.c:118: note: def_stmt: _16 = *_15;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand _28
pa1-p1.c:118: note: def_stmt: _28 = _21 * _27;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: transform binary/unary operation.
pa1-p1.c:118: note: vect_get_vec_def_for_operand: _16
pa1-p1.c:118: note: vect_is_simple_use: operand _16
pa1-p1.c:118: note: def_stmt: _16 = *_15;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: def =  _16  def_stmt =  _16 = *_15;

pa1-p1.c:118: note: vect_get_vec_def_for_operand: _28
pa1-p1.c:118: note: vect_is_simple_use: operand _28
pa1-p1.c:118: note: def_stmt: _28 = _21 * _27;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: def =  _28  def_stmt =  _28 = _21 * _27;

pa1-p1.c:118: note: add new stmt: vect_var_.69_110 = vect_var_.56_5 + vect_var_.68_114;

pa1-p1.c:118: note: ------>vectorizing statement: *_15 = _29;

pa1-p1.c:118: note: transform statement.
pa1-p1.c:118: note: vect_is_simple_use: operand _29
pa1-p1.c:118: note: def_stmt: _29 = _16 + _28;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: transform store. ncopies = 1
pa1-p1.c:118: note: vect_get_vec_def_for_operand: _29
pa1-p1.c:118: note: vect_is_simple_use: operand _29
pa1-p1.c:118: note: def_stmt: _29 = _16 + _28;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: def =  _29  def_stmt =  _29 = _16 + _28;

pa1-p1.c:118: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: *y_12(D)
pa1-p1.c:118: note: created vect_py.73_109
pa1-p1.c:118: note: add new stmt: MEM[(double *)vect_py.70_108] = vect_var_.69_110;

pa1-p1.c:118: note: ------>vectorizing statement: j_31 = j_59 + 1;

pa1-p1.c:118: note: ------>vectorizing statement: vect_py.52_6 = vect_py.52_7 + 16;

pa1-p1.c:118: note: ------>vectorizing statement: vect_p.57_130 = vect_p.57_133 + 0;

pa1-p1.c:118: note: ------>vectorizing statement: vect_p.63_121 = vect_p.63_122 + 16;

pa1-p1.c:118: note: ------>vectorizing statement: vect_py.70_107 = vect_py.70_108 + 16;

pa1-p1.c:118: note: ------>vectorizing statement: if (n_9(D) > j_31)

loop at pa1-p1.c:119: if (ivtmp_103 < bnd.49_81)

pa1-p1.c:118: note: LOOP VECTORIZED.
pa1-p1.c:106: note: vectorized 1 loops in function.

pa1-p1.c:118: note: Turned loop into non-loop; it never loops.

pa1-p1.c:118: note: ===vect_slp_analyze_bb===

pa1-p1.c:118: note: === vect_analyze_data_refs ===

pa1-p1.c:118: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:119: note: ===vect_slp_analyze_bb===

pa1-p1.c:119: note: === vect_analyze_data_refs ===

pa1-p1.c:119: note: get vectype with 2 units of type double
pa1-p1.c:119: note: vectype: vector(2) double
pa1-p1.c:119: note: get vectype with 2 units of type double
pa1-p1.c:119: note: vectype: vector(2) double
pa1-p1.c:119: note: get vectype with 2 units of type double
pa1-p1.c:119: note: vectype: vector(2) double
pa1-p1.c:119: note: get vectype with 2 units of type double
pa1-p1.c:119: note: vectype: vector(2) double
pa1-p1.c:119: note: === vect_pattern_recog ===
pa1-p1.c:119: note: vect_is_simple_use: operand _93
pa1-p1.c:119: note: def_stmt: _93 = (long unsigned int) j_95;

pa1-p1.c:119: note: type of def: 3.
pa1-p1.c:119: note: vect_is_simple_use: operand j_95
pa1-p1.c:119: note: def_stmt: j_95 = PHI <0(5), j_84(7)>

pa1-p1.c:119: note: type of def: 2.
pa1-p1.c:119: note: vect_is_simple_use: operand 8
pa1-p1.c:119: note: vect_is_simple_use: operand _89
pa1-p1.c:119: note: def_stmt: _89 = *pretmp_113;

pa1-p1.c:119: note: type of def: 3.
pa1-p1.c:119: note: === vect_analyze_dependences ===
pa1-p1.c:119: note: determined dependence between *_91 and *_91
pa1-p1.c:119: note: can't determine dependence between *pretmp_113 and *_91
pa1-p1.c:119: note: can't determine dependence between *pretmp_117[j_95] and *_91
pa1-p1.c:119: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:119: note: vect_compute_data_ref_alignment:
pa1-p1.c:119: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:119: note: Unknown alignment for access: *y_12(D)
pa1-p1.c:119: note: vect_compute_data_ref_alignment:
pa1-p1.c:119: note: can't force alignment of ref: *pretmp_113
pa1-p1.c:119: note: vect_compute_data_ref_alignment:
pa1-p1.c:119: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:119: note: Unknown alignment for access: *(m_25(D) + pretmp_116)
pa1-p1.c:119: note: vect_compute_data_ref_alignment:
pa1-p1.c:119: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:119: note: Unknown alignment for access: *y_12(D)
pa1-p1.c:119: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:119: note: not consecutive access _89 = *pretmp_113;

pa1-p1.c:119: note: === vect_analyze_slp ===
pa1-p1.c:119: note: Failed to SLP the basic block.
pa1-p1.c:119: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:119: note: ===vect_slp_analyze_bb===

pa1-p1.c:119: note: === vect_analyze_data_refs ===

pa1-p1.c:119: note: not vectorized: no vectype for stmt: vect_var_.56_5 = MEM[(double *)vect_py.52_7];
 scalar_type: vector(2) double
pa1-p1.c:119: note: === vect_pattern_recog ===
pa1-p1.c:119: note: vect_is_simple_use: operand vect_cst_.62_128
pa1-p1.c:119: note: def_stmt: vect_cst_.62_128 = {_21, _21};

pa1-p1.c:119: note: type of def: 3.
pa1-p1.c:119: note: === vect_analyze_dependences ===
pa1-p1.c:119: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:119: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:119: note: === vect_analyze_slp ===
pa1-p1.c:119: note: Failed to SLP the basic block.
pa1-p1.c:119: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:119: note: ===vect_slp_analyze_bb===

pa1-p1.c:119: note: === vect_analyze_data_refs ===

pa1-p1.c:119: note: get vectype with 2 units of type double
pa1-p1.c:119: note: vectype: vector(2) double
pa1-p1.c:119: note: get vectype with 2 units of type double
pa1-p1.c:119: note: vectype: vector(2) double
pa1-p1.c:119: note: get vectype with 2 units of type double
pa1-p1.c:119: note: vectype: vector(2) double
pa1-p1.c:119: note: get vectype with 2 units of type double
pa1-p1.c:119: note: vectype: vector(2) double
pa1-p1.c:119: note: === vect_pattern_recog ===
pa1-p1.c:119: note: vect_is_simple_use: operand _76
pa1-p1.c:119: note: def_stmt: _76 = (long unsigned int) j_60;

pa1-p1.c:119: note: type of def: 3.
pa1-p1.c:119: note: vect_is_simple_use: operand j_60
pa1-p1.c:119: note: def_stmt: j_60 = PHI <tmp.51_33(11), 0(8)>

pa1-p1.c:119: note: type of def: 2.
pa1-p1.c:119: note: vect_is_simple_use: operand 8
pa1-p1.c:119: note: vect_is_simple_use: operand _70
pa1-p1.c:119: note: def_stmt: _70 = *pretmp_113;

pa1-p1.c:119: note: type of def: 3.
pa1-p1.c:119: note: === vect_analyze_dependences ===
pa1-p1.c:119: note: determined dependence between *_74 and *_74
pa1-p1.c:119: note: can't determine dependence between *pretmp_113 and *_74
pa1-p1.c:119: note: can't determine dependence between *pretmp_117[j_60] and *_74
pa1-p1.c:119: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:119: note: vect_compute_data_ref_alignment:
pa1-p1.c:119: note: can't force alignment of ref: *_74
pa1-p1.c:119: note: vect_compute_data_ref_alignment:
pa1-p1.c:119: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:119: note: Unknown alignment for access: *x_19(D)
pa1-p1.c:119: note: vect_compute_data_ref_alignment:
pa1-p1.c:119: note: Unknown alignment for access: *(m_25(D) + pretmp_116)
pa1-p1.c:119: note: vect_compute_data_ref_alignment:
pa1-p1.c:119: note: can't force alignment of ref: *_74
pa1-p1.c:119: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:119: note: not consecutive access _72 = *_74;

pa1-p1.c:119: note: not consecutive access _67 = *pretmp_117[j_60];

pa1-p1.c:119: note: not consecutive access *_74 = _64;

pa1-p1.c:119: note: === vect_analyze_slp ===
pa1-p1.c:119: note: Failed to SLP the basic block.
pa1-p1.c:119: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:118: note: ===vect_slp_analyze_bb===

pa1-p1.c:118: note: === vect_analyze_data_refs ===

pa1-p1.c:118: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:122: note: ===vect_slp_analyze_bb===

pa1-p1.c:122: note: === vect_analyze_data_refs ===

pa1-p1.c:122: note: get vectype with 2 units of type double
pa1-p1.c:122: note: vectype: vector(2) double
pa1-p1.c:122: note: get vectype with 2 units of type double
pa1-p1.c:122: note: vectype: vector(2) double
pa1-p1.c:122: note: get vectype with 2 units of type double
pa1-p1.c:122: note: vectype: vector(2) double
pa1-p1.c:122: note: get vectype with 2 units of type double
pa1-p1.c:122: note: vectype: vector(2) double
pa1-p1.c:122: note: === vect_pattern_recog ===
pa1-p1.c:122: note: vect_is_simple_use: operand _39
pa1-p1.c:122: note: def_stmt: _39 = (long unsigned int) i_61;

pa1-p1.c:122: note: type of def: 3.
pa1-p1.c:122: note: vect_is_simple_use: operand i_61
pa1-p1.c:122: note: def_stmt: i_61 = PHI <i_52(18), 0(22)>

pa1-p1.c:122: note: type of def: 2.
pa1-p1.c:122: note: vect_is_simple_use: operand 8
pa1-p1.c:122: note: vect_is_simple_use: operand _42
pa1-p1.c:122: note: def_stmt: _42 = *_41;

pa1-p1.c:122: note: type of def: 3.
pa1-p1.c:122: note: === vect_analyze_dependences ===
pa1-p1.c:122: note: determined dependence between *pretmp_127 and *pretmp_127
pa1-p1.c:122: note: can't determine dependence between *_41 and *pretmp_127
pa1-p1.c:122: note: can't determine dependence between *pretmp_132[i_61] and *pretmp_127
pa1-p1.c:122: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:122: note: vect_compute_data_ref_alignment:
pa1-p1.c:122: note: can't force alignment of ref: *pretmp_127
pa1-p1.c:122: note: vect_compute_data_ref_alignment:
pa1-p1.c:122: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:122: note: Unknown alignment for access: *x_19(D)
pa1-p1.c:122: note: vect_compute_data_ref_alignment:
pa1-p1.c:122: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:122: note: Unknown alignment for access: *(m_25(D) + pretmp_131)
pa1-p1.c:122: note: vect_compute_data_ref_alignment:
pa1-p1.c:122: note: can't force alignment of ref: *pretmp_127
pa1-p1.c:122: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:122: note: not consecutive access _38 = *pretmp_127;

pa1-p1.c:122: note: not consecutive access *pretmp_127 = _50;

pa1-p1.c:122: note: === vect_analyze_slp ===
pa1-p1.c:122: note: Failed to SLP the basic block.
pa1-p1.c:122: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:121: note: ===vect_slp_analyze_bb===

pa1-p1.c:121: note: === vect_analyze_data_refs ===

pa1-p1.c:121: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:106: note: ===vect_slp_analyze_bb===

pa1-p1.c:106: note: === vect_analyze_data_refs ===

pa1-p1.c:106: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:124: note: ===vect_slp_analyze_bb===

pa1-p1.c:124: note: === vect_analyze_data_refs ===

pa1-p1.c:124: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:132: note: ===vect_slp_analyze_bb===

pa1-p1.c:132: note: === vect_analyze_data_refs ===

pa1-p1.c:132: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:133: note: ===vect_slp_analyze_bb===

pa1-p1.c:133: note: === vect_analyze_data_refs ===

pa1-p1.c:133: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:134: note: ===vect_slp_analyze_bb===

pa1-p1.c:134: note: === vect_analyze_data_refs ===

pa1-p1.c:134: note: get vectype with 2 units of type __time_t
pa1-p1.c:134: note: vectype: vector(2) long int
pa1-p1.c:134: note: get vectype with 2 units of type __suseconds_t
pa1-p1.c:134: note: vectype: vector(2) long int
pa1-p1.c:134: note: get vectype with 2 units of type long unsigned int
pa1-p1.c:134: note: vectype: vector(2) long unsigned int
pa1-p1.c:134: note: not vectorized: no vectype for stmt: Tp ={v} {CLOBBER};
 scalar_type: struct timeval
pa1-p1.c:134: note: === vect_pattern_recog ===
pa1-p1.c:134: note: vect_is_simple_use: operand _9
pa1-p1.c:134: note: def_stmt: _9 = (double) _8;

pa1-p1.c:134: note: type of def: 3.
pa1-p1.c:134: note: === vect_analyze_dependences ===
pa1-p1.c:134: note: Detected interleaving Tp.tv_sec and Tp.tv_usec
pa1-p1.c:134: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:134: note: vect_compute_data_ref_alignment:
pa1-p1.c:134: note: misalign = 0 bytes of ref Tp.tv_sec
pa1-p1.c:134: note: vect_compute_data_ref_alignment:
pa1-p1.c:134: note: misalign = 8 bytes of ref Tp.tv_usec
pa1-p1.c:134: note: vect_compute_data_ref_alignment:
pa1-p1.c:134: note: misalign = 0 bytes of ref Tzp
pa1-p1.c:134: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:134: note: Detected interleaving of size 2
pa1-p1.c:134: note: not consecutive access Tzp ={v} {CLOBBER};

pa1-p1.c:134: note: === vect_analyze_slp ===
pa1-p1.c:134: note: Failed to SLP the basic block.
pa1-p1.c:134: note: not vectorized: failed to find SLP opportunities in basic block.

Analyzing loop at pa1-p1.c:144

pa1-p1.c:144: note: ===== analyze_loop_nest =====
pa1-p1.c:144: note: === vect_analyze_loop_form ===
pa1-p1.c:144: note: not vectorized: control flow in loop.
pa1-p1.c:144: note: bad loop form.
pa1-p1.c:137: note: vectorized 0 loops in function.

pa1-p1.c:144: note: ===vect_slp_analyze_bb===

pa1-p1.c:144: note: === vect_analyze_data_refs ===

pa1-p1.c:144: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:137: note: ===vect_slp_analyze_bb===

pa1-p1.c:137: note: === vect_analyze_data_refs ===

pa1-p1.c:137: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:146: note: ===vect_slp_analyze_bb===

pa1-p1.c:146: note: === vect_analyze_data_refs ===

pa1-p1.c:146: note: get vectype with 2 units of type double
pa1-p1.c:146: note: vectype: vector(2) double
pa1-p1.c:146: note: get vectype with 2 units of type double
pa1-p1.c:146: note: vectype: vector(2) double
pa1-p1.c:146: note: === vect_pattern_recog ===
pa1-p1.c:146: note: vect_is_simple_use: operand _9
pa1-p1.c:146: note: def_stmt: _9 = (long unsigned int) i_31;

pa1-p1.c:146: note: type of def: 3.
pa1-p1.c:146: note: vect_is_simple_use: operand i_31
pa1-p1.c:146: note: def_stmt: i_31 = PHI <i_21(10), 0(3)>

pa1-p1.c:146: note: type of def: 2.
pa1-p1.c:146: note: vect_is_simple_use: operand 8
pa1-p1.c:146: note: === vect_analyze_dependences ===
pa1-p1.c:146: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:146: note: vect_compute_data_ref_alignment:
pa1-p1.c:146: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:146: note: Unknown alignment for access: *wref_11(D)
pa1-p1.c:146: note: vect_compute_data_ref_alignment:
pa1-p1.c:146: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:146: note: Unknown alignment for access: *w_15(D)
pa1-p1.c:146: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:146: note: === vect_analyze_slp ===
pa1-p1.c:146: note: Failed to SLP the basic block.
pa1-p1.c:146: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:147: note: ===vect_slp_analyze_bb===

pa1-p1.c:147: note: === vect_analyze_data_refs ===

pa1-p1.c:147: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:148: note: ===vect_slp_analyze_bb===

pa1-p1.c:148: note: === vect_analyze_data_refs ===

pa1-p1.c:148: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:149: note: ===vect_slp_analyze_bb===

pa1-p1.c:149: note: === vect_analyze_data_refs ===

pa1-p1.c:149: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:137: note: ===vect_slp_analyze_bb===

pa1-p1.c:137: note: === vect_analyze_data_refs ===

pa1-p1.c:137: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:144: note: ===vect_slp_analyze_bb===

pa1-p1.c:144: note: === vect_analyze_data_refs ===

pa1-p1.c:144: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:137: note: ===vect_slp_analyze_bb===

pa1-p1.c:137: note: === vect_analyze_data_refs ===

pa1-p1.c:137: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:153: note: ===vect_slp_analyze_bb===

pa1-p1.c:153: note: === vect_analyze_data_refs ===

pa1-p1.c:153: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:154: note: ===vect_slp_analyze_bb===

pa1-p1.c:154: note: === vect_analyze_data_refs ===

pa1-p1.c:154: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:157: note: ===vect_slp_analyze_bb===

pa1-p1.c:157: note: === vect_analyze_data_refs ===

pa1-p1.c:157: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:158: note: ===vect_slp_analyze_bb===

pa1-p1.c:158: note: === vect_analyze_data_refs ===

pa1-p1.c:158: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:162: note: ===vect_slp_analyze_bb===

pa1-p1.c:162: note: === vect_analyze_data_refs ===

pa1-p1.c:162: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at pa1-p1.c:80

pa1-p1.c:80: note: ===== analyze_loop_nest =====
pa1-p1.c:80: note: === vect_analyze_loop_form ===
pa1-p1.c:80: note: not vectorized: multiple nested loops.
pa1-p1.c:80: note: bad loop form.
Analyzing loop at pa1-p1.c:121

pa1-p1.c:121: note: ===== analyze_loop_nest =====
pa1-p1.c:121: note: === vect_analyze_loop_form ===
pa1-p1.c:121: note: ===== analyze_loop_nest_1 =====
pa1-p1.c:121: note: === vect_analyze_loop_form ===
pa1-p1.c:121: note: === get_loop_niters ===
pa1-p1.c:121: note: ==> get_loop_niters:4096
pa1-p1.c:121: note: Considering outer-loop vectorization.
pa1-p1.c:121: note: === get_loop_niters ===
pa1-p1.c:121: note: ==> get_loop_niters:4096
pa1-p1.c:121: note: === vect_analyze_data_refs ===

pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: analyze in outer-loop: x
pa1-p1.c:121: note: 	outer base_address: &x
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 128
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: analyze in outer-loop: *(&A + (long unsigned int) j_233 * 32768)
pa1-p1.c:121: note: 	outer base_address: &A
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 32768
	outer aligned to: 128
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:121: note: Analyze phi: .MEM_138 = PHI <.MEM_191(42), .MEM_346(48)>

pa1-p1.c:121: note: Analyze phi: j_233 = PHI <0(42), j_181(48)>

pa1-p1.c:121: note: Access function of PHI: {0, +, 1}_10
pa1-p1.c:121: note: step: 1,  init: 0
pa1-p1.c:121: note: Detected induction.
pa1-p1.c:121: note: Analyze phi: ivtmp_125 = PHI <4096(42), ivtmp_127(48)>

pa1-p1.c:121: note: Access function of PHI: {4096, +, 4294967295}_10
pa1-p1.c:121: note: step: 4294967295,  init: 4096
pa1-p1.c:121: note: Detected induction.
pa1-p1.c:121: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:121: note: Analyze phi: i_234 = PHI <i_180(45), 0(49)>

pa1-p1.c:121: note: Access function of PHI: {0, +, 1}_11
pa1-p1.c:121: note: step: 1,  init: 0
pa1-p1.c:121: note: Detected induction.
pa1-p1.c:121: note: Analyze phi: .MEM_237 = PHI <.MEM_237(45), .MEM_138(49)>

pa1-p1.c:121: note: Analyze phi: D__lsm.126_192 = PHI <_179(45), D__lsm.126_348(49)>

pa1-p1.c:121: note: Access function of PHI: {D__lsm.126_348, +, _178}_11
pa1-p1.c:121: note: step: _178,  init: D__lsm.126_348
pa1-p1.c:121: note: step unknown.
pa1-p1.c:121: note: Analyze phi: ivtmp_121 = PHI <ivtmp_124(45), 4096(49)>

pa1-p1.c:121: note: Access function of PHI: {4096, +, 4294967295}_11
pa1-p1.c:121: note: step: 4294967295,  init: 4096
pa1-p1.c:121: note: Detected induction.
pa1-p1.c:121: note: Analyze phi: D__lsm.126_192 = PHI <_179(45), D__lsm.126_348(49)>

pa1-p1.c:121: note: detected reduction: _179 = _178 + D__lsm.126_192;

pa1-p1.c:121: note: Detected vectorizable nested cycle.
pa1-p1.c:121: note: === vect_pattern_recog ===
pa1-p1.c:121: note: vect_is_simple_use: operand pretmp_332
pa1-p1.c:121: note: def_stmt: pretmp_332 = (long unsigned int) j_233;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: vect_is_simple_use: operand j_233
pa1-p1.c:121: note: def_stmt: j_233 = PHI <0(42), j_181(48)>

pa1-p1.c:121: note: type of def: 4.
pa1-p1.c:121: note: vect_is_simple_use: operand 8
pa1-p1.c:121: note: vect_is_simple_use: operand pretmp_332
pa1-p1.c:121: note: def_stmt: pretmp_332 = (long unsigned int) j_233;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: vect_is_simple_use: operand j_233
pa1-p1.c:121: note: def_stmt: j_233 = PHI <0(42), j_181(48)>

pa1-p1.c:121: note: type of def: 4.
pa1-p1.c:121: note: vect_is_simple_use: operand 32768
pa1-p1.c:121: note: vect_is_simple_use: operand _169
pa1-p1.c:121: note: def_stmt: _169 = (long unsigned int) i_234;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: vect_is_simple_use: operand i_234
pa1-p1.c:121: note: def_stmt: i_234 = PHI <i_180(45), 0(49)>

pa1-p1.c:121: note: type of def: 4.
pa1-p1.c:121: note: vect_is_simple_use: operand 8
pa1-p1.c:121: note: vect_is_simple_use: operand _172
pa1-p1.c:121: note: def_stmt: _172 = *_171;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: === vect_mark_stmts_to_be_vectorized ===
pa1-p1.c:121: note: init: phi relevant? .MEM_138 = PHI <.MEM_191(42), .MEM_346(48)>

pa1-p1.c:121: note: init: phi relevant? j_233 = PHI <0(42), j_181(48)>

pa1-p1.c:121: note: init: phi relevant? ivtmp_125 = PHI <4096(42), ivtmp_127(48)>

pa1-p1.c:121: note: init: stmt relevant? pretmp_332 = (long unsigned int) j_233;

pa1-p1.c:121: note: init: stmt relevant? pretmp_333 = pretmp_332 * 8;

pa1-p1.c:121: note: init: stmt relevant? pretmp_334 = &zz + pretmp_333;

pa1-p1.c:121: note: init: stmt relevant? pretmp_339 = pretmp_332 * 32768;

pa1-p1.c:121: note: init: stmt relevant? pretmp_340 = &A + pretmp_339;

pa1-p1.c:121: note: init: stmt relevant? D__lsm.126_348 = MEM[(double *)pretmp_334];

pa1-p1.c:121: note: init: phi relevant? i_234 = PHI <i_180(45), 0(49)>

pa1-p1.c:121: note: init: phi relevant? .MEM_237 = PHI <.MEM_237(45), .MEM_138(49)>

pa1-p1.c:121: note: init: phi relevant? D__lsm.126_192 = PHI <_179(45), D__lsm.126_348(49)>

pa1-p1.c:121: note: init: phi relevant? ivtmp_121 = PHI <ivtmp_124(45), 4096(49)>

pa1-p1.c:121: note: init: stmt relevant? _169 = (long unsigned int) i_234;

pa1-p1.c:121: note: init: stmt relevant? _170 = _169 * 8;

pa1-p1.c:121: note: init: stmt relevant? _171 = &x + _170;

pa1-p1.c:121: note: init: stmt relevant? _172 = *_171;

pa1-p1.c:121: note: init: stmt relevant? _177 = MEM[(double[0:D.4581] *)pretmp_340][i_234];

pa1-p1.c:121: note: init: stmt relevant? _178 = _172 * _177;

pa1-p1.c:121: note: init: stmt relevant? _179 = _178 + D__lsm.126_192;

pa1-p1.c:121: note: init: stmt relevant? i_180 = i_234 + 1;

pa1-p1.c:121: note: init: stmt relevant? ivtmp_124 = ivtmp_121 - 1;

pa1-p1.c:121: note: init: stmt relevant? if (ivtmp_124 != 0)

pa1-p1.c:121: note: init: phi relevant? D__lsm.126_345 = PHI <_179(46)>

pa1-p1.c:121: note: init: stmt relevant? MEM[(double *)pretmp_334] = D__lsm.126_345;

pa1-p1.c:121: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:121: note: mark relevant 4, live 0.
pa1-p1.c:121: note: init: stmt relevant? j_181 = j_233 + 1;

pa1-p1.c:121: note: init: stmt relevant? ivtmp_127 = ivtmp_125 - 1;

pa1-p1.c:121: note: init: stmt relevant? if (ivtmp_127 != 0)

pa1-p1.c:121: note: worklist: examine stmt: MEM[(double *)pretmp_334] = D__lsm.126_345;

pa1-p1.c:121: note: vect_is_simple_use: operand D__lsm.126_345
pa1-p1.c:121: note: def_stmt: D__lsm.126_345 = PHI <_179(46)>

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: mark relevant 4, live 0.
pa1-p1.c:121: note: worklist: examine stmt: D__lsm.126_345 = PHI <_179(46)>

pa1-p1.c:121: note: vect_is_simple_use: operand _179
pa1-p1.c:121: note: def_stmt: _179 = _178 + D__lsm.126_192;

pa1-p1.c:121: note: type of def: 7.
pa1-p1.c:121: note: inner-loop def-stmt defining outer-loop stmt.
pa1-p1.c:121: note: mark relevant 2, live 0.
pa1-p1.c:121: note: worklist: examine stmt: _179 = _178 + D__lsm.126_192;

pa1-p1.c:121: note: vect_is_simple_use: operand _178
pa1-p1.c:121: note: def_stmt: _178 = _172 * _177;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: mark relevant 2, live 0.
pa1-p1.c:121: note: vect_is_simple_use: operand D__lsm.126_192
pa1-p1.c:121: note: def_stmt: D__lsm.126_192 = PHI <_179(45), D__lsm.126_348(49)>

pa1-p1.c:121: note: type of def: 7.
pa1-p1.c:121: note: mark relevant 2, live 0.
pa1-p1.c:121: note: worklist: examine stmt: D__lsm.126_192 = PHI <_179(45), D__lsm.126_348(49)>

pa1-p1.c:121: note: vect_is_simple_use: operand _179
pa1-p1.c:121: note: def_stmt: _179 = _178 + D__lsm.126_192;

pa1-p1.c:121: note: type of def: 7.
pa1-p1.c:121: note: mark relevant 2, live 0.
pa1-p1.c:121: note: already marked relevant/live.
pa1-p1.c:121: note: vect_is_simple_use: operand D__lsm.126_348
pa1-p1.c:121: note: def_stmt: D__lsm.126_348 = MEM[(double *)pretmp_334];

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: outer-loop def-stmt defining inner-loop stmt.
pa1-p1.c:121: note: mark relevant 4, live 0.
pa1-p1.c:121: note: worklist: examine stmt: D__lsm.126_348 = MEM[(double *)pretmp_334];

pa1-p1.c:121: note: worklist: examine stmt: _178 = _172 * _177;

pa1-p1.c:121: note: vect_is_simple_use: operand _172
pa1-p1.c:121: note: def_stmt: _172 = *_171;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: mark relevant 2, live 0.
pa1-p1.c:121: note: vect_is_simple_use: operand _177
pa1-p1.c:121: note: def_stmt: _177 = MEM[(double[0:D.4581] *)pretmp_340][i_234];

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: mark relevant 2, live 0.
pa1-p1.c:121: note: worklist: examine stmt: _177 = MEM[(double[0:D.4581] *)pretmp_340][i_234];

pa1-p1.c:121: note: worklist: examine stmt: _172 = *_171;

pa1-p1.c:121: note: === vect_analyze_dependences ===
pa1-p1.c:121: note: dependence distance  = 0.
pa1-p1.c:121: note: dependence distance == 0 between MEM[(double *)pretmp_334] and MEM[(double *)pretmp_334]
pa1-p1.c:121: note: === vect_determine_vectorization_factor ===
pa1-p1.c:121: note: ==> examining phi: .MEM_138 = PHI <.MEM_191(42), .MEM_346(48)>

pa1-p1.c:121: note: ==> examining phi: j_233 = PHI <0(42), j_181(48)>

pa1-p1.c:121: note: ==> examining phi: ivtmp_125 = PHI <4096(42), ivtmp_127(48)>

pa1-p1.c:121: note: ==> examining statement: pretmp_332 = (long unsigned int) j_233;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: pretmp_333 = pretmp_332 * 8;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: pretmp_334 = &zz + pretmp_333;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: pretmp_339 = pretmp_332 * 32768;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: pretmp_340 = &A + pretmp_339;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: D__lsm.126_348 = MEM[(double *)pretmp_334];

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining phi: i_234 = PHI <i_180(45), 0(49)>

pa1-p1.c:121: note: ==> examining phi: .MEM_237 = PHI <.MEM_237(45), .MEM_138(49)>

pa1-p1.c:121: note: ==> examining phi: D__lsm.126_192 = PHI <_179(45), D__lsm.126_348(49)>

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining phi: ivtmp_121 = PHI <ivtmp_124(45), 4096(49)>

pa1-p1.c:121: note: ==> examining statement: _169 = (long unsigned int) i_234;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: _170 = _169 * 8;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: _171 = &x + _170;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: _172 = *_171;

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: _177 = MEM[(double[0:D.4581] *)pretmp_340][i_234];

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: _178 = _172 * _177;

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: _179 = _178 + D__lsm.126_192;

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: i_180 = i_234 + 1;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: ivtmp_124 = ivtmp_121 - 1;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: if (ivtmp_124 != 0)

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining phi: D__lsm.126_345 = PHI <_179(46)>

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: MEM[(double *)pretmp_334] = D__lsm.126_345;

pa1-p1.c:121: note: get vectype for scalar type:  double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: nunits = 2
pa1-p1.c:121: note: ==> examining statement: j_181 = j_233 + 1;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: ivtmp_127 = ivtmp_125 - 1;

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: ==> examining statement: if (ivtmp_127 != 0)

pa1-p1.c:121: note: skip.
pa1-p1.c:121: note: vectorization factor = 2
pa1-p1.c:121: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:121: note: dependence distance  = 0.
pa1-p1.c:121: note: accesses have the same alignment.dependence distance modulo vf == 0 between MEM[(double *)pretmp_334] and MEM[(double *)pretmp_334]
pa1-p1.c:121: note: vect_compute_data_ref_alignment:
pa1-p1.c:121: note: misalign = 0 bytes of ref MEM[(double *)pretmp_334]
pa1-p1.c:121: note: vect_compute_data_ref_alignment:
pa1-p1.c:121: note: inner step doesn't divide the vector-size.
pa1-p1.c:121: note: Unknown alignment for access: x
pa1-p1.c:121: note: vect_compute_data_ref_alignment:
pa1-p1.c:121: note: inner step doesn't divide the vector-size.
pa1-p1.c:121: note: Unknown alignment for access: *(&A + (long unsigned int) j_233 * 32768)
pa1-p1.c:121: note: vect_compute_data_ref_alignment:
pa1-p1.c:121: note: misalign = 0 bytes of ref MEM[(double *)pretmp_334]
pa1-p1.c:121: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:121: note: zero step in outer loop.
pa1-p1.c:121: note: grouped access in outer loop.
pa1-p1.c:121: note: not vectorized: complicated access pattern.
pa1-p1.c:121: note: bad data access.
Analyzing loop at pa1-p1.c:121

pa1-p1.c:121: note: ===== analyze_loop_nest =====
pa1-p1.c:121: note: === vect_analyze_loop_form ===
pa1-p1.c:121: note: === get_loop_niters ===
pa1-p1.c:121: note: ==> get_loop_niters:4096
pa1-p1.c:121: note: === vect_analyze_data_refs ===

pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:121: note: Analyze phi: i_234 = PHI <i_180(45), 0(49)>

pa1-p1.c:121: note: Access function of PHI: {0, +, 1}_11
pa1-p1.c:121: note: step: 1,  init: 0
pa1-p1.c:121: note: Detected induction.
pa1-p1.c:121: note: Analyze phi: .MEM_237 = PHI <.MEM_237(45), .MEM_138(49)>

pa1-p1.c:121: note: Analyze phi: D__lsm.126_192 = PHI <_179(45), D__lsm.126_348(49)>

pa1-p1.c:121: note: Access function of PHI: {D__lsm.126_348, +, _178}_11
pa1-p1.c:121: note: step: _178,  init: D__lsm.126_348
pa1-p1.c:121: note: step unknown.
pa1-p1.c:121: note: Analyze phi: ivtmp_121 = PHI <ivtmp_124(45), 4096(49)>

pa1-p1.c:121: note: Access function of PHI: {4096, +, 4294967295}_11
pa1-p1.c:121: note: step: 4294967295,  init: 4096
pa1-p1.c:121: note: Detected induction.
pa1-p1.c:121: note: Analyze phi: D__lsm.126_192 = PHI <_179(45), D__lsm.126_348(49)>

pa1-p1.c:121: note: reduction: unsafe fp math optimization: _179 = _178 + D__lsm.126_192;

pa1-p1.c:121: note: Unknown def-use cycle pattern.
pa1-p1.c:121: note: === vect_pattern_recog ===
pa1-p1.c:121: note: vect_is_simple_use: operand _169
pa1-p1.c:121: note: def_stmt: _169 = (long unsigned int) i_234;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: vect_is_simple_use: operand i_234
pa1-p1.c:121: note: def_stmt: i_234 = PHI <i_180(45), 0(49)>

pa1-p1.c:121: note: type of def: 4.
pa1-p1.c:121: note: vect_is_simple_use: operand 8
pa1-p1.c:121: note: vect_is_simple_use: operand _172
pa1-p1.c:121: note: def_stmt: _172 = *_171;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: === vect_mark_stmts_to_be_vectorized ===
pa1-p1.c:121: note: init: phi relevant? i_234 = PHI <i_180(45), 0(49)>

pa1-p1.c:121: note: init: phi relevant? .MEM_237 = PHI <.MEM_237(45), .MEM_138(49)>

pa1-p1.c:121: note: init: phi relevant? D__lsm.126_192 = PHI <_179(45), D__lsm.126_348(49)>

pa1-p1.c:121: note: init: phi relevant? ivtmp_121 = PHI <ivtmp_124(45), 4096(49)>

pa1-p1.c:121: note: init: stmt relevant? _169 = (long unsigned int) i_234;

pa1-p1.c:121: note: init: stmt relevant? _170 = _169 * 8;

pa1-p1.c:121: note: init: stmt relevant? _171 = &x + _170;

pa1-p1.c:121: note: init: stmt relevant? _172 = *_171;

pa1-p1.c:121: note: init: stmt relevant? _177 = MEM[(double[0:D.4581] *)pretmp_340][i_234];

pa1-p1.c:121: note: init: stmt relevant? _178 = _172 * _177;

pa1-p1.c:121: note: init: stmt relevant? _179 = _178 + D__lsm.126_192;

pa1-p1.c:121: note: vec_stmt_relevant_p: used out of loop.
pa1-p1.c:121: note: mark relevant 0, live 1.
pa1-p1.c:121: note: init: stmt relevant? i_180 = i_234 + 1;

pa1-p1.c:121: note: init: stmt relevant? ivtmp_124 = ivtmp_121 - 1;

pa1-p1.c:121: note: init: stmt relevant? if (ivtmp_124 != 0)

pa1-p1.c:121: note: worklist: examine stmt: _179 = _178 + D__lsm.126_192;

pa1-p1.c:121: note: vect_is_simple_use: operand _178
pa1-p1.c:121: note: def_stmt: _178 = _172 * _177;

pa1-p1.c:121: note: type of def: 3.
pa1-p1.c:121: note: mark relevant 0, live 1.
pa1-p1.c:121: note: vect_is_simple_use: operand D__lsm.126_192
pa1-p1.c:121: note: def_stmt: D__lsm.126_192 = PHI <_179(45), D__lsm.126_348(49)>

pa1-p1.c:121: note: Unsupported pattern.
pa1-p1.c:121: note: not vectorized: unsupported use in stmt.
pa1-p1.c:121: note: unexpected pattern.
Analyzing loop at pa1-p1.c:118

pa1-p1.c:118: note: ===== analyze_loop_nest =====
pa1-p1.c:118: note: === vect_analyze_loop_form ===
pa1-p1.c:118: note: ===== analyze_loop_nest_1 =====
pa1-p1.c:118: note: === vect_analyze_loop_form ===
pa1-p1.c:118: note: === get_loop_niters ===
pa1-p1.c:118: note: ==> get_loop_niters:4096
pa1-p1.c:118: note: Considering outer-loop vectorization.
pa1-p1.c:118: note: === get_loop_niters ===
pa1-p1.c:118: note: ==> get_loop_niters:4096
pa1-p1.c:118: note: === vect_analyze_data_refs ===

pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: analyze in outer-loop: yy
pa1-p1.c:118: note: 	outer base_address: &yy
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 128
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: analyze in outer-loop: *(&A + (long unsigned int) i_232 * 32768)
pa1-p1.c:118: note: 	outer base_address: &A
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 32768
	outer aligned to: 128
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: analyze in outer-loop: yy
pa1-p1.c:118: note: 	outer base_address: &yy
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 128
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:118: note: Analyze phi: .MEM_182 = PHI <.MEM_184(52), .MEM_191(43)>

pa1-p1.c:118: note: Analyze phi: i_232 = PHI <0(52), i_162(43)>

pa1-p1.c:118: note: Access function of PHI: {0, +, 1}_8
pa1-p1.c:118: note: step: 1,  init: 0
pa1-p1.c:118: note: Detected induction.
pa1-p1.c:118: note: Analyze phi: ivtmp_150 = PHI <4096(52), ivtmp_151(43)>

pa1-p1.c:118: note: Access function of PHI: {4096, +, 4294967295}_8
pa1-p1.c:118: note: step: 4294967295,  init: 4096
pa1-p1.c:118: note: Detected induction.
pa1-p1.c:118: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:118: note: Analyze phi: j_231 = PHI <j_161(39), 0(44)>

pa1-p1.c:118: note: Access function of PHI: {0, +, 1}_9
pa1-p1.c:118: note: step: 1,  init: 0
pa1-p1.c:118: note: Detected induction.
pa1-p1.c:118: note: Analyze phi: .MEM_236 = PHI <.MEM_191(39), .MEM_182(44)>

pa1-p1.c:118: note: Analyze phi: ivtmp_128 = PHI <ivtmp_129(39), 4096(44)>

pa1-p1.c:118: note: Access function of PHI: {4096, +, 4294967295}_9
pa1-p1.c:118: note: step: 4294967295,  init: 4096
pa1-p1.c:118: note: Detected induction.
pa1-p1.c:118: note: === vect_pattern_recog ===
pa1-p1.c:118: note: vect_is_simple_use: operand pretmp_316
pa1-p1.c:118: note: def_stmt: pretmp_316 = (long unsigned int) i_232;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand i_232
pa1-p1.c:118: note: def_stmt: i_232 = PHI <0(52), i_162(43)>

pa1-p1.c:118: note: type of def: 4.
pa1-p1.c:118: note: vect_is_simple_use: operand 8
pa1-p1.c:118: note: vect_is_simple_use: operand pretmp_316
pa1-p1.c:118: note: def_stmt: pretmp_316 = (long unsigned int) i_232;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand i_232
pa1-p1.c:118: note: def_stmt: i_232 = PHI <0(52), i_162(43)>

pa1-p1.c:118: note: type of def: 4.
pa1-p1.c:118: note: vect_is_simple_use: operand 32768
pa1-p1.c:118: note: vect_is_simple_use: operand _145
pa1-p1.c:118: note: def_stmt: _145 = (long unsigned int) j_231;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand j_231
pa1-p1.c:118: note: def_stmt: j_231 = PHI <j_161(39), 0(44)>

pa1-p1.c:118: note: type of def: 4.
pa1-p1.c:118: note: vect_is_simple_use: operand 8
pa1-p1.c:118: note: vect_is_simple_use: operand _158
pa1-p1.c:118: note: def_stmt: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: === vect_mark_stmts_to_be_vectorized ===
pa1-p1.c:118: note: init: phi relevant? .MEM_182 = PHI <.MEM_184(52), .MEM_191(43)>

pa1-p1.c:118: note: init: phi relevant? i_232 = PHI <0(52), i_162(43)>

pa1-p1.c:118: note: init: phi relevant? ivtmp_150 = PHI <4096(52), ivtmp_151(43)>

pa1-p1.c:118: note: init: stmt relevant? pretmp_316 = (long unsigned int) i_232;

pa1-p1.c:118: note: init: stmt relevant? pretmp_317 = pretmp_316 * 8;

pa1-p1.c:118: note: init: stmt relevant? pretmp_318 = &x + pretmp_317;

pa1-p1.c:118: note: init: stmt relevant? pretmp_319 = MEM[(double *)pretmp_318];

pa1-p1.c:118: note: init: stmt relevant? pretmp_320 = pretmp_316 * 32768;

pa1-p1.c:118: note: init: stmt relevant? pretmp_321 = &A + pretmp_320;

pa1-p1.c:118: note: init: phi relevant? j_231 = PHI <j_161(39), 0(44)>

pa1-p1.c:118: note: init: phi relevant? .MEM_236 = PHI <.MEM_191(39), .MEM_182(44)>

pa1-p1.c:118: note: init: phi relevant? ivtmp_128 = PHI <ivtmp_129(39), 4096(44)>

pa1-p1.c:118: note: init: stmt relevant? _145 = (long unsigned int) j_231;

pa1-p1.c:118: note: init: stmt relevant? _146 = _145 * 8;

pa1-p1.c:118: note: init: stmt relevant? _147 = &yy + _146;

pa1-p1.c:118: note: init: stmt relevant? _148 = *_147;

pa1-p1.c:118: note: init: stmt relevant? _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: init: stmt relevant? _159 = _158 * pretmp_319;

pa1-p1.c:118: note: init: stmt relevant? _160 = _148 + _159;

pa1-p1.c:118: note: init: stmt relevant? *_147 = _160;

pa1-p1.c:118: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: init: stmt relevant? j_161 = j_231 + 1;

pa1-p1.c:118: note: init: stmt relevant? ivtmp_129 = ivtmp_128 - 1;

pa1-p1.c:118: note: init: stmt relevant? if (ivtmp_129 != 0)

pa1-p1.c:118: note: init: stmt relevant? i_162 = i_232 + 1;

pa1-p1.c:118: note: init: stmt relevant? ivtmp_151 = ivtmp_150 - 1;

pa1-p1.c:118: note: init: stmt relevant? if (ivtmp_151 != 0)

pa1-p1.c:118: note: worklist: examine stmt: *_147 = _160;

pa1-p1.c:118: note: vect_is_simple_use: operand _160
pa1-p1.c:118: note: def_stmt: _160 = _148 + _159;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: worklist: examine stmt: _160 = _148 + _159;

pa1-p1.c:118: note: vect_is_simple_use: operand _148
pa1-p1.c:118: note: def_stmt: _148 = *_147;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: vect_is_simple_use: operand _159
pa1-p1.c:118: note: def_stmt: _159 = _158 * pretmp_319;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: worklist: examine stmt: _159 = _158 * pretmp_319;

pa1-p1.c:118: note: vect_is_simple_use: operand _158
pa1-p1.c:118: note: def_stmt: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: vect_is_simple_use: operand pretmp_319
pa1-p1.c:118: note: def_stmt: pretmp_319 = MEM[(double *)pretmp_318];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: outer-loop def-stmt defining inner-loop stmt.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: worklist: examine stmt: pretmp_319 = MEM[(double *)pretmp_318];

pa1-p1.c:118: note: worklist: examine stmt: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: worklist: examine stmt: _148 = *_147;

pa1-p1.c:118: note: === vect_analyze_dependences ===
pa1-p1.c:118: note: dependence distance  = 0.
pa1-p1.c:118: note: dependence distance == 0 between *_147 and *_147
pa1-p1.c:118: note: dependence distance  = 1.
pa1-p1.c:118: note: not vectorized, possible dependence between data-refs *_147 and *_147
pa1-p1.c:118: note: bad data dependence.
Analyzing loop at pa1-p1.c:118

pa1-p1.c:118: note: ===== analyze_loop_nest =====
pa1-p1.c:118: note: === vect_analyze_loop_form ===
pa1-p1.c:118: note: === get_loop_niters ===
pa1-p1.c:118: note: ==> get_loop_niters:4096
pa1-p1.c:118: note: === vect_analyze_data_refs ===

pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:118: note: Analyze phi: j_231 = PHI <j_161(39), 0(44)>

pa1-p1.c:118: note: Access function of PHI: {0, +, 1}_9
pa1-p1.c:118: note: step: 1,  init: 0
pa1-p1.c:118: note: Detected induction.
pa1-p1.c:118: note: Analyze phi: .MEM_236 = PHI <.MEM_191(39), .MEM_182(44)>

pa1-p1.c:118: note: Analyze phi: ivtmp_128 = PHI <ivtmp_129(39), 4096(44)>

pa1-p1.c:118: note: Access function of PHI: {4096, +, 4294967295}_9
pa1-p1.c:118: note: step: 4294967295,  init: 4096
pa1-p1.c:118: note: Detected induction.
pa1-p1.c:118: note: === vect_pattern_recog ===
pa1-p1.c:118: note: vect_is_simple_use: operand _145
pa1-p1.c:118: note: def_stmt: _145 = (long unsigned int) j_231;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand j_231
pa1-p1.c:118: note: def_stmt: j_231 = PHI <j_161(39), 0(44)>

pa1-p1.c:118: note: type of def: 4.
pa1-p1.c:118: note: vect_is_simple_use: operand 8
pa1-p1.c:118: note: vect_is_simple_use: operand _158
pa1-p1.c:118: note: def_stmt: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: === vect_mark_stmts_to_be_vectorized ===
pa1-p1.c:118: note: init: phi relevant? j_231 = PHI <j_161(39), 0(44)>

pa1-p1.c:118: note: init: phi relevant? .MEM_236 = PHI <.MEM_191(39), .MEM_182(44)>

pa1-p1.c:118: note: init: phi relevant? ivtmp_128 = PHI <ivtmp_129(39), 4096(44)>

pa1-p1.c:118: note: init: stmt relevant? _145 = (long unsigned int) j_231;

pa1-p1.c:118: note: init: stmt relevant? _146 = _145 * 8;

pa1-p1.c:118: note: init: stmt relevant? _147 = &yy + _146;

pa1-p1.c:118: note: init: stmt relevant? _148 = *_147;

pa1-p1.c:118: note: init: stmt relevant? _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: init: stmt relevant? _159 = _158 * pretmp_319;

pa1-p1.c:118: note: init: stmt relevant? _160 = _148 + _159;

pa1-p1.c:118: note: init: stmt relevant? *_147 = _160;

pa1-p1.c:118: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: init: stmt relevant? j_161 = j_231 + 1;

pa1-p1.c:118: note: init: stmt relevant? ivtmp_129 = ivtmp_128 - 1;

pa1-p1.c:118: note: init: stmt relevant? if (ivtmp_129 != 0)

pa1-p1.c:118: note: worklist: examine stmt: *_147 = _160;

pa1-p1.c:118: note: vect_is_simple_use: operand _160
pa1-p1.c:118: note: def_stmt: _160 = _148 + _159;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: worklist: examine stmt: _160 = _148 + _159;

pa1-p1.c:118: note: vect_is_simple_use: operand _148
pa1-p1.c:118: note: def_stmt: _148 = *_147;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: vect_is_simple_use: operand _159
pa1-p1.c:118: note: def_stmt: _159 = _158 * pretmp_319;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: worklist: examine stmt: _159 = _158 * pretmp_319;

pa1-p1.c:118: note: vect_is_simple_use: operand _158
pa1-p1.c:118: note: def_stmt: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: mark relevant 4, live 0.
pa1-p1.c:118: note: vect_is_simple_use: operand pretmp_319
pa1-p1.c:118: note: def_stmt: pretmp_319 = MEM[(double *)pretmp_318];

pa1-p1.c:118: note: type of def: 2.
pa1-p1.c:118: note: def_stmt is out of loop.
pa1-p1.c:118: note: worklist: examine stmt: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: worklist: examine stmt: _148 = *_147;

pa1-p1.c:118: note: === vect_analyze_dependences ===
pa1-p1.c:118: note: dependence distance  = 0.
pa1-p1.c:118: note: dependence distance == 0 between *_147 and *_147
pa1-p1.c:118: note: === vect_determine_vectorization_factor ===
pa1-p1.c:118: note: ==> examining phi: j_231 = PHI <j_161(39), 0(44)>

pa1-p1.c:118: note: ==> examining phi: .MEM_236 = PHI <.MEM_191(39), .MEM_182(44)>

pa1-p1.c:118: note: ==> examining phi: ivtmp_128 = PHI <ivtmp_129(39), 4096(44)>

pa1-p1.c:118: note: ==> examining statement: _145 = (long unsigned int) j_231;

pa1-p1.c:118: note: skip.
pa1-p1.c:118: note: ==> examining statement: _146 = _145 * 8;

pa1-p1.c:118: note: skip.
pa1-p1.c:118: note: ==> examining statement: _147 = &yy + _146;

pa1-p1.c:118: note: skip.
pa1-p1.c:118: note: ==> examining statement: _148 = *_147;

pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: nunits = 2
pa1-p1.c:118: note: ==> examining statement: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: nunits = 2
pa1-p1.c:118: note: ==> examining statement: _159 = _158 * pretmp_319;

pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: nunits = 2
pa1-p1.c:118: note: ==> examining statement: _160 = _148 + _159;

pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: nunits = 2
pa1-p1.c:118: note: ==> examining statement: *_147 = _160;

pa1-p1.c:118: note: get vectype for scalar type:  double
pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: nunits = 2
pa1-p1.c:118: note: ==> examining statement: j_161 = j_231 + 1;

pa1-p1.c:118: note: skip.
pa1-p1.c:118: note: ==> examining statement: ivtmp_129 = ivtmp_128 - 1;

pa1-p1.c:118: note: skip.
pa1-p1.c:118: note: ==> examining statement: if (ivtmp_129 != 0)

pa1-p1.c:118: note: skip.
pa1-p1.c:118: note: vectorization factor = 2
pa1-p1.c:118: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:118: note: dependence distance  = 0.
pa1-p1.c:118: note: accesses have the same alignment.dependence distance modulo vf == 0 between *_147 and *_147
pa1-p1.c:118: note: vect_compute_data_ref_alignment:
pa1-p1.c:118: note: misalign = 0 bytes of ref *_147
pa1-p1.c:118: note: vect_compute_data_ref_alignment:
pa1-p1.c:118: note: can't force alignment of ref: MEM[(double[0:D.4581] *)pretmp_321][j_231]
pa1-p1.c:118: note: vect_compute_data_ref_alignment:
pa1-p1.c:118: note: misalign = 0 bytes of ref *_147
pa1-p1.c:118: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:118: note: === vect_prune_runtime_alias_test_list ===
pa1-p1.c:118: note: === vect_enhance_data_refs_alignment ===
pa1-p1.c:118: note: Unknown misalignment, is_packed = 0
pa1-p1.c:118: note: vect_can_advance_ivs_p:
pa1-p1.c:118: note: Analyze phi: j_231 = PHI <j_161(39), 0(44)>

pa1-p1.c:118: note: Access function of PHI: {0, +, 1}_9
pa1-p1.c:118: note: Analyze phi: .MEM_236 = PHI <.MEM_191(39), .MEM_182(44)>

pa1-p1.c:118: note: virtual phi. skip.
pa1-p1.c:118: note: Analyze phi: ivtmp_128 = PHI <ivtmp_129(39), 4096(44)>

pa1-p1.c:118: note: Access function of PHI: {4096, +, 4294967295}_9
pa1-p1.c:118: note: vect_model_load_cost: aligned.
pa1-p1.c:118: note: vect_get_data_access_cost: inside_cost = 1, outside_cost = 0.
pa1-p1.c:118: note: Setting misalignment to -1.
pa1-p1.c:118: note: vect_model_load_cost: unaligned supported by hardware.
pa1-p1.c:118: note: vect_get_data_access_cost: inside_cost = 3, outside_cost = 0.
pa1-p1.c:118: note: vect_model_store_cost: aligned.
pa1-p1.c:118: note: vect_get_data_access_cost: inside_cost = 4, outside_cost = 0.
pa1-p1.c:118: note: Vectorizing an unaligned access.
pa1-p1.c:118: note: === vect_analyze_slp ===
pa1-p1.c:118: note: === vect_make_slp_decision ===
pa1-p1.c:118: note: === vect_detect_hybrid_slp ===
pa1-p1.c:118: note: === vect_analyze_loop_operations ===
pa1-p1.c:118: note: examining phi: j_231 = PHI <j_161(39), 0(44)>

pa1-p1.c:118: note: examining phi: .MEM_236 = PHI <.MEM_191(39), .MEM_182(44)>

pa1-p1.c:118: note: examining phi: ivtmp_128 = PHI <ivtmp_129(39), 4096(44)>

pa1-p1.c:118: note: ==> examining statement: _145 = (long unsigned int) j_231;

pa1-p1.c:118: note: irrelevant.
pa1-p1.c:118: note: ==> examining statement: _146 = _145 * 8;

pa1-p1.c:118: note: irrelevant.
pa1-p1.c:118: note: ==> examining statement: _147 = &yy + _146;

pa1-p1.c:118: note: irrelevant.
pa1-p1.c:118: note: ==> examining statement: _148 = *_147;

pa1-p1.c:118: note: vect_is_simple_use: operand *_147
pa1-p1.c:118: note: not ssa-name.
pa1-p1.c:118: note: use not simple.
pa1-p1.c:118: note: vect_is_simple_use: operand *_147
pa1-p1.c:118: note: not ssa-name.
pa1-p1.c:118: note: use not simple.
pa1-p1.c:118: note: vect_model_load_cost: aligned.
pa1-p1.c:118: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
pa1-p1.c:118: note: ==> examining statement: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: num. args = 4 (not unary/binary/ternary op).
pa1-p1.c:118: note: vect_is_simple_use: operand MEM[(double[0:D.4581] *)pretmp_321][j_231]
pa1-p1.c:118: note: not ssa-name.
pa1-p1.c:118: note: use not simple.
pa1-p1.c:118: note: vect_model_load_cost: unaligned supported by hardware.
pa1-p1.c:118: note: vect_model_load_cost: inside_cost = 2, prologue_cost = 0 .
pa1-p1.c:118: note: ==> examining statement: _159 = _158 * pretmp_319;

pa1-p1.c:118: note: vect_is_simple_use: operand _158
pa1-p1.c:118: note: def_stmt: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand pretmp_319
pa1-p1.c:118: note: def_stmt: pretmp_319 = MEM[(double *)pretmp_318];

pa1-p1.c:118: note: type of def: 2.
pa1-p1.c:118: note: === vectorizable_operation ===
pa1-p1.c:118: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa1-p1.c:118: note: ==> examining statement: _160 = _148 + _159;

pa1-p1.c:118: note: vect_is_simple_use: operand _148
pa1-p1.c:118: note: def_stmt: _148 = *_147;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand _159
pa1-p1.c:118: note: def_stmt: _159 = _158 * pretmp_319;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: === vectorizable_operation ===
pa1-p1.c:118: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa1-p1.c:118: note: ==> examining statement: *_147 = _160;

pa1-p1.c:118: note: vect_is_simple_use: operand _160
pa1-p1.c:118: note: def_stmt: _160 = _148 + _159;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_model_store_cost: aligned.
pa1-p1.c:118: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa1-p1.c:118: note: ==> examining statement: j_161 = j_231 + 1;

pa1-p1.c:118: note: irrelevant.
pa1-p1.c:118: note: ==> examining statement: ivtmp_129 = ivtmp_128 - 1;

pa1-p1.c:118: note: irrelevant.
pa1-p1.c:118: note: ==> examining statement: if (ivtmp_129 != 0)

pa1-p1.c:118: note: irrelevant.
pa1-p1.c:118: note: vectorization_factor = 2, niters = 4096
pa1-p1.c:118: note: === vect_update_slp_costs_according_to_vf ===
pa1-p1.c:118: note: Cost model analysis: 
  Vector inside of loop cost: 6
  Vector prologue cost: 1
  Vector epilogue cost: 0
  Scalar iteration cost: 5
  Scalar outside cost: 0
  Vector outside cost: 1
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1

pa1-p1.c:118: note:   Runtime profitability threshold = 1

pa1-p1.c:118: note:   Static estimate profitability threshold = 1


Vectorizing loop at pa1-p1.c:118

pa1-p1.c:118: note: === vec_transform_loop ===
pa1-p1.c:118: note: ------>vectorizing phi: j_231 = PHI <j_161(39), 0(58)>

pa1-p1.c:118: note: ------>vectorizing phi: .MEM_236 = PHI <.MEM_191(39), .MEM_182(58)>

pa1-p1.c:118: note: ------>vectorizing phi: ivtmp_128 = PHI <ivtmp_129(39), 4096(58)>

pa1-p1.c:118: note: ------>vectorizing statement: _145 = (long unsigned int) j_231;

pa1-p1.c:118: note: ------>vectorizing statement: _146 = _145 * 8;

pa1-p1.c:118: note: ------>vectorizing statement: _147 = &yy + _146;

pa1-p1.c:118: note: ------>vectorizing statement: _148 = *_147;

pa1-p1.c:118: note: transform statement.
pa1-p1.c:118: note: transform load. ncopies = 1
pa1-p1.c:118: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(double *)&yy]
pa1-p1.c:118: note: created vect_pyy.130_325
pa1-p1.c:118: note: add new stmt: vect_var_.131_304 = MEM[(double *)vect_pyy.127_324];

pa1-p1.c:118: note: ------>vectorizing statement: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: transform statement.
pa1-p1.c:118: note: transform load. ncopies = 1
pa1-p1.c:118: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: MEM[(double[0:D.4581] *)pretmp_321]
pa1-p1.c:118: note: created vect_p.135_300
pa1-p1.c:118: note: add new stmt: vect_var_.136_277 = MEM[(double[0:D.4581] *)vect_p.132_299];

pa1-p1.c:118: note: ------>vectorizing statement: _159 = _158 * pretmp_319;

pa1-p1.c:118: note: transform statement.
pa1-p1.c:118: note: vect_is_simple_use: operand _158
pa1-p1.c:118: note: def_stmt: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand pretmp_319
pa1-p1.c:118: note: def_stmt: pretmp_319 = MEM[(double *)pretmp_318];

pa1-p1.c:118: note: type of def: 2.
pa1-p1.c:118: note: transform binary/unary operation.
pa1-p1.c:118: note: vect_get_vec_def_for_operand: _158
pa1-p1.c:118: note: vect_is_simple_use: operand _158
pa1-p1.c:118: note: def_stmt: _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: def =  _158  def_stmt =  _158 = MEM[(double[0:D.4581] *)pretmp_321][j_231];

pa1-p1.c:118: note: vect_get_vec_def_for_operand: pretmp_319
pa1-p1.c:118: note: vect_is_simple_use: operand pretmp_319
pa1-p1.c:118: note: def_stmt: pretmp_319 = MEM[(double *)pretmp_318];

pa1-p1.c:118: note: type of def: 2.
pa1-p1.c:118: note: def =  pretmp_319  def_stmt =  pretmp_319 = MEM[(double *)pretmp_318];

pa1-p1.c:118: note: get vectype with 2 units of type double
pa1-p1.c:118: note: vectype: vector(2) double
pa1-p1.c:118: note: Create vector_inv.
pa1-p1.c:118: note: created new init_stmt: vect_cst_.138_276 = {pretmp_319, pretmp_319};

pa1-p1.c:118: note: add new stmt: vect_var_.137_268 = vect_var_.136_277 * vect_cst_.138_276;

pa1-p1.c:118: note: ------>vectorizing statement: _160 = _148 + _159;

pa1-p1.c:118: note: transform statement.
pa1-p1.c:118: note: vect_is_simple_use: operand _148
pa1-p1.c:118: note: def_stmt: _148 = *_147;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: vect_is_simple_use: operand _159
pa1-p1.c:118: note: def_stmt: _159 = _158 * pretmp_319;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: transform binary/unary operation.
pa1-p1.c:118: note: vect_get_vec_def_for_operand: _148
pa1-p1.c:118: note: vect_is_simple_use: operand _148
pa1-p1.c:118: note: def_stmt: _148 = *_147;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: def =  _148  def_stmt =  _148 = *_147;

pa1-p1.c:118: note: vect_get_vec_def_for_operand: _159
pa1-p1.c:118: note: vect_is_simple_use: operand _159
pa1-p1.c:118: note: def_stmt: _159 = _158 * pretmp_319;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: def =  _159  def_stmt =  _159 = _158 * pretmp_319;

pa1-p1.c:118: note: add new stmt: vect_var_.139_267 = vect_var_.131_304 + vect_var_.137_268;

pa1-p1.c:118: note: ------>vectorizing statement: *_147 = _160;

pa1-p1.c:118: note: transform statement.
pa1-p1.c:118: note: vect_is_simple_use: operand _160
pa1-p1.c:118: note: def_stmt: _160 = _148 + _159;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: transform store. ncopies = 1
pa1-p1.c:118: note: vect_get_vec_def_for_operand: _160
pa1-p1.c:118: note: vect_is_simple_use: operand _160
pa1-p1.c:118: note: def_stmt: _160 = _148 + _159;

pa1-p1.c:118: note: type of def: 3.
pa1-p1.c:118: note: def =  _160  def_stmt =  _160 = _148 + _159;

pa1-p1.c:118: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(double *)&yy]
pa1-p1.c:118: note: created vect_pyy.143_266
pa1-p1.c:118: note: add new stmt: MEM[(double *)vect_pyy.140_265] = vect_var_.139_267;

pa1-p1.c:118: note: ------>vectorizing statement: j_161 = j_231 + 1;

pa1-p1.c:118: note: ------>vectorizing statement: ivtmp_129 = ivtmp_128 - 1;

pa1-p1.c:118: note: ------>vectorizing statement: vect_pyy.127_323 = vect_pyy.127_324 + 16;

pa1-p1.c:118: note: ------>vectorizing statement: vect_p.132_278 = vect_p.132_299 + 16;

pa1-p1.c:118: note: ------>vectorizing statement: vect_pyy.140_264 = vect_pyy.140_265 + 16;

pa1-p1.c:118: note: ------>vectorizing statement: if (ivtmp_129 != 0)

loop at pa1-p1.c:119: if (ivtmp_262 < 2048)

pa1-p1.c:118: note: LOOP VECTORIZED.
Analyzing loop at pa1-p1.c:72

pa1-p1.c:72: note: ===== analyze_loop_nest =====
pa1-p1.c:72: note: === vect_analyze_loop_form ===
pa1-p1.c:72: note: === get_loop_niters ===
pa1-p1.c:72: note: ==> get_loop_niters:4096
pa1-p1.c:72: note: === vect_analyze_data_refs ===

pa1-p1.c:72: note: get vectype with 2 units of type double
pa1-p1.c:72: note: vectype: vector(2) double
pa1-p1.c:72: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:72: note: Analyze phi: i_222 = PHI <i_85(35), 0(33)>

pa1-p1.c:72: note: Access function of PHI: {0, +, 1}_6
pa1-p1.c:72: note: step: 1,  init: 0
pa1-p1.c:72: note: Detected induction.
pa1-p1.c:72: note: Analyze phi: .MEM_83 = PHI <.MEM_84(35), .MEM_228(33)>

pa1-p1.c:72: note: Analyze phi: ivtmp_156 = PHI <ivtmp_157(35), 4096(33)>

pa1-p1.c:72: note: Access function of PHI: {4096, +, 4294967295}_6
pa1-p1.c:72: note: step: 4294967295,  init: 4096
pa1-p1.c:72: note: Detected induction.
pa1-p1.c:72: note: === vect_pattern_recog ===
pa1-p1.c:72: note: === vect_mark_stmts_to_be_vectorized ===
pa1-p1.c:72: note: init: phi relevant? i_222 = PHI <i_85(35), 0(33)>

pa1-p1.c:72: note: init: phi relevant? .MEM_83 = PHI <.MEM_84(35), .MEM_228(33)>

pa1-p1.c:72: note: init: phi relevant? ivtmp_156 = PHI <ivtmp_157(35), 4096(33)>

pa1-p1.c:72: note: init: stmt relevant? zz[i_222] = 1.0e+0;

pa1-p1.c:72: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:72: note: mark relevant 4, live 0.
pa1-p1.c:72: note: init: stmt relevant? i_85 = i_222 + 1;

pa1-p1.c:72: note: init: stmt relevant? ivtmp_157 = ivtmp_156 - 1;

pa1-p1.c:72: note: init: stmt relevant? if (ivtmp_157 != 0)

pa1-p1.c:72: note: worklist: examine stmt: zz[i_222] = 1.0e+0;

pa1-p1.c:72: note: === vect_analyze_dependences ===
pa1-p1.c:72: note: === vect_determine_vectorization_factor ===
pa1-p1.c:72: note: ==> examining phi: i_222 = PHI <i_85(35), 0(33)>

pa1-p1.c:72: note: ==> examining phi: .MEM_83 = PHI <.MEM_84(35), .MEM_228(33)>

pa1-p1.c:72: note: ==> examining phi: ivtmp_156 = PHI <ivtmp_157(35), 4096(33)>

pa1-p1.c:72: note: ==> examining statement: zz[i_222] = 1.0e+0;

pa1-p1.c:72: note: get vectype for scalar type:  double
pa1-p1.c:72: note: get vectype with 2 units of type double
pa1-p1.c:72: note: vectype: vector(2) double
pa1-p1.c:72: note: vectype: vector(2) double
pa1-p1.c:72: note: nunits = 2
pa1-p1.c:72: note: ==> examining statement: i_85 = i_222 + 1;

pa1-p1.c:72: note: skip.
pa1-p1.c:72: note: ==> examining statement: ivtmp_157 = ivtmp_156 - 1;

pa1-p1.c:72: note: skip.
pa1-p1.c:72: note: ==> examining statement: if (ivtmp_157 != 0)

pa1-p1.c:72: note: skip.
pa1-p1.c:72: note: vectorization factor = 2
pa1-p1.c:72: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:72: note: vect_compute_data_ref_alignment:
pa1-p1.c:72: note: misalign = 0 bytes of ref zz[i_222]
pa1-p1.c:72: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:72: note: === vect_prune_runtime_alias_test_list ===
pa1-p1.c:72: note: === vect_enhance_data_refs_alignment ===
pa1-p1.c:72: note: vect_can_advance_ivs_p:
pa1-p1.c:72: note: Analyze phi: i_222 = PHI <i_85(35), 0(33)>

pa1-p1.c:72: note: Access function of PHI: {0, +, 1}_6
pa1-p1.c:72: note: Analyze phi: .MEM_83 = PHI <.MEM_84(35), .MEM_228(33)>

pa1-p1.c:72: note: virtual phi. skip.
pa1-p1.c:72: note: Analyze phi: ivtmp_156 = PHI <ivtmp_157(35), 4096(33)>

pa1-p1.c:72: note: Access function of PHI: {4096, +, 4294967295}_6
pa1-p1.c:72: note: vect_model_store_cost: aligned.
pa1-p1.c:72: note: vect_get_data_access_cost: inside_cost = 1, outside_cost = 0.
pa1-p1.c:72: note: === vect_analyze_slp ===
pa1-p1.c:72: note: === vect_make_slp_decision ===
pa1-p1.c:72: note: === vect_detect_hybrid_slp ===
pa1-p1.c:72: note: === vect_analyze_loop_operations ===
pa1-p1.c:72: note: examining phi: i_222 = PHI <i_85(35), 0(33)>

pa1-p1.c:72: note: examining phi: .MEM_83 = PHI <.MEM_84(35), .MEM_228(33)>

pa1-p1.c:72: note: examining phi: ivtmp_156 = PHI <ivtmp_157(35), 4096(33)>

pa1-p1.c:72: note: ==> examining statement: zz[i_222] = 1.0e+0;

pa1-p1.c:72: note: vect_is_simple_use: operand 1.0e+0
pa1-p1.c:72: note: vect_model_store_cost: aligned.
pa1-p1.c:72: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 1 .
pa1-p1.c:72: note: ==> examining statement: i_85 = i_222 + 1;

pa1-p1.c:72: note: irrelevant.
pa1-p1.c:72: note: ==> examining statement: ivtmp_157 = ivtmp_156 - 1;

pa1-p1.c:72: note: irrelevant.
pa1-p1.c:72: note: ==> examining statement: if (ivtmp_157 != 0)

pa1-p1.c:72: note: irrelevant.
pa1-p1.c:72: note: vectorization_factor = 2, niters = 4096
pa1-p1.c:72: note: === vect_update_slp_costs_according_to_vf ===
pa1-p1.c:72: note: Cost model analysis: 
  Vector inside of loop cost: 1
  Vector prologue cost: 1
  Vector epilogue cost: 0
  Scalar iteration cost: 1
  Scalar outside cost: 0
  Vector outside cost: 1
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 3

pa1-p1.c:72: note:   Runtime profitability threshold = 2

pa1-p1.c:72: note:   Static estimate profitability threshold = 2


Vectorizing loop at pa1-p1.c:72

pa1-p1.c:72: note: === vec_transform_loop ===
pa1-p1.c:72: note: ------>vectorizing phi: i_222 = PHI <i_85(35), 0(59)>

pa1-p1.c:72: note: ------>vectorizing phi: .MEM_83 = PHI <.MEM_84(35), .MEM_228(59)>

pa1-p1.c:72: note: ------>vectorizing phi: ivtmp_156 = PHI <ivtmp_157(35), 4096(59)>

pa1-p1.c:72: note: ------>vectorizing statement: zz[i_222] = 1.0e+0;

pa1-p1.c:72: note: transform statement.
pa1-p1.c:72: note: vect_is_simple_use: operand 1.0e+0
pa1-p1.c:72: note: transform store. ncopies = 1
pa1-p1.c:72: note: vect_get_vec_def_for_operand: 1.0e+0
pa1-p1.c:72: note: vect_is_simple_use: operand 1.0e+0
pa1-p1.c:72: note: get vectype with 2 units of type double
pa1-p1.c:72: note: vectype: vector(2) double
pa1-p1.c:72: note: Create vector_cst. nunits = 2
pa1-p1.c:72: note: created new init_stmt: vect_cst_.144_261 = { 1.0e+0, 1.0e+0 };

pa1-p1.c:72: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: zz
pa1-p1.c:72: note: created vect_pzz.148_260
pa1-p1.c:72: note: add new stmt: MEM[(double[4096] *)vect_pzz.145_259] = vect_cst_.144_261;

pa1-p1.c:72: note: ------>vectorizing statement: i_85 = i_222 + 1;

pa1-p1.c:72: note: ------>vectorizing statement: ivtmp_157 = ivtmp_156 - 1;

pa1-p1.c:72: note: ------>vectorizing statement: vect_pzz.145_258 = vect_pzz.145_259 + 16;

pa1-p1.c:72: note: ------>vectorizing statement: if (ivtmp_157 != 0)

loop at pa1-p1.c:74: if (ivtmp_256 < 2048)

pa1-p1.c:72: note: LOOP VECTORIZED.
Analyzing loop at pa1-p1.c:61

pa1-p1.c:61: note: ===== analyze_loop_nest =====
pa1-p1.c:61: note: === vect_analyze_loop_form ===
pa1-p1.c:61: note: not vectorized: multiple nested loops.
pa1-p1.c:61: note: bad loop form.
Analyzing loop at pa1-p1.c:98

pa1-p1.c:98: note: ===== analyze_loop_nest =====
pa1-p1.c:98: note: === vect_analyze_loop_form ===
pa1-p1.c:98: note: ===== analyze_loop_nest_1 =====
pa1-p1.c:98: note: === vect_analyze_loop_form ===
pa1-p1.c:98: note: === get_loop_niters ===
pa1-p1.c:98: note: ==> get_loop_niters:4096
pa1-p1.c:98: note: Considering outer-loop vectorization.
pa1-p1.c:98: note: === get_loop_niters ===
pa1-p1.c:98: note: ==> get_loop_niters:4096
pa1-p1.c:98: note: === vect_analyze_data_refs ===

pa1-p1.c:98: note: get vectype with 2 units of type double
pa1-p1.c:98: note: vectype: vector(2) double
pa1-p1.c:98: note: analyze in outer-loop: y
pa1-p1.c:98: note: 	outer base_address: &y
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 128
pa1-p1.c:98: note: get vectype with 2 units of type double
pa1-p1.c:98: note: vectype: vector(2) double
pa1-p1.c:98: note: analyze in outer-loop: *(&A + (long unsigned int) i_230 * 32768)
pa1-p1.c:98: note: 	outer base_address: &A
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 32768
	outer aligned to: 128
pa1-p1.c:98: note: get vectype with 2 units of type double
pa1-p1.c:98: note: vectype: vector(2) double
pa1-p1.c:98: note: analyze in outer-loop: y
pa1-p1.c:98: note: 	outer base_address: &y
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 128
pa1-p1.c:98: note: get vectype with 2 units of type double
pa1-p1.c:98: note: vectype: vector(2) double
pa1-p1.c:98: note: analyze in outer-loop: z
pa1-p1.c:98: note: 	outer base_address: &z
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 128
pa1-p1.c:98: note: get vectype with 2 units of type double
pa1-p1.c:98: note: vectype: vector(2) double
pa1-p1.c:98: note: analyze in outer-loop: A
pa1-p1.c:98: note: 	outer base_address: &A
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 8
	outer aligned to: 128
pa1-p1.c:98: note: get vectype with 2 units of type double
pa1-p1.c:98: note: vectype: vector(2) double
pa1-p1.c:98: note: analyze in outer-loop: z
pa1-p1.c:98: note: 	outer base_address: &z
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 0
	outer aligned to: 128
pa1-p1.c:98: note: get vectype with 2 units of type double
pa1-p1.c:98: note: vectype: vector(2) double
pa1-p1.c:98: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:98: note: Analyze phi: .MEM_122 = PHI <.MEM_197(28), .MEM_194(24)>

pa1-p1.c:98: note: Analyze phi: i_230 = PHI <0(28), i_142(24)>

pa1-p1.c:98: note: Access function of PHI: {0, +, 1}_4
pa1-p1.c:98: note: step: 1,  init: 0
pa1-p1.c:98: note: Detected induction.
pa1-p1.c:98: note: Analyze phi: ivtmp_165 = PHI <4096(28), ivtmp_167(24)>

pa1-p1.c:98: note: Access function of PHI: {4096, +, 4294967295}_4
pa1-p1.c:98: note: step: 4294967295,  init: 4096
pa1-p1.c:98: note: Detected induction.
pa1-p1.c:98: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:98: note: Analyze phi: j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:98: note: Access function of PHI: {0, +, 1}_5
pa1-p1.c:98: note: step: 1,  init: 0
pa1-p1.c:98: note: Detected induction.
pa1-p1.c:98: note: Analyze phi: .MEM_235 = PHI <.MEM_194(21), .MEM_122(25)>

pa1-p1.c:98: note: Analyze phi: ivtmp_166 = PHI <ivtmp_164(21), 4096(25)>

pa1-p1.c:98: note: Access function of PHI: {4096, +, 4294967295}_5
pa1-p1.c:98: note: step: 4294967295,  init: 4096
pa1-p1.c:98: note: Detected induction.
pa1-p1.c:98: note: === vect_pattern_recog ===
pa1-p1.c:98: note: vect_is_simple_use: operand pretmp_289
pa1-p1.c:98: note: def_stmt: pretmp_289 = (long unsigned int) i_230;

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: vect_is_simple_use: operand i_230
pa1-p1.c:98: note: def_stmt: i_230 = PHI <0(28), i_142(24)>

pa1-p1.c:98: note: type of def: 4.
pa1-p1.c:98: note: vect_is_simple_use: operand 32768
pa1-p1.c:98: note: vect_is_simple_use: operand pretmp_289
pa1-p1.c:98: note: def_stmt: pretmp_289 = (long unsigned int) i_230;

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: vect_is_simple_use: operand i_230
pa1-p1.c:98: note: def_stmt: i_230 = PHI <0(28), i_142(24)>

pa1-p1.c:98: note: type of def: 4.
pa1-p1.c:98: note: vect_is_simple_use: operand 8
pa1-p1.c:98: note: vect_is_simple_use: operand _116
pa1-p1.c:98: note: def_stmt: _116 = (long unsigned int) j_229;

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: vect_is_simple_use: operand j_229
pa1-p1.c:98: note: def_stmt: j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:98: note: type of def: 4.
pa1-p1.c:98: note: vect_is_simple_use: operand 8
pa1-p1.c:98: note: vect_is_simple_use: operand _126
pa1-p1.c:98: note: def_stmt: _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: vect_is_simple_use: operand _116
pa1-p1.c:98: note: def_stmt: _116 = (long unsigned int) j_229;

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: vect_is_simple_use: operand j_229
pa1-p1.c:98: note: def_stmt: j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:98: note: type of def: 4.
pa1-p1.c:98: note: vect_is_simple_use: operand 32768
pa1-p1.c:98: note: vect_is_simple_use: operand _137
pa1-p1.c:98: note: def_stmt: _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: === vect_mark_stmts_to_be_vectorized ===
pa1-p1.c:98: note: init: phi relevant? .MEM_122 = PHI <.MEM_197(28), .MEM_194(24)>

pa1-p1.c:98: note: init: phi relevant? i_230 = PHI <0(28), i_142(24)>

pa1-p1.c:98: note: init: phi relevant? ivtmp_165 = PHI <4096(28), ivtmp_167(24)>

pa1-p1.c:98: note: init: stmt relevant? pretmp_289 = (long unsigned int) i_230;

pa1-p1.c:98: note: init: stmt relevant? pretmp_290 = pretmp_289 * 32768;

pa1-p1.c:98: note: init: stmt relevant? pretmp_291 = &A + pretmp_290;

pa1-p1.c:98: note: init: stmt relevant? pretmp_292 = pretmp_289 * 8;

pa1-p1.c:98: note: init: stmt relevant? pretmp_293 = &x + pretmp_292;

pa1-p1.c:98: note: init: stmt relevant? pretmp_294 = MEM[(double *)pretmp_293];

pa1-p1.c:98: note: init: phi relevant? j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:98: note: init: phi relevant? .MEM_235 = PHI <.MEM_194(21), .MEM_122(25)>

pa1-p1.c:98: note: init: phi relevant? ivtmp_166 = PHI <ivtmp_164(21), 4096(25)>

pa1-p1.c:98: note: init: stmt relevant? _116 = (long unsigned int) j_229;

pa1-p1.c:98: note: init: stmt relevant? _117 = _116 * 8;

pa1-p1.c:98: note: init: stmt relevant? _118 = &y + _117;

pa1-p1.c:98: note: init: stmt relevant? _119 = *_118;

pa1-p1.c:98: note: init: stmt relevant? _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:98: note: init: stmt relevant? _130 = _126 * pretmp_294;

pa1-p1.c:98: note: init: stmt relevant? _131 = _119 + _130;

pa1-p1.c:98: note: init: stmt relevant? *_118 = _131;

pa1-p1.c:98: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: init: stmt relevant? _132 = &z + _117;

pa1-p1.c:98: note: init: stmt relevant? _133 = *_132;

pa1-p1.c:98: note: init: stmt relevant? _135 = _116 * 32768;

pa1-p1.c:98: note: init: stmt relevant? _136 = &A + _135;

pa1-p1.c:98: note: init: stmt relevant? _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:98: note: init: stmt relevant? _139 = _137 * pretmp_294;

pa1-p1.c:98: note: init: stmt relevant? _140 = _133 + _139;

pa1-p1.c:98: note: init: stmt relevant? *_132 = _140;

pa1-p1.c:98: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: init: stmt relevant? j_141 = j_229 + 1;

pa1-p1.c:98: note: init: stmt relevant? ivtmp_164 = ivtmp_166 - 1;

pa1-p1.c:98: note: init: stmt relevant? if (ivtmp_164 != 0)

pa1-p1.c:98: note: init: stmt relevant? i_142 = i_230 + 1;

pa1-p1.c:98: note: init: stmt relevant? ivtmp_167 = ivtmp_165 - 1;

pa1-p1.c:98: note: init: stmt relevant? if (ivtmp_167 != 0)

pa1-p1.c:98: note: worklist: examine stmt: *_132 = _140;

pa1-p1.c:98: note: vect_is_simple_use: operand _140
pa1-p1.c:98: note: def_stmt: _140 = _133 + _139;

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: worklist: examine stmt: _140 = _133 + _139;

pa1-p1.c:98: note: vect_is_simple_use: operand _133
pa1-p1.c:98: note: def_stmt: _133 = *_132;

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: vect_is_simple_use: operand _139
pa1-p1.c:98: note: def_stmt: _139 = _137 * pretmp_294;

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: worklist: examine stmt: _139 = _137 * pretmp_294;

pa1-p1.c:98: note: vect_is_simple_use: operand _137
pa1-p1.c:98: note: def_stmt: _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: vect_is_simple_use: operand pretmp_294
pa1-p1.c:98: note: def_stmt: pretmp_294 = MEM[(double *)pretmp_293];

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: outer-loop def-stmt defining inner-loop stmt.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: worklist: examine stmt: pretmp_294 = MEM[(double *)pretmp_293];

pa1-p1.c:98: note: worklist: examine stmt: _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:98: note: worklist: examine stmt: _133 = *_132;

pa1-p1.c:98: note: worklist: examine stmt: *_118 = _131;

pa1-p1.c:98: note: vect_is_simple_use: operand _131
pa1-p1.c:98: note: def_stmt: _131 = _119 + _130;

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: worklist: examine stmt: _131 = _119 + _130;

pa1-p1.c:98: note: vect_is_simple_use: operand _119
pa1-p1.c:98: note: def_stmt: _119 = *_118;

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: vect_is_simple_use: operand _130
pa1-p1.c:98: note: def_stmt: _130 = _126 * pretmp_294;

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: worklist: examine stmt: _130 = _126 * pretmp_294;

pa1-p1.c:98: note: vect_is_simple_use: operand _126
pa1-p1.c:98: note: def_stmt: _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: vect_is_simple_use: operand pretmp_294
pa1-p1.c:98: note: def_stmt: pretmp_294 = MEM[(double *)pretmp_293];

pa1-p1.c:98: note: type of def: 3.
pa1-p1.c:98: note: outer-loop def-stmt defining inner-loop stmt.
pa1-p1.c:98: note: mark relevant 4, live 0.
pa1-p1.c:98: note: already marked relevant/live.
pa1-p1.c:98: note: worklist: examine stmt: _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:98: note: worklist: examine stmt: _119 = *_118;

pa1-p1.c:98: note: === vect_analyze_dependences ===
pa1-p1.c:98: note: dependence distance  = 0.
pa1-p1.c:98: note: dependence distance == 0 between *_118 and *_118
pa1-p1.c:98: note: dependence distance  = 1.
pa1-p1.c:98: note: not vectorized, possible dependence between data-refs *_118 and *_118
pa1-p1.c:98: note: bad data dependence.
Analyzing loop at pa1-p1.c:99

pa1-p1.c:99: note: ===== analyze_loop_nest =====
pa1-p1.c:99: note: === vect_analyze_loop_form ===
pa1-p1.c:99: note: === get_loop_niters ===
pa1-p1.c:99: note: ==> get_loop_niters:4096
pa1-p1.c:99: note: === vect_analyze_data_refs ===

pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:99: note: Analyze phi: j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:99: note: Access function of PHI: {0, +, 1}_5
pa1-p1.c:99: note: step: 1,  init: 0
pa1-p1.c:99: note: Detected induction.
pa1-p1.c:99: note: Analyze phi: .MEM_235 = PHI <.MEM_194(21), .MEM_122(25)>

pa1-p1.c:99: note: Analyze phi: ivtmp_166 = PHI <ivtmp_164(21), 4096(25)>

pa1-p1.c:99: note: Access function of PHI: {4096, +, 4294967295}_5
pa1-p1.c:99: note: step: 4294967295,  init: 4096
pa1-p1.c:99: note: Detected induction.
pa1-p1.c:99: note: === vect_pattern_recog ===
pa1-p1.c:99: note: vect_is_simple_use: operand _116
pa1-p1.c:99: note: def_stmt: _116 = (long unsigned int) j_229;

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: vect_is_simple_use: operand j_229
pa1-p1.c:99: note: def_stmt: j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:99: note: type of def: 4.
pa1-p1.c:99: note: vect_is_simple_use: operand 8
pa1-p1.c:99: note: vect_is_simple_use: operand _126
pa1-p1.c:99: note: def_stmt: _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: vect_is_simple_use: operand _116
pa1-p1.c:99: note: def_stmt: _116 = (long unsigned int) j_229;

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: vect_is_simple_use: operand j_229
pa1-p1.c:99: note: def_stmt: j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:99: note: type of def: 4.
pa1-p1.c:99: note: vect_is_simple_use: operand 32768
pa1-p1.c:99: note: vect_is_simple_use: operand _137
pa1-p1.c:99: note: def_stmt: _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: === vect_mark_stmts_to_be_vectorized ===
pa1-p1.c:99: note: init: phi relevant? j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:99: note: init: phi relevant? .MEM_235 = PHI <.MEM_194(21), .MEM_122(25)>

pa1-p1.c:99: note: init: phi relevant? ivtmp_166 = PHI <ivtmp_164(21), 4096(25)>

pa1-p1.c:99: note: init: stmt relevant? _116 = (long unsigned int) j_229;

pa1-p1.c:99: note: init: stmt relevant? _117 = _116 * 8;

pa1-p1.c:99: note: init: stmt relevant? _118 = &y + _117;

pa1-p1.c:99: note: init: stmt relevant? _119 = *_118;

pa1-p1.c:99: note: init: stmt relevant? _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:99: note: init: stmt relevant? _130 = _126 * pretmp_294;

pa1-p1.c:99: note: init: stmt relevant? _131 = _119 + _130;

pa1-p1.c:99: note: init: stmt relevant? *_118 = _131;

pa1-p1.c:99: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:99: note: mark relevant 4, live 0.
pa1-p1.c:99: note: init: stmt relevant? _132 = &z + _117;

pa1-p1.c:99: note: init: stmt relevant? _133 = *_132;

pa1-p1.c:99: note: init: stmt relevant? _135 = _116 * 32768;

pa1-p1.c:99: note: init: stmt relevant? _136 = &A + _135;

pa1-p1.c:99: note: init: stmt relevant? _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:99: note: init: stmt relevant? _139 = _137 * pretmp_294;

pa1-p1.c:99: note: init: stmt relevant? _140 = _133 + _139;

pa1-p1.c:99: note: init: stmt relevant? *_132 = _140;

pa1-p1.c:99: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:99: note: mark relevant 4, live 0.
pa1-p1.c:99: note: init: stmt relevant? j_141 = j_229 + 1;

pa1-p1.c:99: note: init: stmt relevant? ivtmp_164 = ivtmp_166 - 1;

pa1-p1.c:99: note: init: stmt relevant? if (ivtmp_164 != 0)

pa1-p1.c:99: note: worklist: examine stmt: *_132 = _140;

pa1-p1.c:99: note: vect_is_simple_use: operand _140
pa1-p1.c:99: note: def_stmt: _140 = _133 + _139;

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: mark relevant 4, live 0.
pa1-p1.c:99: note: worklist: examine stmt: _140 = _133 + _139;

pa1-p1.c:99: note: vect_is_simple_use: operand _133
pa1-p1.c:99: note: def_stmt: _133 = *_132;

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: mark relevant 4, live 0.
pa1-p1.c:99: note: vect_is_simple_use: operand _139
pa1-p1.c:99: note: def_stmt: _139 = _137 * pretmp_294;

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: mark relevant 4, live 0.
pa1-p1.c:99: note: worklist: examine stmt: _139 = _137 * pretmp_294;

pa1-p1.c:99: note: vect_is_simple_use: operand _137
pa1-p1.c:99: note: def_stmt: _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: mark relevant 4, live 0.
pa1-p1.c:99: note: vect_is_simple_use: operand pretmp_294
pa1-p1.c:99: note: def_stmt: pretmp_294 = MEM[(double *)pretmp_293];

pa1-p1.c:99: note: type of def: 2.
pa1-p1.c:99: note: def_stmt is out of loop.
pa1-p1.c:99: note: worklist: examine stmt: _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:99: note: worklist: examine stmt: _133 = *_132;

pa1-p1.c:99: note: worklist: examine stmt: *_118 = _131;

pa1-p1.c:99: note: vect_is_simple_use: operand _131
pa1-p1.c:99: note: def_stmt: _131 = _119 + _130;

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: mark relevant 4, live 0.
pa1-p1.c:99: note: worklist: examine stmt: _131 = _119 + _130;

pa1-p1.c:99: note: vect_is_simple_use: operand _119
pa1-p1.c:99: note: def_stmt: _119 = *_118;

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: mark relevant 4, live 0.
pa1-p1.c:99: note: vect_is_simple_use: operand _130
pa1-p1.c:99: note: def_stmt: _130 = _126 * pretmp_294;

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: mark relevant 4, live 0.
pa1-p1.c:99: note: worklist: examine stmt: _130 = _126 * pretmp_294;

pa1-p1.c:99: note: vect_is_simple_use: operand _126
pa1-p1.c:99: note: def_stmt: _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: mark relevant 4, live 0.
pa1-p1.c:99: note: vect_is_simple_use: operand pretmp_294
pa1-p1.c:99: note: def_stmt: pretmp_294 = MEM[(double *)pretmp_293];

pa1-p1.c:99: note: type of def: 2.
pa1-p1.c:99: note: def_stmt is out of loop.
pa1-p1.c:99: note: worklist: examine stmt: _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:99: note: worklist: examine stmt: _119 = *_118;

pa1-p1.c:99: note: === vect_analyze_dependences ===
pa1-p1.c:99: note: dependence distance  = 0.
pa1-p1.c:99: note: dependence distance == 0 between *_118 and *_118
pa1-p1.c:99: note: dependence distance  = 0.
pa1-p1.c:99: note: dependence distance == 0 between *_132 and *_132
pa1-p1.c:99: note: === vect_determine_vectorization_factor ===
pa1-p1.c:99: note: ==> examining phi: j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:99: note: ==> examining phi: .MEM_235 = PHI <.MEM_194(21), .MEM_122(25)>

pa1-p1.c:99: note: ==> examining phi: ivtmp_166 = PHI <ivtmp_164(21), 4096(25)>

pa1-p1.c:99: note: ==> examining statement: _116 = (long unsigned int) j_229;

pa1-p1.c:99: note: skip.
pa1-p1.c:99: note: ==> examining statement: _117 = _116 * 8;

pa1-p1.c:99: note: skip.
pa1-p1.c:99: note: ==> examining statement: _118 = &y + _117;

pa1-p1.c:99: note: skip.
pa1-p1.c:99: note: ==> examining statement: _119 = *_118;

pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: nunits = 2
pa1-p1.c:99: note: ==> examining statement: _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: nunits = 2
pa1-p1.c:99: note: ==> examining statement: _130 = _126 * pretmp_294;

pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: nunits = 2
pa1-p1.c:99: note: ==> examining statement: _131 = _119 + _130;

pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: nunits = 2
pa1-p1.c:99: note: ==> examining statement: *_118 = _131;

pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: nunits = 2
pa1-p1.c:99: note: ==> examining statement: _132 = &z + _117;

pa1-p1.c:99: note: skip.
pa1-p1.c:99: note: ==> examining statement: _133 = *_132;

pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: nunits = 2
pa1-p1.c:99: note: ==> examining statement: _135 = _116 * 32768;

pa1-p1.c:99: note: skip.
pa1-p1.c:99: note: ==> examining statement: _136 = &A + _135;

pa1-p1.c:99: note: skip.
pa1-p1.c:99: note: ==> examining statement: _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: nunits = 2
pa1-p1.c:99: note: ==> examining statement: _139 = _137 * pretmp_294;

pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: nunits = 2
pa1-p1.c:99: note: ==> examining statement: _140 = _133 + _139;

pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: nunits = 2
pa1-p1.c:99: note: ==> examining statement: *_132 = _140;

pa1-p1.c:99: note: get vectype for scalar type:  double
pa1-p1.c:99: note: get vectype with 2 units of type double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: vectype: vector(2) double
pa1-p1.c:99: note: nunits = 2
pa1-p1.c:99: note: ==> examining statement: j_141 = j_229 + 1;

pa1-p1.c:99: note: skip.
pa1-p1.c:99: note: ==> examining statement: ivtmp_164 = ivtmp_166 - 1;

pa1-p1.c:99: note: skip.
pa1-p1.c:99: note: ==> examining statement: if (ivtmp_164 != 0)

pa1-p1.c:99: note: skip.
pa1-p1.c:99: note: vectorization factor = 2
pa1-p1.c:99: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:99: note: dependence distance  = 0.
pa1-p1.c:99: note: accesses have the same alignment.dependence distance modulo vf == 0 between *_118 and *_118
pa1-p1.c:99: note: dependence distance  = 0.
pa1-p1.c:99: note: accesses have the same alignment.dependence distance modulo vf == 0 between *_132 and *_132
pa1-p1.c:99: note: vect_compute_data_ref_alignment:
pa1-p1.c:99: note: misalign = 0 bytes of ref *_118
pa1-p1.c:99: note: vect_compute_data_ref_alignment:
pa1-p1.c:99: note: can't force alignment of ref: MEM[(double[0:D.4549] *)pretmp_291][j_229]
pa1-p1.c:99: note: vect_compute_data_ref_alignment:
pa1-p1.c:99: note: misalign = 0 bytes of ref *_118
pa1-p1.c:99: note: vect_compute_data_ref_alignment:
pa1-p1.c:99: note: misalign = 0 bytes of ref *_132
pa1-p1.c:99: note: vect_compute_data_ref_alignment:
pa1-p1.c:99: note: Unknown alignment for access: A
pa1-p1.c:99: note: vect_compute_data_ref_alignment:
pa1-p1.c:99: note: misalign = 0 bytes of ref *_132
pa1-p1.c:99: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:99: note: Detected single element interleaving MEM[(double[0:D.4549] *)_136][i_230] step 32768
pa1-p1.c:99: note: Data access with gaps requires scalar epilogue loop
pa1-p1.c:99: note: === vect_prune_runtime_alias_test_list ===
pa1-p1.c:99: note: === vect_enhance_data_refs_alignment ===
pa1-p1.c:99: note: Unknown misalignment, is_packed = 0
pa1-p1.c:99: note: vector alignment may not be reachable
pa1-p1.c:99: note: vect_can_advance_ivs_p:
pa1-p1.c:99: note: Analyze phi: j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:99: note: Access function of PHI: {0, +, 1}_5
pa1-p1.c:99: note: Analyze phi: .MEM_235 = PHI <.MEM_194(21), .MEM_122(25)>

pa1-p1.c:99: note: virtual phi. skip.
pa1-p1.c:99: note: Analyze phi: ivtmp_166 = PHI <ivtmp_164(21), 4096(25)>

pa1-p1.c:99: note: Access function of PHI: {4096, +, 4294967295}_5
pa1-p1.c:99: note: Vectorizing an unaligned access.
pa1-p1.c:99: note: Vectorizing an unaligned access.
pa1-p1.c:99: note: === vect_analyze_slp ===
pa1-p1.c:99: note: === vect_make_slp_decision ===
pa1-p1.c:99: note: === vect_detect_hybrid_slp ===
pa1-p1.c:99: note: === vect_analyze_loop_operations ===
pa1-p1.c:99: note: examining phi: j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:99: note: examining phi: .MEM_235 = PHI <.MEM_194(21), .MEM_122(25)>

pa1-p1.c:99: note: examining phi: ivtmp_166 = PHI <ivtmp_164(21), 4096(25)>

pa1-p1.c:99: note: ==> examining statement: _116 = (long unsigned int) j_229;

pa1-p1.c:99: note: irrelevant.
pa1-p1.c:99: note: ==> examining statement: _117 = _116 * 8;

pa1-p1.c:99: note: irrelevant.
pa1-p1.c:99: note: ==> examining statement: _118 = &y + _117;

pa1-p1.c:99: note: irrelevant.
pa1-p1.c:99: note: ==> examining statement: _119 = *_118;

pa1-p1.c:99: note: vect_is_simple_use: operand *_118
pa1-p1.c:99: note: not ssa-name.
pa1-p1.c:99: note: use not simple.
pa1-p1.c:99: note: vect_is_simple_use: operand *_118
pa1-p1.c:99: note: not ssa-name.
pa1-p1.c:99: note: use not simple.
pa1-p1.c:99: note: vect_model_load_cost: aligned.
pa1-p1.c:99: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
pa1-p1.c:99: note: ==> examining statement: _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:99: note: num. args = 4 (not unary/binary/ternary op).
pa1-p1.c:99: note: vect_is_simple_use: operand MEM[(double[0:D.4549] *)pretmp_291][j_229]
pa1-p1.c:99: note: not ssa-name.
pa1-p1.c:99: note: use not simple.
pa1-p1.c:99: note: vect_model_load_cost: unaligned supported by hardware.
pa1-p1.c:99: note: vect_model_load_cost: inside_cost = 2, prologue_cost = 0 .
pa1-p1.c:99: note: ==> examining statement: _130 = _126 * pretmp_294;

pa1-p1.c:99: note: vect_is_simple_use: operand _126
pa1-p1.c:99: note: def_stmt: _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: vect_is_simple_use: operand pretmp_294
pa1-p1.c:99: note: def_stmt: pretmp_294 = MEM[(double *)pretmp_293];

pa1-p1.c:99: note: type of def: 2.
pa1-p1.c:99: note: === vectorizable_operation ===
pa1-p1.c:99: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa1-p1.c:99: note: ==> examining statement: _131 = _119 + _130;

pa1-p1.c:99: note: vect_is_simple_use: operand _119
pa1-p1.c:99: note: def_stmt: _119 = *_118;

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: vect_is_simple_use: operand _130
pa1-p1.c:99: note: def_stmt: _130 = _126 * pretmp_294;

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: === vectorizable_operation ===
pa1-p1.c:99: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa1-p1.c:99: note: ==> examining statement: *_118 = _131;

pa1-p1.c:99: note: vect_is_simple_use: operand _131
pa1-p1.c:99: note: def_stmt: _131 = _119 + _130;

pa1-p1.c:99: note: type of def: 3.
pa1-p1.c:99: note: vect_model_store_cost: aligned.
pa1-p1.c:99: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
pa1-p1.c:99: note: ==> examining statement: _132 = &z + _117;

pa1-p1.c:99: note: irrelevant.
pa1-p1.c:99: note: ==> examining statement: _133 = *_132;

pa1-p1.c:99: note: vect_is_simple_use: operand *_132
pa1-p1.c:99: note: not ssa-name.
pa1-p1.c:99: note: use not simple.
pa1-p1.c:99: note: vect_is_simple_use: operand *_132
pa1-p1.c:99: note: not ssa-name.
pa1-p1.c:99: note: use not simple.
pa1-p1.c:99: note: vect_model_load_cost: aligned.
pa1-p1.c:99: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
pa1-p1.c:99: note: ==> examining statement: _135 = _116 * 32768;

pa1-p1.c:99: note: irrelevant.
pa1-p1.c:99: note: ==> examining statement: _136 = &A + _135;

pa1-p1.c:99: note: irrelevant.
pa1-p1.c:99: note: ==> examining statement: _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:99: note: num. args = 4 (not unary/binary/ternary op).
pa1-p1.c:99: note: vect_is_simple_use: operand MEM[(double[0:D.4549] *)_136][i_230]
pa1-p1.c:99: note: not ssa-name.
pa1-p1.c:99: note: use not simple.
pa1-p1.c:99: note: single-element interleaving not supported for not adjacent vector loads

pa1-p1.c:99: note: not vectorized: relevant stmt not supported: _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:99: note: bad operation or unsupported loop bound.
Analyzing loop at pa1-p1.c:40

pa1-p1.c:40: note: ===== analyze_loop_nest =====
pa1-p1.c:40: note: === vect_analyze_loop_form ===
pa1-p1.c:40: note: ===== analyze_loop_nest_1 =====
pa1-p1.c:40: note: === vect_analyze_loop_form ===
pa1-p1.c:40: note: === get_loop_niters ===
pa1-p1.c:40: note: ==> get_loop_niters:4096
pa1-p1.c:40: note: Considering outer-loop vectorization.
pa1-p1.c:40: note: === get_loop_niters ===
pa1-p1.c:40: note: ==> get_loop_niters:4096
pa1-p1.c:40: note: === vect_analyze_data_refs ===

pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: analyze in outer-loop: A
pa1-p1.c:40: note: 	outer base_address: &A
	outer offset from base address: 0
	outer constant offset from base address: 0
	outer step: 32768
	outer aligned to: 128
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:40: note: Analyze phi: i_221 = PHI <i_26(7), 0(2)>

pa1-p1.c:40: note: Access function of PHI: {0, +, 1}_1
pa1-p1.c:40: note: step: 1,  init: 0
pa1-p1.c:40: note: Detected induction.
pa1-p1.c:40: note: Analyze phi: .MEM_227 = PHI <.MEM_24(7), .MEM_13(D)(2)>

pa1-p1.c:40: note: Analyze phi: ivtmp_343 = PHI <ivtmp_342(7), 4096(2)>

pa1-p1.c:40: note: Access function of PHI: {4096, +, 4294967295}_1
pa1-p1.c:40: note: step: 4294967295,  init: 4096
pa1-p1.c:40: note: Detected induction.
pa1-p1.c:40: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:40: note: Analyze phi: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:40: note: Access function of PHI: {0, +, 1}_2
pa1-p1.c:40: note: step: 1,  init: 0
pa1-p1.c:40: note: Detected induction.
pa1-p1.c:40: note: Analyze phi: .MEM_226 = PHI <.MEM_24(5), .MEM_19(3)>

pa1-p1.c:40: note: Analyze phi: ivtmp_347 = PHI <ivtmp_344(5), 4096(3)>

pa1-p1.c:40: note: Access function of PHI: {4096, +, 4294967295}_2
pa1-p1.c:40: note: step: 4294967295,  init: 4096
pa1-p1.c:40: note: Detected induction.
pa1-p1.c:40: note: === vect_pattern_recog ===
pa1-p1.c:40: note: vect_is_simple_use: operand _20
pa1-p1.c:40: note: def_stmt: _20 = (double) j_223;

pa1-p1.c:40: note: type of def: 3.
pa1-p1.c:40: note: vect_is_simple_use: operand _22
pa1-p1.c:40: note: def_stmt: _22 = _14 + _21;

pa1-p1.c:40: note: type of def: 3.
pa1-p1.c:40: note: === vect_mark_stmts_to_be_vectorized ===
pa1-p1.c:40: note: init: phi relevant? i_221 = PHI <i_26(7), 0(2)>

pa1-p1.c:40: note: init: phi relevant? .MEM_227 = PHI <.MEM_24(7), .MEM_13(D)(2)>

pa1-p1.c:40: note: init: phi relevant? ivtmp_343 = PHI <ivtmp_342(7), 4096(2)>

pa1-p1.c:40: note: init: stmt relevant? _14 = (double) i_221;

pa1-p1.c:40: note: init: stmt relevant? x[i_221] = _14;

pa1-p1.c:40: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: init: stmt relevant? y[i_221] = 0.0;

pa1-p1.c:40: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: init: stmt relevant? z[i_221] = 1.0e+0;

pa1-p1.c:40: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: init: stmt relevant? yy[i_221] = 0.0;

pa1-p1.c:40: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: init: stmt relevant? zz[i_221] = 1.0e+0;

pa1-p1.c:40: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: init: phi relevant? j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:40: note: init: phi relevant? .MEM_226 = PHI <.MEM_24(5), .MEM_19(3)>

pa1-p1.c:40: note: init: phi relevant? ivtmp_347 = PHI <ivtmp_344(5), 4096(3)>

pa1-p1.c:40: note: init: stmt relevant? _20 = (double) j_223;

pa1-p1.c:40: note: init: stmt relevant? _21 = _20 * 2.0e+0;

pa1-p1.c:40: note: init: stmt relevant? _22 = _14 + _21;

pa1-p1.c:40: note: init: stmt relevant? _23 = _22 * 1.220703125e-4;

pa1-p1.c:40: note: init: stmt relevant? A[i_221][j_223] = _23;

pa1-p1.c:40: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: init: stmt relevant? j_25 = j_223 + 1;

pa1-p1.c:40: note: init: stmt relevant? ivtmp_344 = ivtmp_347 - 1;

pa1-p1.c:40: note: init: stmt relevant? if (ivtmp_344 != 0)

pa1-p1.c:40: note: init: stmt relevant? i_26 = i_221 + 1;

pa1-p1.c:40: note: init: stmt relevant? ivtmp_342 = ivtmp_343 - 1;

pa1-p1.c:40: note: init: stmt relevant? if (ivtmp_342 != 0)

pa1-p1.c:40: note: worklist: examine stmt: A[i_221][j_223] = _23;

pa1-p1.c:40: note: vect_is_simple_use: operand _23
pa1-p1.c:40: note: def_stmt: _23 = _22 * 1.220703125e-4;

pa1-p1.c:40: note: type of def: 3.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: worklist: examine stmt: _23 = _22 * 1.220703125e-4;

pa1-p1.c:40: note: vect_is_simple_use: operand _22
pa1-p1.c:40: note: def_stmt: _22 = _14 + _21;

pa1-p1.c:40: note: type of def: 3.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: worklist: examine stmt: _22 = _14 + _21;

pa1-p1.c:40: note: vect_is_simple_use: operand _14
pa1-p1.c:40: note: def_stmt: _14 = (double) i_221;

pa1-p1.c:40: note: type of def: 3.
pa1-p1.c:40: note: outer-loop def-stmt defining inner-loop stmt.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: vect_is_simple_use: operand _21
pa1-p1.c:40: note: def_stmt: _21 = _20 * 2.0e+0;

pa1-p1.c:40: note: type of def: 3.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: worklist: examine stmt: _21 = _20 * 2.0e+0;

pa1-p1.c:40: note: vect_is_simple_use: operand _20
pa1-p1.c:40: note: def_stmt: _20 = (double) j_223;

pa1-p1.c:40: note: type of def: 3.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: worklist: examine stmt: _20 = (double) j_223;

pa1-p1.c:40: note: vect_is_simple_use: operand j_223
pa1-p1.c:40: note: def_stmt: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:40: note: type of def: 4.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: worklist: examine stmt: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:40: note: vect_is_simple_use: operand j_25
pa1-p1.c:40: note: def_stmt: j_25 = j_223 + 1;

pa1-p1.c:40: note: type of def: 3.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: vect_is_simple_use: operand 0
pa1-p1.c:40: note: worklist: examine stmt: j_25 = j_223 + 1;

pa1-p1.c:40: note: vect_is_simple_use: operand j_223
pa1-p1.c:40: note: def_stmt: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:40: note: type of def: 4.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: already marked relevant/live.
pa1-p1.c:40: note: worklist: examine stmt: _14 = (double) i_221;

pa1-p1.c:40: note: vect_is_simple_use: operand i_221
pa1-p1.c:40: note: def_stmt: i_221 = PHI <i_26(7), 0(2)>

pa1-p1.c:40: note: type of def: 4.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: worklist: examine stmt: i_221 = PHI <i_26(7), 0(2)>

pa1-p1.c:40: note: vect_is_simple_use: operand i_26
pa1-p1.c:40: note: def_stmt: i_26 = i_221 + 1;

pa1-p1.c:40: note: type of def: 3.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: vect_is_simple_use: operand 0
pa1-p1.c:40: note: worklist: examine stmt: i_26 = i_221 + 1;

pa1-p1.c:40: note: vect_is_simple_use: operand i_221
pa1-p1.c:40: note: def_stmt: i_221 = PHI <i_26(7), 0(2)>

pa1-p1.c:40: note: type of def: 4.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: already marked relevant/live.
pa1-p1.c:40: note: worklist: examine stmt: zz[i_221] = 1.0e+0;

pa1-p1.c:40: note: worklist: examine stmt: yy[i_221] = 0.0;

pa1-p1.c:40: note: worklist: examine stmt: z[i_221] = 1.0e+0;

pa1-p1.c:40: note: worklist: examine stmt: y[i_221] = 0.0;

pa1-p1.c:40: note: worklist: examine stmt: x[i_221] = _14;

pa1-p1.c:40: note: vect_is_simple_use: operand _14
pa1-p1.c:40: note: def_stmt: _14 = (double) i_221;

pa1-p1.c:40: note: type of def: 3.
pa1-p1.c:40: note: mark relevant 4, live 0.
pa1-p1.c:40: note: already marked relevant/live.
pa1-p1.c:40: note: === vect_analyze_dependences ===
pa1-p1.c:40: note: === vect_determine_vectorization_factor ===
pa1-p1.c:40: note: ==> examining phi: i_221 = PHI <i_26(7), 0(2)>

pa1-p1.c:40: note: get vectype for scalar type:  int
pa1-p1.c:40: note: get vectype with 4 units of type int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: nunits = 4
pa1-p1.c:40: note: ==> examining phi: .MEM_227 = PHI <.MEM_24(7), .MEM_13(D)(2)>

pa1-p1.c:40: note: ==> examining phi: ivtmp_343 = PHI <ivtmp_342(7), 4096(2)>

pa1-p1.c:40: note: ==> examining statement: _14 = (double) i_221;

pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: get vectype for scalar type:  int
pa1-p1.c:40: note: get vectype with 4 units of type int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: nunits = 4
pa1-p1.c:40: note: ==> examining statement: x[i_221] = _14;

pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: nunits = 2
pa1-p1.c:40: note: ==> examining statement: y[i_221] = 0.0;

pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: nunits = 2
pa1-p1.c:40: note: ==> examining statement: z[i_221] = 1.0e+0;

pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: nunits = 2
pa1-p1.c:40: note: ==> examining statement: yy[i_221] = 0.0;

pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: nunits = 2
pa1-p1.c:40: note: ==> examining statement: zz[i_221] = 1.0e+0;

pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: nunits = 2
pa1-p1.c:40: note: ==> examining phi: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:40: note: get vectype for scalar type:  int
pa1-p1.c:40: note: get vectype with 4 units of type int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: nunits = 4
pa1-p1.c:40: note: ==> examining phi: .MEM_226 = PHI <.MEM_24(5), .MEM_19(3)>

pa1-p1.c:40: note: ==> examining phi: ivtmp_347 = PHI <ivtmp_344(5), 4096(3)>

pa1-p1.c:40: note: ==> examining statement: _20 = (double) j_223;

pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: get vectype for scalar type:  int
pa1-p1.c:40: note: get vectype with 4 units of type int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: nunits = 4
pa1-p1.c:40: note: ==> examining statement: _21 = _20 * 2.0e+0;

pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: nunits = 2
pa1-p1.c:40: note: ==> examining statement: _22 = _14 + _21;

pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: nunits = 2
pa1-p1.c:40: note: ==> examining statement: _23 = _22 * 1.220703125e-4;

pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: nunits = 2
pa1-p1.c:40: note: ==> examining statement: A[i_221][j_223] = _23;

pa1-p1.c:40: note: get vectype for scalar type:  double
pa1-p1.c:40: note: get vectype with 2 units of type double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: vectype: vector(2) double
pa1-p1.c:40: note: nunits = 2
pa1-p1.c:40: note: ==> examining statement: j_25 = j_223 + 1;

pa1-p1.c:40: note: get vectype for scalar type:  int
pa1-p1.c:40: note: get vectype with 4 units of type int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: get vectype for scalar type:  int
pa1-p1.c:40: note: get vectype with 4 units of type int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: nunits = 4
pa1-p1.c:40: note: ==> examining statement: ivtmp_344 = ivtmp_347 - 1;

pa1-p1.c:40: note: skip.
pa1-p1.c:40: note: ==> examining statement: if (ivtmp_344 != 0)

pa1-p1.c:40: note: skip.
pa1-p1.c:40: note: ==> examining statement: i_26 = i_221 + 1;

pa1-p1.c:40: note: get vectype for scalar type:  int
pa1-p1.c:40: note: get vectype with 4 units of type int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: get vectype for scalar type:  int
pa1-p1.c:40: note: get vectype with 4 units of type int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: vectype: vector(4) int
pa1-p1.c:40: note: nunits = 4
pa1-p1.c:40: note: ==> examining statement: ivtmp_342 = ivtmp_343 - 1;

pa1-p1.c:40: note: skip.
pa1-p1.c:40: note: ==> examining statement: if (ivtmp_342 != 0)

pa1-p1.c:40: note: skip.
pa1-p1.c:40: note: vectorization factor = 4
pa1-p1.c:40: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:40: note: vect_compute_data_ref_alignment:
pa1-p1.c:40: note: misalign = 0 bytes of ref x[i_221]
pa1-p1.c:40: note: vect_compute_data_ref_alignment:
pa1-p1.c:40: note: misalign = 0 bytes of ref y[i_221]
pa1-p1.c:40: note: vect_compute_data_ref_alignment:
pa1-p1.c:40: note: misalign = 0 bytes of ref z[i_221]
pa1-p1.c:40: note: vect_compute_data_ref_alignment:
pa1-p1.c:40: note: misalign = 0 bytes of ref yy[i_221]
pa1-p1.c:40: note: vect_compute_data_ref_alignment:
pa1-p1.c:40: note: misalign = 0 bytes of ref zz[i_221]
pa1-p1.c:40: note: vect_compute_data_ref_alignment:
pa1-p1.c:40: note: inner step doesn't divide the vector-size.
pa1-p1.c:40: note: Unknown alignment for access: A
pa1-p1.c:40: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:40: note: grouped access in outer loop.
pa1-p1.c:40: note: not vectorized: complicated access pattern.
pa1-p1.c:40: note: bad data access.
Analyzing loop at pa1-p1.c:45

pa1-p1.c:45: note: ===== analyze_loop_nest =====
pa1-p1.c:45: note: === vect_analyze_loop_form ===
pa1-p1.c:45: note: === get_loop_niters ===
pa1-p1.c:45: note: ==> get_loop_niters:4096
pa1-p1.c:45: note: === vect_analyze_data_refs ===

pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: === vect_analyze_scalar_cycles ===
pa1-p1.c:45: note: Analyze phi: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:45: note: Access function of PHI: {0, +, 1}_2
pa1-p1.c:45: note: step: 1,  init: 0
pa1-p1.c:45: note: Detected induction.
pa1-p1.c:45: note: Analyze phi: .MEM_226 = PHI <.MEM_24(5), .MEM_19(3)>

pa1-p1.c:45: note: Analyze phi: ivtmp_347 = PHI <ivtmp_344(5), 4096(3)>

pa1-p1.c:45: note: Access function of PHI: {4096, +, 4294967295}_2
pa1-p1.c:45: note: step: 4294967295,  init: 4096
pa1-p1.c:45: note: Detected induction.
pa1-p1.c:45: note: === vect_pattern_recog ===
pa1-p1.c:45: note: vect_is_simple_use: operand _20
pa1-p1.c:45: note: def_stmt: _20 = (double) j_223;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: vect_is_simple_use: operand _22
pa1-p1.c:45: note: def_stmt: _22 = _14 + _21;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: === vect_mark_stmts_to_be_vectorized ===
pa1-p1.c:45: note: init: phi relevant? j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:45: note: init: phi relevant? .MEM_226 = PHI <.MEM_24(5), .MEM_19(3)>

pa1-p1.c:45: note: init: phi relevant? ivtmp_347 = PHI <ivtmp_344(5), 4096(3)>

pa1-p1.c:45: note: init: stmt relevant? _20 = (double) j_223;

pa1-p1.c:45: note: init: stmt relevant? _21 = _20 * 2.0e+0;

pa1-p1.c:45: note: init: stmt relevant? _22 = _14 + _21;

pa1-p1.c:45: note: init: stmt relevant? _23 = _22 * 1.220703125e-4;

pa1-p1.c:45: note: init: stmt relevant? A[i_221][j_223] = _23;

pa1-p1.c:45: note: vec_stmt_relevant_p: stmt has vdefs.
pa1-p1.c:45: note: mark relevant 4, live 0.
pa1-p1.c:45: note: init: stmt relevant? j_25 = j_223 + 1;

pa1-p1.c:45: note: init: stmt relevant? ivtmp_344 = ivtmp_347 - 1;

pa1-p1.c:45: note: init: stmt relevant? if (ivtmp_344 != 0)

pa1-p1.c:45: note: worklist: examine stmt: A[i_221][j_223] = _23;

pa1-p1.c:45: note: vect_is_simple_use: operand _23
pa1-p1.c:45: note: def_stmt: _23 = _22 * 1.220703125e-4;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: mark relevant 4, live 0.
pa1-p1.c:45: note: worklist: examine stmt: _23 = _22 * 1.220703125e-4;

pa1-p1.c:45: note: vect_is_simple_use: operand _22
pa1-p1.c:45: note: def_stmt: _22 = _14 + _21;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: mark relevant 4, live 0.
pa1-p1.c:45: note: worklist: examine stmt: _22 = _14 + _21;

pa1-p1.c:45: note: vect_is_simple_use: operand _14
pa1-p1.c:45: note: def_stmt: _14 = (double) i_221;

pa1-p1.c:45: note: type of def: 2.
pa1-p1.c:45: note: def_stmt is out of loop.
pa1-p1.c:45: note: vect_is_simple_use: operand _21
pa1-p1.c:45: note: def_stmt: _21 = _20 * 2.0e+0;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: mark relevant 4, live 0.
pa1-p1.c:45: note: worklist: examine stmt: _21 = _20 * 2.0e+0;

pa1-p1.c:45: note: vect_is_simple_use: operand _20
pa1-p1.c:45: note: def_stmt: _20 = (double) j_223;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: mark relevant 4, live 0.
pa1-p1.c:45: note: worklist: examine stmt: _20 = (double) j_223;

pa1-p1.c:45: note: vect_is_simple_use: operand j_223
pa1-p1.c:45: note: def_stmt: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:45: note: type of def: 4.
pa1-p1.c:45: note: mark relevant 4, live 0.
pa1-p1.c:45: note: worklist: examine stmt: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:45: note: vect_is_simple_use: operand j_25
pa1-p1.c:45: note: def_stmt: j_25 = j_223 + 1;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: mark relevant 4, live 0.
pa1-p1.c:45: note: vect_is_simple_use: operand 0
pa1-p1.c:45: note: worklist: examine stmt: j_25 = j_223 + 1;

pa1-p1.c:45: note: vect_is_simple_use: operand j_223
pa1-p1.c:45: note: def_stmt: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:45: note: type of def: 4.
pa1-p1.c:45: note: mark relevant 4, live 0.
pa1-p1.c:45: note: already marked relevant/live.
pa1-p1.c:45: note: === vect_analyze_dependences ===
pa1-p1.c:45: note: === vect_determine_vectorization_factor ===
pa1-p1.c:45: note: ==> examining phi: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:45: note: get vectype for scalar type:  int
pa1-p1.c:45: note: get vectype with 4 units of type int
pa1-p1.c:45: note: vectype: vector(4) int
pa1-p1.c:45: note: vectype: vector(4) int
pa1-p1.c:45: note: nunits = 4
pa1-p1.c:45: note: ==> examining phi: .MEM_226 = PHI <.MEM_24(5), .MEM_19(3)>

pa1-p1.c:45: note: ==> examining phi: ivtmp_347 = PHI <ivtmp_344(5), 4096(3)>

pa1-p1.c:45: note: ==> examining statement: _20 = (double) j_223;

pa1-p1.c:45: note: get vectype for scalar type:  double
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: get vectype for scalar type:  int
pa1-p1.c:45: note: get vectype with 4 units of type int
pa1-p1.c:45: note: vectype: vector(4) int
pa1-p1.c:45: note: vectype: vector(4) int
pa1-p1.c:45: note: nunits = 4
pa1-p1.c:45: note: ==> examining statement: _21 = _20 * 2.0e+0;

pa1-p1.c:45: note: get vectype for scalar type:  double
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: get vectype for scalar type:  double
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: nunits = 2
pa1-p1.c:45: note: ==> examining statement: _22 = _14 + _21;

pa1-p1.c:45: note: get vectype for scalar type:  double
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: get vectype for scalar type:  double
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: nunits = 2
pa1-p1.c:45: note: ==> examining statement: _23 = _22 * 1.220703125e-4;

pa1-p1.c:45: note: get vectype for scalar type:  double
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: get vectype for scalar type:  double
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: nunits = 2
pa1-p1.c:45: note: ==> examining statement: A[i_221][j_223] = _23;

pa1-p1.c:45: note: get vectype for scalar type:  double
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: nunits = 2
pa1-p1.c:45: note: ==> examining statement: j_25 = j_223 + 1;

pa1-p1.c:45: note: get vectype for scalar type:  int
pa1-p1.c:45: note: get vectype with 4 units of type int
pa1-p1.c:45: note: vectype: vector(4) int
pa1-p1.c:45: note: get vectype for scalar type:  int
pa1-p1.c:45: note: get vectype with 4 units of type int
pa1-p1.c:45: note: vectype: vector(4) int
pa1-p1.c:45: note: vectype: vector(4) int
pa1-p1.c:45: note: nunits = 4
pa1-p1.c:45: note: ==> examining statement: ivtmp_344 = ivtmp_347 - 1;

pa1-p1.c:45: note: skip.
pa1-p1.c:45: note: ==> examining statement: if (ivtmp_344 != 0)

pa1-p1.c:45: note: skip.
pa1-p1.c:45: note: vectorization factor = 4
pa1-p1.c:45: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:45: note: vect_compute_data_ref_alignment:
pa1-p1.c:45: note: misalign = 0 bytes of ref A[i_221][j_223]
pa1-p1.c:45: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:45: note: === vect_prune_runtime_alias_test_list ===
pa1-p1.c:45: note: === vect_enhance_data_refs_alignment ===
pa1-p1.c:45: note: vect_can_advance_ivs_p:
pa1-p1.c:45: note: Analyze phi: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:45: note: Access function of PHI: {0, +, 1}_2
pa1-p1.c:45: note: Analyze phi: .MEM_226 = PHI <.MEM_24(5), .MEM_19(3)>

pa1-p1.c:45: note: virtual phi. skip.
pa1-p1.c:45: note: Analyze phi: ivtmp_347 = PHI <ivtmp_344(5), 4096(3)>

pa1-p1.c:45: note: Access function of PHI: {4096, +, 4294967295}_2
pa1-p1.c:45: note: vect_model_store_cost: aligned.
pa1-p1.c:45: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
pa1-p1.c:45: note: === vect_analyze_slp ===
pa1-p1.c:45: note: === vect_make_slp_decision ===
pa1-p1.c:45: note: === vect_detect_hybrid_slp ===
pa1-p1.c:45: note: === vect_analyze_loop_operations ===
pa1-p1.c:45: note: examining phi: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:45: note: === vectorizable_induction ===
pa1-p1.c:45: note: vect_model_induction_cost: inside_cost = 1, prologue_cost = 2 .
pa1-p1.c:45: note: examining phi: .MEM_226 = PHI <.MEM_24(5), .MEM_19(3)>

pa1-p1.c:45: note: examining phi: ivtmp_347 = PHI <ivtmp_344(5), 4096(3)>

pa1-p1.c:45: note: ==> examining statement: _20 = (double) j_223;

pa1-p1.c:45: note: vect_is_simple_use: operand j_223
pa1-p1.c:45: note: def_stmt: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:45: note: type of def: 4.
pa1-p1.c:45: note: === vectorizable_conversion ===
pa1-p1.c:45: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 0 .
pa1-p1.c:45: note: ==> examining statement: _21 = _20 * 2.0e+0;

pa1-p1.c:45: note: vect_is_simple_use: operand _20
pa1-p1.c:45: note: def_stmt: _20 = (double) j_223;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: vect_is_simple_use: operand 2.0e+0
pa1-p1.c:45: note: === vectorizable_operation ===
pa1-p1.c:45: note: vect_model_simple_cost: inside_cost = 2, prologue_cost = 1 .
pa1-p1.c:45: note: ==> examining statement: _22 = _14 + _21;

pa1-p1.c:45: note: vect_is_simple_use: operand _14
pa1-p1.c:45: note: def_stmt: _14 = (double) i_221;

pa1-p1.c:45: note: type of def: 2.
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: vect_is_simple_use: operand _21
pa1-p1.c:45: note: def_stmt: _21 = _20 * 2.0e+0;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: === vectorizable_operation ===
pa1-p1.c:45: note: vect_model_simple_cost: inside_cost = 2, prologue_cost = 1 .
pa1-p1.c:45: note: ==> examining statement: _23 = _22 * 1.220703125e-4;

pa1-p1.c:45: note: vect_is_simple_use: operand _22
pa1-p1.c:45: note: def_stmt: _22 = _14 + _21;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: vect_is_simple_use: operand 1.220703125e-4
pa1-p1.c:45: note: === vectorizable_operation ===
pa1-p1.c:45: note: vect_model_simple_cost: inside_cost = 2, prologue_cost = 1 .
pa1-p1.c:45: note: ==> examining statement: A[i_221][j_223] = _23;

pa1-p1.c:45: note: vect_is_simple_use: operand _23
pa1-p1.c:45: note: def_stmt: _23 = _22 * 1.220703125e-4;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: vect_model_store_cost: aligned.
pa1-p1.c:45: note: vect_model_store_cost: inside_cost = 2, prologue_cost = 0 .
pa1-p1.c:45: note: ==> examining statement: j_25 = j_223 + 1;

pa1-p1.c:45: note: vect_is_simple_use: operand j_223
pa1-p1.c:45: note: def_stmt: j_223 = PHI <j_25(5), 0(3)>

pa1-p1.c:45: note: type of def: 4.
pa1-p1.c:45: note: vect_is_simple_use: operand 1
pa1-p1.c:45: note: === vectorizable_operation ===
pa1-p1.c:45: note: vect_model_simple_cost: inside_cost = 1, prologue_cost = 1 .
pa1-p1.c:45: note: ==> examining statement: ivtmp_344 = ivtmp_347 - 1;

pa1-p1.c:45: note: irrelevant.
pa1-p1.c:45: note: ==> examining statement: if (ivtmp_344 != 0)

pa1-p1.c:45: note: irrelevant.
pa1-p1.c:45: note: vectorization_factor = 4, niters = 4096
pa1-p1.c:45: note: === vect_update_slp_costs_according_to_vf ===
pa1-p1.c:45: note: Cost model analysis: 
  Vector inside of loop cost: 11
  Vector prologue cost: 6
  Vector epilogue cost: 0
  Scalar iteration cost: 6
  Scalar outside cost: 0
  Vector outside cost: 6
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 2

pa1-p1.c:45: note:   Runtime profitability threshold = 3

pa1-p1.c:45: note:   Static estimate profitability threshold = 3


Vectorizing loop at pa1-p1.c:45

pa1-p1.c:45: note: === vec_transform_loop ===
pa1-p1.c:45: note: ------>vectorizing phi: j_223 = PHI <j_25(5), 0(60)>

pa1-p1.c:45: note: transform phi.
pa1-p1.c:45: note: transform induction phi.
pa1-p1.c:45: note: get vectype with 4 units of type int
pa1-p1.c:45: note: vectype: vector(4) int
pa1-p1.c:45: note: get vectype with 4 units of type int
pa1-p1.c:45: note: vectype: vector(4) int
pa1-p1.c:45: note: created new init_stmt: stmp_var_.149_255 = 0 + 1;

pa1-p1.c:45: note: created new init_stmt: stmp_var_.149_254 = stmp_var_.149_255 + 1;

pa1-p1.c:45: note: created new init_stmt: stmp_var_.149_253 = stmp_var_.149_254 + 1;

pa1-p1.c:45: note: created new init_stmt: vect_cst_.150_252 = {0, stmp_var_.149_255, stmp_var_.149_254, stmp_var_.149_253};

pa1-p1.c:45: note: get vectype with 4 units of type int
pa1-p1.c:45: note: vectype: vector(4) int
pa1-p1.c:45: note: created new init_stmt: vect_cst_.151_251 = { 4, 4, 4, 4 };

pa1-p1.c:45: note: transform induction: created def-use cycle: vect_vec_iv_.152_250 = PHI <vect_vec_iv_.152_249(5), vect_cst_.150_252(60)>

vect_vec_iv_.152_249 = vect_vec_iv_.152_250 + vect_cst_.151_251;

pa1-p1.c:45: note: ------>vectorizing phi: .MEM_226 = PHI <.MEM_24(5), .MEM_19(60)>

pa1-p1.c:45: note: ------>vectorizing phi: ivtmp_347 = PHI <ivtmp_344(5), 4096(60)>

pa1-p1.c:45: note: ------>vectorizing phi: vect_vec_iv_.152_250 = PHI <vect_vec_iv_.152_249(5), vect_cst_.150_252(60)>

pa1-p1.c:45: note: ------>vectorizing statement: vect_vec_iv_.152_249 = vect_vec_iv_.152_250 + vect_cst_.151_251;

pa1-p1.c:45: note: ------>vectorizing statement: _20 = (double) j_223;

pa1-p1.c:45: note: multiple-types.
pa1-p1.c:45: note: transform statement.
pa1-p1.c:45: note: vect_is_simple_use: operand j_223
pa1-p1.c:45: note: def_stmt: j_223 = PHI <j_25(5), 0(60)>

pa1-p1.c:45: note: type of def: 4.
pa1-p1.c:45: note: transform conversion. ncopies = 1.
pa1-p1.c:45: note: vect_get_vec_def_for_operand: j_223
pa1-p1.c:45: note: vect_is_simple_use: operand j_223
pa1-p1.c:45: note: def_stmt: j_223 = PHI <j_25(5), 0(60)>

pa1-p1.c:45: note: type of def: 4.
pa1-p1.c:45: note: def =  j_223  def_stmt =  j_223 = PHI <j_25(5), 0(60)>

pa1-p1.c:45: note: add new stmt: vect_var_.153_248 = [vec_unpack_float_lo_expr] vect_vec_iv_.152_250;

pa1-p1.c:45: note: add new stmt: vect_var_.153_247 = [vec_unpack_float_hi_expr] vect_vec_iv_.152_250;

pa1-p1.c:45: note: ------>vectorizing statement: _21 = _20 * 2.0e+0;

pa1-p1.c:45: note: multiple-types.
pa1-p1.c:45: note: transform statement.
pa1-p1.c:45: note: vect_is_simple_use: operand _20
pa1-p1.c:45: note: def_stmt: _20 = (double) j_223;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: vect_is_simple_use: operand 2.0e+0
pa1-p1.c:45: note: transform binary/unary operation.
pa1-p1.c:45: note: vect_get_vec_def_for_operand: _20
pa1-p1.c:45: note: vect_is_simple_use: operand _20
pa1-p1.c:45: note: def_stmt: _20 = (double) j_223;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: def =  _20  def_stmt =  _20 = (double) j_223;

pa1-p1.c:45: note: vect_get_vec_def_for_operand: 2.0e+0
pa1-p1.c:45: note: vect_is_simple_use: operand 2.0e+0
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: Create vector_cst. nunits = 2
pa1-p1.c:45: note: created new init_stmt: vect_cst_.155_246 = { 2.0e+0, 2.0e+0 };

pa1-p1.c:45: note: add new stmt: vect_var_.154_245 = vect_var_.153_248 * vect_cst_.155_246;

pa1-p1.c:45: note: add new stmt: vect_var_.154_244 = vect_var_.153_247 * vect_cst_.155_246;

pa1-p1.c:45: note: ------>vectorizing statement: _22 = _14 + _21;

pa1-p1.c:45: note: multiple-types.
pa1-p1.c:45: note: transform statement.
pa1-p1.c:45: note: vect_is_simple_use: operand _14
pa1-p1.c:45: note: def_stmt: _14 = (double) i_221;

pa1-p1.c:45: note: type of def: 2.
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: vect_is_simple_use: operand _21
pa1-p1.c:45: note: def_stmt: _21 = _20 * 2.0e+0;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: transform binary/unary operation.
pa1-p1.c:45: note: vect_get_vec_def_for_operand: _14
pa1-p1.c:45: note: vect_is_simple_use: operand _14
pa1-p1.c:45: note: def_stmt: _14 = (double) i_221;

pa1-p1.c:45: note: type of def: 2.
pa1-p1.c:45: note: def =  _14  def_stmt =  _14 = (double) i_221;

pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: Create vector_inv.
pa1-p1.c:45: note: created new init_stmt: vect_cst_.157_243 = {_14, _14};

pa1-p1.c:45: note: vect_get_vec_def_for_operand: _21
pa1-p1.c:45: note: vect_is_simple_use: operand _21
pa1-p1.c:45: note: def_stmt: _21 = _20 * 2.0e+0;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: def =  _21  def_stmt =  _21 = _20 * 2.0e+0;

pa1-p1.c:45: note: add new stmt: vect_var_.156_242 = vect_cst_.157_243 + vect_var_.154_245;

pa1-p1.c:45: note: add new stmt: vect_var_.156_241 = vect_cst_.157_243 + vect_var_.154_244;

pa1-p1.c:45: note: ------>vectorizing statement: _23 = _22 * 1.220703125e-4;

pa1-p1.c:45: note: multiple-types.
pa1-p1.c:45: note: transform statement.
pa1-p1.c:45: note: vect_is_simple_use: operand _22
pa1-p1.c:45: note: def_stmt: _22 = _14 + _21;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: vect_is_simple_use: operand 1.220703125e-4
pa1-p1.c:45: note: transform binary/unary operation.
pa1-p1.c:45: note: vect_get_vec_def_for_operand: _22
pa1-p1.c:45: note: vect_is_simple_use: operand _22
pa1-p1.c:45: note: def_stmt: _22 = _14 + _21;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: def =  _22  def_stmt =  _22 = _14 + _21;

pa1-p1.c:45: note: vect_get_vec_def_for_operand: 1.220703125e-4
pa1-p1.c:45: note: vect_is_simple_use: operand 1.220703125e-4
pa1-p1.c:45: note: get vectype with 2 units of type double
pa1-p1.c:45: note: vectype: vector(2) double
pa1-p1.c:45: note: Create vector_cst. nunits = 2
pa1-p1.c:45: note: created new init_stmt: vect_cst_.159_240 = { 1.220703125e-4, 1.220703125e-4 };

pa1-p1.c:45: note: add new stmt: vect_var_.158_239 = vect_var_.156_242 * vect_cst_.159_240;

pa1-p1.c:45: note: add new stmt: vect_var_.158_238 = vect_var_.156_241 * vect_cst_.159_240;

pa1-p1.c:45: note: ------>vectorizing statement: A[i_221][j_223] = _23;

pa1-p1.c:45: note: multiple-types.
pa1-p1.c:45: note: transform statement.
pa1-p1.c:45: note: vect_is_simple_use: operand _23
pa1-p1.c:45: note: def_stmt: _23 = _22 * 1.220703125e-4;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: transform store. ncopies = 2
pa1-p1.c:45: note: vect_get_vec_def_for_operand: _23
pa1-p1.c:45: note: vect_is_simple_use: operand _23
pa1-p1.c:45: note: def_stmt: _23 = _22 * 1.220703125e-4;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: def =  _23  def_stmt =  _23 = _22 * 1.220703125e-4;

pa1-p1.c:45: note: create vector_type-pointer variable to type: vector(2) double  vectorizing an array ref: A
pa1-p1.c:45: note: created vect_pA.163_218
pa1-p1.c:45: note: add new stmt: MEM[(double[4096][4096] *)vect_pA.160_217] = vect_var_.158_239;

pa1-p1.c:45: note: vect_is_simple_use: operand vect_var_.158_239
pa1-p1.c:45: note: def_stmt: vect_var_.158_239 = vect_var_.156_242 * vect_cst_.159_240;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: add new stmt: vect_pA.160_214 = vect_pA.160_217 + 16;

pa1-p1.c:45: note: add new stmt: MEM[(double[4096][4096] *)vect_pA.160_214] = vect_var_.158_238;

pa1-p1.c:45: note: ------>vectorizing statement: j_25 = j_223 + 1;

pa1-p1.c:45: note: transform statement.
pa1-p1.c:45: note: vect_is_simple_use: operand j_223
pa1-p1.c:45: note: def_stmt: j_223 = PHI <j_25(5), 0(60)>

pa1-p1.c:45: note: type of def: 4.
pa1-p1.c:45: note: vect_is_simple_use: operand 1
pa1-p1.c:45: note: transform binary/unary operation.
pa1-p1.c:45: note: vect_get_vec_def_for_operand: j_223
pa1-p1.c:45: note: vect_is_simple_use: operand j_223
pa1-p1.c:45: note: def_stmt: j_223 = PHI <j_25(5), 0(60)>

pa1-p1.c:45: note: type of def: 4.
pa1-p1.c:45: note: def =  j_223  def_stmt =  j_223 = PHI <j_25(5), 0(60)>

pa1-p1.c:45: note: vect_get_vec_def_for_operand: 1
pa1-p1.c:45: note: vect_is_simple_use: operand 1
pa1-p1.c:45: note: get vectype with 4 units of type int
pa1-p1.c:45: note: vectype: vector(4) int
pa1-p1.c:45: note: Create vector_cst. nunits = 4
pa1-p1.c:45: note: created new init_stmt: vect_cst_.165_24 = { 1, 1, 1, 1 };

pa1-p1.c:45: note: add new stmt: vect_j.164_212 = vect_vec_iv_.152_250 + vect_cst_.165_24;

pa1-p1.c:45: note: ------>vectorizing statement: ivtmp_344 = ivtmp_347 - 1;

pa1-p1.c:45: note: ------>vectorizing statement: vect_pA.160_216 = vect_pA.160_214 + 16;

pa1-p1.c:45: note: ------>vectorizing statement: if (ivtmp_344 != 0)

loop at pa1-p1.c:45: if (ivtmp_210 < 1024)

pa1-p1.c:45: note: LOOP VECTORIZED.
pa1-p1.c:25: note: vectorized 3 loops in function.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:42: note: ===vect_slp_analyze_bb===

pa1-p1.c:42: note: === vect_analyze_data_refs ===

pa1-p1.c:42: note: get vectype with 2 units of type double
pa1-p1.c:42: note: vectype: vector(2) double
pa1-p1.c:42: note: get vectype with 2 units of type double
pa1-p1.c:42: note: vectype: vector(2) double
pa1-p1.c:42: note: get vectype with 2 units of type double
pa1-p1.c:42: note: vectype: vector(2) double
pa1-p1.c:42: note: get vectype with 2 units of type double
pa1-p1.c:42: note: vectype: vector(2) double
pa1-p1.c:42: note: get vectype with 2 units of type double
pa1-p1.c:42: note: vectype: vector(2) double
pa1-p1.c:42: note: === vect_pattern_recog ===
pa1-p1.c:42: note: vect_is_simple_use: operand _219
pa1-p1.c:42: note: def_stmt: _219 = (sizetype) i_221;

pa1-p1.c:42: note: type of def: 3.
pa1-p1.c:42: note: vect_is_simple_use: operand i_221
pa1-p1.c:42: note: def_stmt: i_221 = PHI <i_26(7), 0(2)>

pa1-p1.c:42: note: type of def: 2.
pa1-p1.c:42: note: vect_is_simple_use: operand 32768
pa1-p1.c:42: note: === vect_analyze_dependences ===
pa1-p1.c:42: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:42: note: vect_compute_data_ref_alignment:
pa1-p1.c:42: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:42: note: Unknown alignment for access: x
pa1-p1.c:42: note: vect_compute_data_ref_alignment:
pa1-p1.c:42: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:42: note: Unknown alignment for access: y
pa1-p1.c:42: note: vect_compute_data_ref_alignment:
pa1-p1.c:42: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:42: note: Unknown alignment for access: z
pa1-p1.c:42: note: vect_compute_data_ref_alignment:
pa1-p1.c:42: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:42: note: Unknown alignment for access: yy
pa1-p1.c:42: note: vect_compute_data_ref_alignment:
pa1-p1.c:42: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:42: note: Unknown alignment for access: zz
pa1-p1.c:42: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:42: note: === vect_analyze_slp ===
pa1-p1.c:42: note: Failed to SLP the basic block.
pa1-p1.c:42: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:45: note: ===vect_slp_analyze_bb===

pa1-p1.c:45: note: === vect_analyze_data_refs ===

pa1-p1.c:45: note: not vectorized: no vectype for stmt: MEM[(double[4096][4096] *)vect_pA.160_217] = vect_var_.158_239;
 scalar_type: vector(2) double
pa1-p1.c:45: note: === vect_pattern_recog ===
pa1-p1.c:45: note: vect_is_simple_use: operand vect_var_.153_248
pa1-p1.c:45: note: def_stmt: vect_var_.153_248 = [vec_unpack_float_lo_expr] vect_vec_iv_.152_250;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: vect_is_simple_use: operand vect_var_.153_247
pa1-p1.c:45: note: def_stmt: vect_var_.153_247 = [vec_unpack_float_hi_expr] vect_vec_iv_.152_250;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: vect_is_simple_use: operand vect_var_.156_242
pa1-p1.c:45: note: def_stmt: vect_var_.156_242 = vect_cst_.157_243 + vect_var_.154_245;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: vect_is_simple_use: operand vect_var_.156_241
pa1-p1.c:45: note: def_stmt: vect_var_.156_241 = vect_cst_.157_243 + vect_var_.154_244;

pa1-p1.c:45: note: type of def: 3.
pa1-p1.c:45: note: === vect_analyze_dependences ===
pa1-p1.c:45: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:45: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:45: note: === vect_analyze_slp ===
pa1-p1.c:45: note: Failed to SLP the basic block.
pa1-p1.c:45: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:40: note: ===vect_slp_analyze_bb===

pa1-p1.c:40: note: === vect_analyze_data_refs ===

pa1-p1.c:40: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:49: note: ===vect_slp_analyze_bb===

pa1-p1.c:49: note: === vect_analyze_data_refs ===

pa1-p1.c:49: note: get vectype with 4 units of type int
pa1-p1.c:49: note: vectype: vector(4) int
pa1-p1.c:49: note: === vect_pattern_recog ===
pa1-p1.c:49: note: === vect_analyze_dependences ===
pa1-p1.c:49: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:49: note: vect_compute_data_ref_alignment:
pa1-p1.c:49: note: force alignment of event_set
pa1-p1.c:49: note: misalign = 0 bytes of ref event_set
pa1-p1.c:49: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:49: note: not consecutive access event_set = -1;

pa1-p1.c:49: note: === vect_analyze_slp ===
pa1-p1.c:49: note: Failed to SLP the basic block.
pa1-p1.c:49: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:51: note: ===vect_slp_analyze_bb===

pa1-p1.c:51: note: === vect_analyze_data_refs ===

pa1-p1.c:51: note: get vectype with 2 units of type long unsigned int
pa1-p1.c:51: note: vectype: vector(2) long unsigned int
pa1-p1.c:51: note: === vect_pattern_recog ===
pa1-p1.c:51: note: === vect_analyze_dependences ===
pa1-p1.c:51: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:51: note: vect_compute_data_ref_alignment:
pa1-p1.c:51: note: can't force alignment of ref: stderr
pa1-p1.c:51: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:51: note: not consecutive access stderr.0_31 = stderr;

pa1-p1.c:51: note: === vect_analyze_slp ===
pa1-p1.c:51: note: Failed to SLP the basic block.
pa1-p1.c:51: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:52: note: ===vect_slp_analyze_bb===

pa1-p1.c:52: note: === vect_analyze_data_refs ===

pa1-p1.c:52: note: get vectype with 4 units of type int
pa1-p1.c:52: note: vectype: vector(4) int
pa1-p1.c:52: note: === vect_pattern_recog ===
pa1-p1.c:52: note: === vect_analyze_dependences ===
pa1-p1.c:52: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:52: note: vect_compute_data_ref_alignment:
pa1-p1.c:52: note: misalign = 0 bytes of ref event_set
pa1-p1.c:52: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:52: note: not consecutive access event_set.1_34 = event_set;

pa1-p1.c:52: note: === vect_analyze_slp ===
pa1-p1.c:52: note: Failed to SLP the basic block.
pa1-p1.c:52: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:52: note: ===vect_slp_analyze_bb===

pa1-p1.c:52: note: === vect_analyze_data_refs ===

pa1-p1.c:52: note: get vectype with 2 units of type long unsigned int
pa1-p1.c:52: note: vectype: vector(2) long unsigned int
pa1-p1.c:52: note: === vect_pattern_recog ===
pa1-p1.c:52: note: === vect_analyze_dependences ===
pa1-p1.c:52: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:52: note: vect_compute_data_ref_alignment:
pa1-p1.c:52: note: can't force alignment of ref: stderr
pa1-p1.c:52: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:52: note: not consecutive access stderr.0_37 = stderr;

pa1-p1.c:52: note: === vect_analyze_slp ===
pa1-p1.c:52: note: Failed to SLP the basic block.
pa1-p1.c:52: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:53: note: ===vect_slp_analyze_bb===

pa1-p1.c:53: note: === vect_analyze_data_refs ===

pa1-p1.c:53: note: get vectype with 4 units of type int
pa1-p1.c:53: note: vectype: vector(4) int
pa1-p1.c:53: note: === vect_pattern_recog ===
pa1-p1.c:53: note: === vect_analyze_dependences ===
pa1-p1.c:53: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:53: note: vect_compute_data_ref_alignment:
pa1-p1.c:53: note: misalign = 0 bytes of ref event_set
pa1-p1.c:53: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:53: note: not consecutive access event_set.1_40 = event_set;

pa1-p1.c:53: note: === vect_analyze_slp ===
pa1-p1.c:53: note: Failed to SLP the basic block.
pa1-p1.c:53: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:53: note: ===vect_slp_analyze_bb===

pa1-p1.c:53: note: === vect_analyze_data_refs ===

pa1-p1.c:53: note: get vectype with 2 units of type long unsigned int
pa1-p1.c:53: note: vectype: vector(2) long unsigned int
pa1-p1.c:53: note: === vect_pattern_recog ===
pa1-p1.c:53: note: === vect_analyze_dependences ===
pa1-p1.c:53: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:53: note: vect_compute_data_ref_alignment:
pa1-p1.c:53: note: can't force alignment of ref: stderr
pa1-p1.c:53: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:53: note: not consecutive access stderr.0_43 = stderr;

pa1-p1.c:53: note: === vect_analyze_slp ===
pa1-p1.c:53: note: Failed to SLP the basic block.
pa1-p1.c:53: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:54: note: ===vect_slp_analyze_bb===

pa1-p1.c:54: note: === vect_analyze_data_refs ===

pa1-p1.c:54: note: get vectype with 4 units of type int
pa1-p1.c:54: note: vectype: vector(4) int
pa1-p1.c:54: note: === vect_pattern_recog ===
pa1-p1.c:54: note: === vect_analyze_dependences ===
pa1-p1.c:54: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:54: note: vect_compute_data_ref_alignment:
pa1-p1.c:54: note: misalign = 0 bytes of ref event_set
pa1-p1.c:54: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:54: note: not consecutive access event_set.1_46 = event_set;

pa1-p1.c:54: note: === vect_analyze_slp ===
pa1-p1.c:54: note: Failed to SLP the basic block.
pa1-p1.c:54: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:54: note: ===vect_slp_analyze_bb===

pa1-p1.c:54: note: === vect_analyze_data_refs ===

pa1-p1.c:54: note: get vectype with 2 units of type long unsigned int
pa1-p1.c:54: note: vectype: vector(2) long unsigned int
pa1-p1.c:54: note: === vect_pattern_recog ===
pa1-p1.c:54: note: === vect_analyze_dependences ===
pa1-p1.c:54: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:54: note: vect_compute_data_ref_alignment:
pa1-p1.c:54: note: can't force alignment of ref: stderr
pa1-p1.c:54: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:54: note: not consecutive access stderr.0_49 = stderr;

pa1-p1.c:54: note: === vect_analyze_slp ===
pa1-p1.c:54: note: Failed to SLP the basic block.
pa1-p1.c:54: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:55: note: ===vect_slp_analyze_bb===

pa1-p1.c:55: note: === vect_analyze_data_refs ===

pa1-p1.c:55: note: get vectype with 4 units of type int
pa1-p1.c:55: note: vectype: vector(4) int
pa1-p1.c:55: note: === vect_pattern_recog ===
pa1-p1.c:55: note: === vect_analyze_dependences ===
pa1-p1.c:55: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:55: note: vect_compute_data_ref_alignment:
pa1-p1.c:55: note: misalign = 0 bytes of ref event_set
pa1-p1.c:55: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:55: note: not consecutive access event_set.1_52 = event_set;

pa1-p1.c:55: note: === vect_analyze_slp ===
pa1-p1.c:55: note: Failed to SLP the basic block.
pa1-p1.c:55: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:55: note: ===vect_slp_analyze_bb===

pa1-p1.c:55: note: === vect_analyze_data_refs ===

pa1-p1.c:55: note: get vectype with 2 units of type long unsigned int
pa1-p1.c:55: note: vectype: vector(2) long unsigned int
pa1-p1.c:55: note: === vect_pattern_recog ===
pa1-p1.c:55: note: === vect_analyze_dependences ===
pa1-p1.c:55: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:55: note: vect_compute_data_ref_alignment:
pa1-p1.c:55: note: can't force alignment of ref: stderr
pa1-p1.c:55: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:55: note: not consecutive access stderr.0_55 = stderr;

pa1-p1.c:55: note: === vect_analyze_slp ===
pa1-p1.c:55: note: Failed to SLP the basic block.
pa1-p1.c:55: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:57: note: ===vect_slp_analyze_bb===

pa1-p1.c:57: note: === vect_analyze_data_refs ===

pa1-p1.c:57: note: get vectype with 4 units of type int
pa1-p1.c:57: note: vectype: vector(4) int
pa1-p1.c:57: note: === vect_pattern_recog ===
pa1-p1.c:57: note: === vect_analyze_dependences ===
pa1-p1.c:57: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:57: note: vect_compute_data_ref_alignment:
pa1-p1.c:57: note: misalign = 0 bytes of ref event_set
pa1-p1.c:57: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:57: note: not consecutive access event_set.1_58 = event_set;

pa1-p1.c:57: note: === vect_analyze_slp ===
pa1-p1.c:57: note: Failed to SLP the basic block.
pa1-p1.c:57: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:57: note: ===vect_slp_analyze_bb===

pa1-p1.c:57: note: === vect_analyze_data_refs ===

pa1-p1.c:57: note: get vectype with 2 units of type long unsigned int
pa1-p1.c:57: note: vectype: vector(2) long unsigned int
pa1-p1.c:57: note: === vect_pattern_recog ===
pa1-p1.c:57: note: === vect_analyze_dependences ===
pa1-p1.c:57: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:57: note: vect_compute_data_ref_alignment:
pa1-p1.c:57: note: can't force alignment of ref: stderr
pa1-p1.c:57: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:57: note: not consecutive access stderr.0_61 = stderr;

pa1-p1.c:57: note: === vect_analyze_slp ===
pa1-p1.c:57: note: Failed to SLP the basic block.
pa1-p1.c:57: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:60: note: ===vect_slp_analyze_bb===

pa1-p1.c:60: note: === vect_analyze_data_refs ===

pa1-p1.c:60: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:101: note: ===vect_slp_analyze_bb===

pa1-p1.c:101: note: === vect_analyze_data_refs ===

pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: get vectype with 2 units of type double
pa1-p1.c:101: note: vectype: vector(2) double
pa1-p1.c:101: note: === vect_pattern_recog ===
pa1-p1.c:101: note: vect_is_simple_use: operand _116
pa1-p1.c:101: note: def_stmt: _116 = (long unsigned int) j_229;

pa1-p1.c:101: note: type of def: 3.
pa1-p1.c:101: note: vect_is_simple_use: operand j_229
pa1-p1.c:101: note: def_stmt: j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:101: note: type of def: 2.
pa1-p1.c:101: note: vect_is_simple_use: operand 8
pa1-p1.c:101: note: vect_is_simple_use: operand _126
pa1-p1.c:101: note: def_stmt: _126 = MEM[(double[0:D.4549] *)pretmp_291][j_229];

pa1-p1.c:101: note: type of def: 3.
pa1-p1.c:101: note: vect_is_simple_use: operand _116
pa1-p1.c:101: note: def_stmt: _116 = (long unsigned int) j_229;

pa1-p1.c:101: note: type of def: 3.
pa1-p1.c:101: note: vect_is_simple_use: operand j_229
pa1-p1.c:101: note: def_stmt: j_229 = PHI <j_141(21), 0(25)>

pa1-p1.c:101: note: type of def: 2.
pa1-p1.c:101: note: vect_is_simple_use: operand 32768
pa1-p1.c:101: note: vect_is_simple_use: operand _137
pa1-p1.c:101: note: def_stmt: _137 = MEM[(double[0:D.4549] *)_136][i_230];

pa1-p1.c:101: note: type of def: 3.
pa1-p1.c:101: note: === vect_analyze_dependences ===
pa1-p1.c:101: note: determined dependence between *_118 and *_118
pa1-p1.c:101: note: determined dependence between *_132 and *_132
pa1-p1.c:101: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:101: note: vect_compute_data_ref_alignment:
pa1-p1.c:101: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:101: note: Unknown alignment for access: y
pa1-p1.c:101: note: vect_compute_data_ref_alignment:
pa1-p1.c:101: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:101: note: Unknown alignment for access: *(&A + (long unsigned int) i_230 * 32768)
pa1-p1.c:101: note: vect_compute_data_ref_alignment:
pa1-p1.c:101: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:101: note: Unknown alignment for access: y
pa1-p1.c:101: note: vect_compute_data_ref_alignment:
pa1-p1.c:101: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:101: note: Unknown alignment for access: z
pa1-p1.c:101: note: vect_compute_data_ref_alignment:
pa1-p1.c:101: note: Unknown alignment for access: A
pa1-p1.c:101: note: vect_compute_data_ref_alignment:
pa1-p1.c:101: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:101: note: Unknown alignment for access: z
pa1-p1.c:101: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:101: note: Detected single element interleaving MEM[(double[0:D.4549] *)_136][i_230] step 32768
pa1-p1.c:101: note: === vect_analyze_slp ===
pa1-p1.c:101: note: Failed to SLP the basic block.
pa1-p1.c:101: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:98: note: ===vect_slp_analyze_bb===

pa1-p1.c:98: note: === vect_analyze_data_refs ===

pa1-p1.c:98: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: get vectype with 2 units of type double
pa1-p1.c:25: note: vectype: vector(2) double
pa1-p1.c:25: note: === vect_pattern_recog ===
pa1-p1.c:25: note: vect_is_simple_use: operand pretmp_289
pa1-p1.c:25: note: def_stmt: pretmp_289 = (long unsigned int) i_230;

pa1-p1.c:25: note: type of def: 3.
pa1-p1.c:25: note: vect_is_simple_use: operand i_230
pa1-p1.c:25: note: def_stmt: i_230 = PHI <0(28), i_142(24)>

pa1-p1.c:25: note: type of def: 2.
pa1-p1.c:25: note: vect_is_simple_use: operand 32768
pa1-p1.c:25: note: vect_is_simple_use: operand pretmp_289
pa1-p1.c:25: note: def_stmt: pretmp_289 = (long unsigned int) i_230;

pa1-p1.c:25: note: type of def: 3.
pa1-p1.c:25: note: vect_is_simple_use: operand i_230
pa1-p1.c:25: note: def_stmt: i_230 = PHI <0(28), i_142(24)>

pa1-p1.c:25: note: type of def: 2.
pa1-p1.c:25: note: vect_is_simple_use: operand 8
pa1-p1.c:25: note: === vect_analyze_dependences ===
pa1-p1.c:25: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:25: note: vect_compute_data_ref_alignment:
pa1-p1.c:25: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:25: note: Unknown alignment for access: x
pa1-p1.c:25: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:25: note: === vect_analyze_slp ===
pa1-p1.c:25: note: Failed to SLP the basic block.
pa1-p1.c:25: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:61: note: ===vect_slp_analyze_bb===

pa1-p1.c:61: note: === vect_analyze_data_refs ===

pa1-p1.c:61: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:62: note: ===vect_slp_analyze_bb===

pa1-p1.c:62: note: === vect_analyze_data_refs ===

pa1-p1.c:62: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:64: note: ===vect_slp_analyze_bb===

pa1-p1.c:64: note: === vect_analyze_data_refs ===

pa1-p1.c:64: note: get vectype with 2 units of type long unsigned int
pa1-p1.c:64: note: vectype: vector(2) long unsigned int
pa1-p1.c:64: note: === vect_pattern_recog ===
pa1-p1.c:64: note: === vect_analyze_dependences ===
pa1-p1.c:64: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:64: note: vect_compute_data_ref_alignment:
pa1-p1.c:64: note: can't force alignment of ref: stderr
pa1-p1.c:64: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:64: note: not consecutive access stderr.0_73 = stderr;

pa1-p1.c:64: note: === vect_analyze_slp ===
pa1-p1.c:64: note: Failed to SLP the basic block.
pa1-p1.c:64: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:65: note: ===vect_slp_analyze_bb===

pa1-p1.c:65: note: === vect_analyze_data_refs ===

pa1-p1.c:65: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:68: note: ===vect_slp_analyze_bb===

pa1-p1.c:68: note: === vect_analyze_data_refs ===

pa1-p1.c:68: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:69: note: ===vect_slp_analyze_bb===

pa1-p1.c:69: note: === vect_analyze_data_refs ===

pa1-p1.c:69: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:74: note: ===vect_slp_analyze_bb===

pa1-p1.c:74: note: === vect_analyze_data_refs ===

pa1-p1.c:74: note: not vectorized: no vectype for stmt: MEM[(double[4096] *)vect_pzz.145_259] = vect_cst_.144_261;
 scalar_type: vector(2) double
pa1-p1.c:74: note: === vect_pattern_recog ===
pa1-p1.c:74: note: === vect_analyze_dependences ===
pa1-p1.c:74: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:74: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:74: note: === vect_analyze_slp ===
pa1-p1.c:74: note: Failed to SLP the basic block.
pa1-p1.c:74: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:77: note: ===vect_slp_analyze_bb===

pa1-p1.c:77: note: === vect_analyze_data_refs ===

pa1-p1.c:77: note: get vectype with 4 units of type int
pa1-p1.c:77: note: vectype: vector(4) int
pa1-p1.c:77: note: === vect_pattern_recog ===
pa1-p1.c:77: note: === vect_analyze_dependences ===
pa1-p1.c:77: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:77: note: vect_compute_data_ref_alignment:
pa1-p1.c:77: note: misalign = 0 bytes of ref event_set
pa1-p1.c:77: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:77: note: not consecutive access event_set.1_86 = event_set;

pa1-p1.c:77: note: === vect_analyze_slp ===
pa1-p1.c:77: note: Failed to SLP the basic block.
pa1-p1.c:77: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:77: note: ===vect_slp_analyze_bb===

pa1-p1.c:77: note: === vect_analyze_data_refs ===

pa1-p1.c:77: note: get vectype with 2 units of type long unsigned int
pa1-p1.c:77: note: vectype: vector(2) long unsigned int
pa1-p1.c:77: note: === vect_pattern_recog ===
pa1-p1.c:77: note: === vect_analyze_dependences ===
pa1-p1.c:77: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:77: note: vect_compute_data_ref_alignment:
pa1-p1.c:77: note: can't force alignment of ref: stderr
pa1-p1.c:77: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:77: note: not consecutive access stderr.0_89 = stderr;

pa1-p1.c:77: note: === vect_analyze_slp ===
pa1-p1.c:77: note: Failed to SLP the basic block.
pa1-p1.c:77: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:79: note: ===vect_slp_analyze_bb===

pa1-p1.c:79: note: === vect_analyze_data_refs ===

pa1-p1.c:79: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:119: note: ===vect_slp_analyze_bb===

pa1-p1.c:119: note: === vect_analyze_data_refs ===

pa1-p1.c:119: note: not vectorized: no vectype for stmt: vect_var_.131_304 = MEM[(double *)vect_pyy.127_324];
 scalar_type: vector(2) double
pa1-p1.c:119: note: === vect_pattern_recog ===
pa1-p1.c:119: note: vect_is_simple_use: operand vect_var_.136_277
pa1-p1.c:119: note: def_stmt: vect_var_.136_277 = MEM[(double[0:D.4581] *)vect_p.132_299];

pa1-p1.c:119: note: type of def: 3.
pa1-p1.c:119: note: === vect_analyze_dependences ===
pa1-p1.c:119: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:119: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:119: note: === vect_analyze_slp ===
pa1-p1.c:119: note: Failed to SLP the basic block.
pa1-p1.c:119: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:118: note: ===vect_slp_analyze_bb===

pa1-p1.c:118: note: === vect_analyze_data_refs ===

pa1-p1.c:118: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: get vectype with 2 units of type double
pa1-p1.c:25: note: vectype: vector(2) double
pa1-p1.c:25: note: === vect_pattern_recog ===
pa1-p1.c:25: note: vect_is_simple_use: operand pretmp_316
pa1-p1.c:25: note: def_stmt: pretmp_316 = (long unsigned int) i_232;

pa1-p1.c:25: note: type of def: 3.
pa1-p1.c:25: note: vect_is_simple_use: operand i_232
pa1-p1.c:25: note: def_stmt: i_232 = PHI <0(52), i_162(43)>

pa1-p1.c:25: note: type of def: 2.
pa1-p1.c:25: note: vect_is_simple_use: operand 8
pa1-p1.c:25: note: vect_is_simple_use: operand _302
pa1-p1.c:25: note: def_stmt: _302 = (long unsigned int) i_232;

pa1-p1.c:25: note: type of def: 3.
pa1-p1.c:25: note: vect_is_simple_use: operand i_232
pa1-p1.c:25: note: def_stmt: i_232 = PHI <0(52), i_162(43)>

pa1-p1.c:25: note: type of def: 2.
pa1-p1.c:25: note: vect_is_simple_use: operand 32768
pa1-p1.c:25: note: === vect_analyze_dependences ===
pa1-p1.c:25: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:25: note: vect_compute_data_ref_alignment:
pa1-p1.c:25: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:25: note: Unknown alignment for access: x
pa1-p1.c:25: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:25: note: === vect_analyze_slp ===
pa1-p1.c:25: note: Failed to SLP the basic block.
pa1-p1.c:25: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:122: note: ===vect_slp_analyze_bb===

pa1-p1.c:122: note: === vect_analyze_data_refs ===

pa1-p1.c:122: note: get vectype with 2 units of type double
pa1-p1.c:122: note: vectype: vector(2) double
pa1-p1.c:122: note: get vectype with 2 units of type double
pa1-p1.c:122: note: vectype: vector(2) double
pa1-p1.c:122: note: === vect_pattern_recog ===
pa1-p1.c:122: note: vect_is_simple_use: operand _169
pa1-p1.c:122: note: def_stmt: _169 = (long unsigned int) i_234;

pa1-p1.c:122: note: type of def: 3.
pa1-p1.c:122: note: vect_is_simple_use: operand i_234
pa1-p1.c:122: note: def_stmt: i_234 = PHI <i_180(45), 0(49)>

pa1-p1.c:122: note: type of def: 2.
pa1-p1.c:122: note: vect_is_simple_use: operand 8
pa1-p1.c:122: note: vect_is_simple_use: operand _172
pa1-p1.c:122: note: def_stmt: _172 = *_171;

pa1-p1.c:122: note: type of def: 3.
pa1-p1.c:122: note: === vect_analyze_dependences ===
pa1-p1.c:122: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:122: note: vect_compute_data_ref_alignment:
pa1-p1.c:122: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:122: note: Unknown alignment for access: x
pa1-p1.c:122: note: vect_compute_data_ref_alignment:
pa1-p1.c:122: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:122: note: Unknown alignment for access: *(&A + (long unsigned int) j_233 * 32768)
pa1-p1.c:122: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:122: note: === vect_analyze_slp ===
pa1-p1.c:122: note: Failed to SLP the basic block.
pa1-p1.c:122: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:121: note: ===vect_slp_analyze_bb===

pa1-p1.c:121: note: === vect_analyze_data_refs ===

pa1-p1.c:121: note: get vectype with 2 units of type double
pa1-p1.c:121: note: vectype: vector(2) double
pa1-p1.c:121: note: === vect_pattern_recog ===
pa1-p1.c:121: note: === vect_analyze_dependences ===
pa1-p1.c:121: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:121: note: vect_compute_data_ref_alignment:
pa1-p1.c:121: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:121: note: Unknown alignment for access: zz
pa1-p1.c:121: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:121: note: === vect_analyze_slp ===
pa1-p1.c:121: note: Failed to SLP the basic block.
pa1-p1.c:121: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: get vectype with 2 units of type double
pa1-p1.c:25: note: vectype: vector(2) double
pa1-p1.c:25: note: === vect_pattern_recog ===
pa1-p1.c:25: note: vect_is_simple_use: operand pretmp_332
pa1-p1.c:25: note: def_stmt: pretmp_332 = (long unsigned int) j_233;

pa1-p1.c:25: note: type of def: 3.
pa1-p1.c:25: note: vect_is_simple_use: operand j_233
pa1-p1.c:25: note: def_stmt: j_233 = PHI <0(42), j_181(48)>

pa1-p1.c:25: note: type of def: 2.
pa1-p1.c:25: note: vect_is_simple_use: operand 8
pa1-p1.c:25: note: vect_is_simple_use: operand pretmp_332
pa1-p1.c:25: note: def_stmt: pretmp_332 = (long unsigned int) j_233;

pa1-p1.c:25: note: type of def: 3.
pa1-p1.c:25: note: vect_is_simple_use: operand j_233
pa1-p1.c:25: note: def_stmt: j_233 = PHI <0(42), j_181(48)>

pa1-p1.c:25: note: type of def: 2.
pa1-p1.c:25: note: vect_is_simple_use: operand 32768
pa1-p1.c:25: note: === vect_analyze_dependences ===
pa1-p1.c:25: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:25: note: vect_compute_data_ref_alignment:
pa1-p1.c:25: note: SLP: step doesn't divide the vector-size.
pa1-p1.c:25: note: Unknown alignment for access: zz
pa1-p1.c:25: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:25: note: === vect_analyze_slp ===
pa1-p1.c:25: note: Failed to SLP the basic block.
pa1-p1.c:25: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:80: note: ===vect_slp_analyze_bb===

pa1-p1.c:80: note: === vect_analyze_data_refs ===

pa1-p1.c:80: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:25: note: ===vect_slp_analyze_bb===

pa1-p1.c:25: note: === vect_analyze_data_refs ===

pa1-p1.c:25: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:81: note: ===vect_slp_analyze_bb===

pa1-p1.c:81: note: === vect_analyze_data_refs ===

pa1-p1.c:81: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:84: note: ===vect_slp_analyze_bb===

pa1-p1.c:84: note: === vect_analyze_data_refs ===

pa1-p1.c:84: note: get vectype with 2 units of type long unsigned int
pa1-p1.c:84: note: vectype: vector(2) long unsigned int
pa1-p1.c:84: note: === vect_pattern_recog ===
pa1-p1.c:84: note: === vect_analyze_dependences ===
pa1-p1.c:84: note: === vect_analyze_data_refs_alignment ===
pa1-p1.c:84: note: vect_compute_data_ref_alignment:
pa1-p1.c:84: note: can't force alignment of ref: stderr
pa1-p1.c:84: note: === vect_analyze_data_ref_accesses ===
pa1-p1.c:84: note: not consecutive access stderr.0_102 = stderr;

pa1-p1.c:84: note: === vect_analyze_slp ===
pa1-p1.c:84: note: Failed to SLP the basic block.
pa1-p1.c:84: note: not vectorized: failed to find SLP opportunities in basic block.

pa1-p1.c:85: note: ===vect_slp_analyze_bb===

pa1-p1.c:85: note: === vect_analyze_data_refs ===

pa1-p1.c:85: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:87: note: ===vect_slp_analyze_bb===

pa1-p1.c:87: note: === vect_analyze_data_refs ===

pa1-p1.c:87: note: not vectorized: not enough data-refs in basic block.

pa1-p1.c:88: note: ===vect_slp_analyze_bb===

pa1-p1.c:88: note: === vect_analyze_data_refs ===

pa1-p1.c:88: note: not vectorized: not enough data-refs in basic block.
